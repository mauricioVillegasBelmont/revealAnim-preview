/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/crypto-js/aes.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/aes.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Lookup tables\n\t    var SBOX = [];\n\t    var INV_SBOX = [];\n\t    var SUB_MIX_0 = [];\n\t    var SUB_MIX_1 = [];\n\t    var SUB_MIX_2 = [];\n\t    var SUB_MIX_3 = [];\n\t    var INV_SUB_MIX_0 = [];\n\t    var INV_SUB_MIX_1 = [];\n\t    var INV_SUB_MIX_2 = [];\n\t    var INV_SUB_MIX_3 = [];\n\n\t    // Compute lookup tables\n\t    (function () {\n\t        // Compute double table\n\t        var d = [];\n\t        for (var i = 0; i < 256; i++) {\n\t            if (i < 128) {\n\t                d[i] = i << 1;\n\t            } else {\n\t                d[i] = (i << 1) ^ 0x11b;\n\t            }\n\t        }\n\n\t        // Walk GF(2^8)\n\t        var x = 0;\n\t        var xi = 0;\n\t        for (var i = 0; i < 256; i++) {\n\t            // Compute sbox\n\t            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n\t            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n\t            SBOX[x] = sx;\n\t            INV_SBOX[sx] = x;\n\n\t            // Compute multiplication\n\t            var x2 = d[x];\n\t            var x4 = d[x2];\n\t            var x8 = d[x4];\n\n\t            // Compute sub bytes, mix columns tables\n\t            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n\t            SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n\t            SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n\t            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);\n\t            SUB_MIX_3[x] = t;\n\n\t            // Compute inv sub bytes, inv mix columns tables\n\t            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n\t            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n\t            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n\t            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);\n\t            INV_SUB_MIX_3[sx] = t;\n\n\t            // Compute next counter\n\t            if (!x) {\n\t                x = xi = 1;\n\t            } else {\n\t                x = x2 ^ d[d[d[x8 ^ x2]]];\n\t                xi ^= d[d[xi]];\n\t            }\n\t        }\n\t    }());\n\n\t    // Precomputed Rcon lookup\n\t    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n\t    /**\n\t     * AES block cipher algorithm.\n\t     */\n\t    var AES = C_algo.AES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            var t;\n\n\t            // Skip reset of nRounds has been set before and key did not change\n\t            if (this._nRounds && this._keyPriorReset === this._key) {\n\t                return;\n\t            }\n\n\t            // Shortcuts\n\t            var key = this._keyPriorReset = this._key;\n\t            var keyWords = key.words;\n\t            var keySize = key.sigBytes / 4;\n\n\t            // Compute number of rounds\n\t            var nRounds = this._nRounds = keySize + 6;\n\n\t            // Compute number of key schedule rows\n\t            var ksRows = (nRounds + 1) * 4;\n\n\t            // Compute key schedule\n\t            var keySchedule = this._keySchedule = [];\n\t            for (var ksRow = 0; ksRow < ksRows; ksRow++) {\n\t                if (ksRow < keySize) {\n\t                    keySchedule[ksRow] = keyWords[ksRow];\n\t                } else {\n\t                    t = keySchedule[ksRow - 1];\n\n\t                    if (!(ksRow % keySize)) {\n\t                        // Rot word\n\t                        t = (t << 8) | (t >>> 24);\n\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\n\t                        // Mix Rcon\n\t                        t ^= RCON[(ksRow / keySize) | 0] << 24;\n\t                    } else if (keySize > 6 && ksRow % keySize == 4) {\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\t                    }\n\n\t                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n\t                }\n\t            }\n\n\t            // Compute inv key schedule\n\t            var invKeySchedule = this._invKeySchedule = [];\n\t            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n\t                var ksRow = ksRows - invKsRow;\n\n\t                if (invKsRow % 4) {\n\t                    var t = keySchedule[ksRow];\n\t                } else {\n\t                    var t = keySchedule[ksRow - 4];\n\t                }\n\n\t                if (invKsRow < 4 || ksRow <= 4) {\n\t                    invKeySchedule[invKsRow] = t;\n\t                } else {\n\t                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n\t                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n\t                }\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            // Swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\n\t            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n\n\t            // Inv swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\t        },\n\n\t        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n\t            // Shortcut\n\t            var nRounds = this._nRounds;\n\n\t            // Get input, add round key\n\t            var s0 = M[offset]     ^ keySchedule[0];\n\t            var s1 = M[offset + 1] ^ keySchedule[1];\n\t            var s2 = M[offset + 2] ^ keySchedule[2];\n\t            var s3 = M[offset + 3] ^ keySchedule[3];\n\n\t            // Key schedule row counter\n\t            var ksRow = 4;\n\n\t            // Rounds\n\t            for (var round = 1; round < nRounds; round++) {\n\t                // Shift rows, sub bytes, mix columns, add round key\n\t                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];\n\t                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];\n\t                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];\n\t                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];\n\n\t                // Update state\n\t                s0 = t0;\n\t                s1 = t1;\n\t                s2 = t2;\n\t                s3 = t3;\n\t            }\n\n\t            // Shift rows, sub bytes, add round key\n\t            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];\n\n\t            // Set output\n\t            M[offset]     = t0;\n\t            M[offset + 1] = t1;\n\t            M[offset + 2] = t2;\n\t            M[offset + 3] = t3;\n\t        },\n\n\t        keySize: 256/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.AES = BlockCipher._createHelper(AES);\n\t}());\n\n\n\treturn CryptoJS.AES;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/aes.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/blowfish.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/blowfish.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    const N = 16;\n\n\t    //Origin pbox and sbox, derived from PI\n\t    const ORIG_P = [\n\t        0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,\n\t        0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,\n\t        0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,\n\t        0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,\n\t        0x9216D5D9, 0x8979FB1B\n\t    ];\n\n\t    const ORIG_S = [\n\t        [   0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7,\n\t            0xB8E1AFED, 0x6A267E96, 0xBA7C9045, 0xF12C7F99,\n\t            0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,\n\t            0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E,\n\t            0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE,\n\t            0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,\n\t            0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF,\n\t            0x8E79DCB0, 0x603A180E, 0x6C9E0E8B, 0xB01E8A3E,\n\t            0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,\n\t            0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440,\n\t            0x55CA396A, 0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE,\n\t            0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,\n\t            0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E,\n\t            0xAFD6BA33, 0x6C24CF5C, 0x7A325381, 0x28958677,\n\t            0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,\n\t            0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032,\n\t            0xEF845D5D, 0xE98575B1, 0xDC262302, 0xEB651B88,\n\t            0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,\n\t            0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E,\n\t            0x21C66842, 0xF6E96C9A, 0x670C9C61, 0xABD388F0,\n\t            0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,\n\t            0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98,\n\t            0xA1F1651D, 0x39AF0176, 0x66CA593E, 0x82430E88,\n\t            0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,\n\t            0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6,\n\t            0x4ED3AA62, 0x363F7706, 0x1BFEDF72, 0x429B023D,\n\t            0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,\n\t            0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7,\n\t            0xE3FE501A, 0xB6794C3B, 0x976CE0BD, 0x04C006BA,\n\t            0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,\n\t            0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F,\n\t            0x6DFC511F, 0x9B30952C, 0xCC814544, 0xAF5EBD09,\n\t            0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,\n\t            0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB,\n\t            0x5579C0BD, 0x1A60320A, 0xD6A100C6, 0x402C7279,\n\t            0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,\n\t            0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB,\n\t            0x323DB5FA, 0xFD238760, 0x53317B48, 0x3E00DF82,\n\t            0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,\n\t            0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573,\n\t            0x695B27B0, 0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0,\n\t            0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,\n\t            0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790,\n\t            0xE1DDF2DA, 0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8,\n\t            0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,\n\t            0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0,\n\t            0xD08ED1D0, 0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7,\n\t            0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,\n\t            0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD,\n\t            0x2F2F2218, 0xBE0E1777, 0xEA752DFE, 0x8B021FA1,\n\t            0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,\n\t            0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9,\n\t            0x165FA266, 0x80957705, 0x93CC7314, 0x211A1477,\n\t            0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,\n\t            0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49,\n\t            0x00250E2D, 0x2071B35E, 0x226800BB, 0x57B8E0AF,\n\t            0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,\n\t            0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5,\n\t            0x83260376, 0x6295CFA9, 0x11C81968, 0x4E734A41,\n\t            0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,\n\t            0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400,\n\t            0x08BA6FB5, 0x571BE91F, 0xF296EC6B, 0x2A0DD915,\n\t            0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,\n\t            0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A   ],\n\t        [   0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623,\n\t            0xAD6EA6B0, 0x49A7DF7D, 0x9CEE60B8, 0x8FEDB266,\n\t            0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,\n\t            0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E,\n\t            0x3F54989A, 0x5B429D65, 0x6B8FE4D6, 0x99F73FD6,\n\t            0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,\n\t            0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E,\n\t            0x09686B3F, 0x3EBAEFC9, 0x3C971814, 0x6B6A70A1,\n\t            0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,\n\t            0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8,\n\t            0xB03ADA37, 0xF0500C0D, 0xF01C1F04, 0x0200B3FF,\n\t            0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,\n\t            0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701,\n\t            0x3AE5E581, 0x37C2DADC, 0xC8B57634, 0x9AF3DDA7,\n\t            0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,\n\t            0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331,\n\t            0x4E548B38, 0x4F6DB908, 0x6F420D03, 0xF60A04BF,\n\t            0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,\n\t            0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E,\n\t            0x5512721F, 0x2E6B7124, 0x501ADDE6, 0x9F84CD87,\n\t            0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,\n\t            0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2,\n\t            0xEF1C1847, 0x3215D908, 0xDD433B37, 0x24C2BA16,\n\t            0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,\n\t            0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B,\n\t            0x043556F1, 0xD7A3C76B, 0x3C11183B, 0x5924A509,\n\t            0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,\n\t            0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3,\n\t            0x771FE71C, 0x4E3D06FA, 0x2965DCB9, 0x99E71D0F,\n\t            0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,\n\t            0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4,\n\t            0xF2F74EA7, 0x361D2B3D, 0x1939260F, 0x19C27960,\n\t            0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,\n\t            0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28,\n\t            0xC332DDEF, 0xBE6C5AA5, 0x65582185, 0x68AB9802,\n\t            0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,\n\t            0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510,\n\t            0x13CCA830, 0xEB61BD96, 0x0334FE1E, 0xAA0363CF,\n\t            0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,\n\t            0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E,\n\t            0x648B1EAF, 0x19BDF0CA, 0xA02369B9, 0x655ABB50,\n\t            0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,\n\t            0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8,\n\t            0xF837889A, 0x97E32D77, 0x11ED935F, 0x16681281,\n\t            0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,\n\t            0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696,\n\t            0xCDB30AEB, 0x532E3054, 0x8FD948E4, 0x6DBC3128,\n\t            0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,\n\t            0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0,\n\t            0x45EEE2B6, 0xA3AAABEA, 0xDB6C4F15, 0xFACB4FD0,\n\t            0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,\n\t            0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250,\n\t            0xCF62A1F2, 0x5B8D2646, 0xFC8883A0, 0xC1C7B6A3,\n\t            0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,\n\t            0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00,\n\t            0x58428D2A, 0x0C55F5EA, 0x1DADF43E, 0x233F7061,\n\t            0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,\n\t            0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E,\n\t            0xA6078084, 0x19F8509E, 0xE8EFD855, 0x61D99735,\n\t            0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,\n\t            0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9,\n\t            0xDB73DBD3, 0x105588CD, 0x675FDA79, 0xE3674340,\n\t            0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,\n\t            0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7   ],\n\t        [   0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934,\n\t            0x411520F7, 0x7602D4F7, 0xBCF46B2E, 0xD4A20068,\n\t            0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,\n\t            0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840,\n\t            0x4D95FC1D, 0x96B591AF, 0x70F4DDD3, 0x66A02F45,\n\t            0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,\n\t            0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A,\n\t            0x28507825, 0x530429F4, 0x0A2C86DA, 0xE9B66DFB,\n\t            0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,\n\t            0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6,\n\t            0xAACE1E7C, 0xD3375FEC, 0xCE78A399, 0x406B2A42,\n\t            0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,\n\t            0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2,\n\t            0x3A6EFA74, 0xDD5B4332, 0x6841E7F7, 0xCA7820FB,\n\t            0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,\n\t            0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B,\n\t            0x55A867BC, 0xA1159A58, 0xCCA92963, 0x99E1DB33,\n\t            0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,\n\t            0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3,\n\t            0x95C11548, 0xE4C66D22, 0x48C1133F, 0xC70F86DC,\n\t            0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,\n\t            0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564,\n\t            0x257B7834, 0x602A9C60, 0xDFF8E8A3, 0x1F636C1B,\n\t            0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,\n\t            0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922,\n\t            0x85B2A20E, 0xE6BA0D99, 0xDE720C8C, 0x2DA2F728,\n\t            0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,\n\t            0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E,\n\t            0x0A476341, 0x992EFF74, 0x3A6F6EAB, 0xF4F8FD37,\n\t            0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,\n\t            0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804,\n\t            0xF1290DC7, 0xCC00FFA3, 0xB5390F92, 0x690FED0B,\n\t            0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,\n\t            0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB,\n\t            0x37392EB3, 0xCC115979, 0x8026E297, 0xF42E312D,\n\t            0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,\n\t            0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350,\n\t            0x1A6B1018, 0x11CAEDFA, 0x3D25BDD8, 0xE2E1C3C9,\n\t            0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,\n\t            0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE,\n\t            0x9DBC8057, 0xF0F7C086, 0x60787BF8, 0x6003604D,\n\t            0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,\n\t            0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F,\n\t            0x77A057BE, 0xBDE8AE24, 0x55464299, 0xBF582E61,\n\t            0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,\n\t            0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9,\n\t            0x7AEB2661, 0x8B1DDF84, 0x846A0E79, 0x915F95E2,\n\t            0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,\n\t            0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E,\n\t            0xB77F19B6, 0xE0A9DC09, 0x662D09A1, 0xC4324633,\n\t            0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,\n\t            0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169,\n\t            0xDCB7DA83, 0x573906FE, 0xA1E2CE9B, 0x4FCD7F52,\n\t            0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,\n\t            0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5,\n\t            0xF0177A28, 0xC0F586E0, 0x006058AA, 0x30DC7D62,\n\t            0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,\n\t            0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76,\n\t            0x6F05E409, 0x4B7C0188, 0x39720A3D, 0x7C927C24,\n\t            0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,\n\t            0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4,\n\t            0x1E50EF5E, 0xB161E6F8, 0xA28514D9, 0x6C51133C,\n\t            0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,\n\t            0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0  ],\n\t        [   0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,\n\t            0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,\n\t            0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,\n\t            0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,\n\t            0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,\n\t            0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,\n\t            0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,\n\t            0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,\n\t            0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,\n\t            0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,\n\t            0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,\n\t            0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,\n\t            0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,\n\t            0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,\n\t            0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,\n\t            0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,\n\t            0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,\n\t            0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,\n\t            0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,\n\t            0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,\n\t            0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,\n\t            0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,\n\t            0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,\n\t            0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,\n\t            0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,\n\t            0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,\n\t            0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,\n\t            0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,\n\t            0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,\n\t            0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,\n\t            0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,\n\t            0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,\n\t            0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,\n\t            0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,\n\t            0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,\n\t            0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,\n\t            0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,\n\t            0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,\n\t            0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,\n\t            0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,\n\t            0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,\n\t            0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,\n\t            0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,\n\t            0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,\n\t            0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,\n\t            0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,\n\t            0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,\n\t            0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,\n\t            0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,\n\t            0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,\n\t            0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,\n\t            0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,\n\t            0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,\n\t            0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,\n\t            0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,\n\t            0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,\n\t            0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,\n\t            0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,\n\t            0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,\n\t            0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,\n\t            0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,\n\t            0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,\n\t            0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,\n\t            0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6  ]\n\t    ];\n\n\t    var BLOWFISH_CTX = {\n\t        pbox: [],\n\t        sbox: []\n\t    }\n\n\t    function F(ctx, x){\n\t        let a = (x >> 24) & 0xFF;\n\t        let b = (x >> 16) & 0xFF;\n\t        let c = (x >> 8) & 0xFF;\n\t        let d = x & 0xFF;\n\n\t        let y = ctx.sbox[0][a] + ctx.sbox[1][b];\n\t        y = y ^ ctx.sbox[2][c];\n\t        y = y + ctx.sbox[3][d];\n\n\t        return y;\n\t    }\n\n\t    function BlowFish_Encrypt(ctx, left, right){\n\t        let Xl = left;\n\t        let Xr = right;\n\t        let temp;\n\n\t        for(let i = 0; i < N; ++i){\n\t            Xl = Xl ^ ctx.pbox[i];\n\t            Xr = F(ctx, Xl) ^ Xr;\n\n\t            temp = Xl;\n\t            Xl = Xr;\n\t            Xr = temp;\n\t        }\n\n\t        temp = Xl;\n\t        Xl = Xr;\n\t        Xr = temp;\n\n\t        Xr = Xr ^ ctx.pbox[N];\n\t        Xl = Xl ^ ctx.pbox[N + 1];\n\n\t        return {left: Xl, right: Xr};\n\t    }\n\n\t    function BlowFish_Decrypt(ctx, left, right){\n\t        let Xl = left;\n\t        let Xr = right;\n\t        let temp;\n\n\t        for(let i = N + 1; i > 1; --i){\n\t            Xl = Xl ^ ctx.pbox[i];\n\t            Xr = F(ctx, Xl) ^ Xr;\n\n\t            temp = Xl;\n\t            Xl = Xr;\n\t            Xr = temp;\n\t        }\n\n\t        temp = Xl;\n\t        Xl = Xr;\n\t        Xr = temp;\n\n\t        Xr = Xr ^ ctx.pbox[1];\n\t        Xl = Xl ^ ctx.pbox[0];\n\n\t        return {left: Xl, right: Xr};\n\t    }\n\n\t    /**\n\t     * Initialization ctx's pbox and sbox.\n\t     *\n\t     * @param {Object} ctx The object has pbox and sbox.\n\t     * @param {Array} key An array of 32-bit words.\n\t     * @param {int} keysize The length of the key.\n\t     *\n\t     * @example\n\t     *\n\t     *     BlowFishInit(BLOWFISH_CTX, key, 128/32);\n\t     */\n\t    function BlowFishInit(ctx, key, keysize)\n\t    {\n\t        for(let Row = 0; Row < 4; Row++)\n\t        {\n\t            ctx.sbox[Row] = [];\n\t            for(let Col = 0; Col < 256; Col++)\n\t            {\n\t                ctx.sbox[Row][Col] = ORIG_S[Row][Col];\n\t            }\n\t        }\n\n\t        let keyIndex = 0;\n\t        for(let index = 0; index < N + 2; index++)\n\t        {\n\t            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];\n\t            keyIndex++;\n\t            if(keyIndex >= keysize)\n\t            {\n\t                keyIndex = 0;\n\t            }\n\t        }\n\n\t        let Data1 = 0;\n\t        let Data2 = 0;\n\t        let res = 0;\n\t        for(let i = 0; i < N + 2; i += 2)\n\t        {\n\t            res = BlowFish_Encrypt(ctx, Data1, Data2);\n\t            Data1 = res.left;\n\t            Data2 = res.right;\n\t            ctx.pbox[i] = Data1;\n\t            ctx.pbox[i + 1] = Data2;\n\t        }\n\n\t        for(let i = 0; i < 4; i++)\n\t        {\n\t            for(let j = 0; j < 256; j += 2)\n\t            {\n\t                res = BlowFish_Encrypt(ctx, Data1, Data2);\n\t                Data1 = res.left;\n\t                Data2 = res.right;\n\t                ctx.sbox[i][j] = Data1;\n\t                ctx.sbox[i][j + 1] = Data2;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    /**\n\t     * Blowfish block cipher algorithm.\n\t     */\n\t    var Blowfish = C_algo.Blowfish = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Skip reset of nRounds has been set before and key did not change\n\t            if (this._keyPriorReset === this._key) {\n\t                return;\n\t            }\n\n\t            // Shortcuts\n\t            var key = this._keyPriorReset = this._key;\n\t            var keyWords = key.words;\n\t            var keySize = key.sigBytes / 4;\n\n\t            //Initialization pbox and sbox\n\t            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);\n\t            M[offset] = res.left;\n\t            M[offset + 1] = res.right;\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);\n\t            M[offset] = res.left;\n\t            M[offset + 1] = res.right;\n\t        },\n\n\t        blockSize: 64/32,\n\n\t        keySize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.Blowfish.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.Blowfish.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.Blowfish = BlockCipher._createHelper(Blowfish);\n\t}());\n\n\n\treturn CryptoJS.Blowfish;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/blowfish.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/cipher-core.js":
/*!***********************************************!*\
  !*** ./node_modules/crypto-js/cipher-core.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher core components.\n\t */\n\tCryptoJS.lib.Cipher || (function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var Base64 = C_enc.Base64;\n\t    var C_algo = C.algo;\n\t    var EvpKDF = C_algo.EvpKDF;\n\n\t    /**\n\t     * Abstract base cipher template.\n\t     *\n\t     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n\t     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n\t     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n\t     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n\t     */\n\t    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {WordArray} iv The IV to use for this operation.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Creates this cipher in encryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createEncryptor: function (key, cfg) {\n\t            return this.create(this._ENC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Creates this cipher in decryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createDecryptor: function (key, cfg) {\n\t            return this.create(this._DEC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created cipher.\n\t         *\n\t         * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n\t         */\n\t        init: function (xformMode, key, cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Store transform mode and key\n\t            this._xformMode = xformMode;\n\t            this._key = key;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this cipher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     cipher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-cipher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Adds data to be encrypted or decrypted.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.process('data');\n\t         *     var encrypted = cipher.process(wordArray);\n\t         */\n\t        process: function (dataUpdate) {\n\t            // Append\n\t            this._append(dataUpdate);\n\n\t            // Process available blocks\n\t            return this._process();\n\t        },\n\n\t        /**\n\t         * Finalizes the encryption or decryption process.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after final processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.finalize();\n\t         *     var encrypted = cipher.finalize('data');\n\t         *     var encrypted = cipher.finalize(wordArray);\n\t         */\n\t        finalize: function (dataUpdate) {\n\t            // Final data update\n\t            if (dataUpdate) {\n\t                this._append(dataUpdate);\n\t            }\n\n\t            // Perform concrete-cipher logic\n\t            var finalProcessedData = this._doFinalize();\n\n\t            return finalProcessedData;\n\t        },\n\n\t        keySize: 128/32,\n\n\t        ivSize: 128/32,\n\n\t        _ENC_XFORM_MODE: 1,\n\n\t        _DEC_XFORM_MODE: 2,\n\n\t        /**\n\t         * Creates shortcut functions to a cipher's object interface.\n\t         *\n\t         * @param {Cipher} cipher The cipher to create a helper for.\n\t         *\n\t         * @return {Object} An object with encrypt and decrypt shortcut functions.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n\t         */\n\t        _createHelper: (function () {\n\t            function selectCipherStrategy(key) {\n\t                if (typeof key == 'string') {\n\t                    return PasswordBasedCipher;\n\t                } else {\n\t                    return SerializableCipher;\n\t                }\n\t            }\n\n\t            return function (cipher) {\n\t                return {\n\t                    encrypt: function (message, key, cfg) {\n\t                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\n\t                    },\n\n\t                    decrypt: function (ciphertext, key, cfg) {\n\t                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\n\t                    }\n\t                };\n\t            };\n\t        }())\n\t    });\n\n\t    /**\n\t     * Abstract base stream cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n\t     */\n\t    var StreamCipher = C_lib.StreamCipher = Cipher.extend({\n\t        _doFinalize: function () {\n\t            // Process partial blocks\n\t            var finalProcessedBlocks = this._process(!!'flush');\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 1\n\t    });\n\n\t    /**\n\t     * Mode namespace.\n\t     */\n\t    var C_mode = C.mode = {};\n\n\t    /**\n\t     * Abstract base block cipher mode template.\n\t     */\n\t    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\n\t        /**\n\t         * Creates this mode for encryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n\t         */\n\t        createEncryptor: function (cipher, iv) {\n\t            return this.Encryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Creates this mode for decryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n\t         */\n\t        createDecryptor: function (cipher, iv) {\n\t            return this.Decryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created mode.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n\t         */\n\t        init: function (cipher, iv) {\n\t            this._cipher = cipher;\n\t            this._iv = iv;\n\t        }\n\t    });\n\n\t    /**\n\t     * Cipher Block Chaining mode.\n\t     */\n\t    var CBC = C_mode.CBC = (function () {\n\t        /**\n\t         * Abstract base CBC mode.\n\t         */\n\t        var CBC = BlockCipherMode.extend();\n\n\t        /**\n\t         * CBC encryptor.\n\t         */\n\t        CBC.Encryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // XOR and encrypt\n\t                xorBlock.call(this, words, offset, blockSize);\n\t                cipher.encryptBlock(words, offset);\n\n\t                // Remember this block to use with next block\n\t                this._prevBlock = words.slice(offset, offset + blockSize);\n\t            }\n\t        });\n\n\t        /**\n\t         * CBC decryptor.\n\t         */\n\t        CBC.Decryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // Remember this block to use with next block\n\t                var thisBlock = words.slice(offset, offset + blockSize);\n\n\t                // Decrypt and XOR\n\t                cipher.decryptBlock(words, offset);\n\t                xorBlock.call(this, words, offset, blockSize);\n\n\t                // This block becomes the previous block\n\t                this._prevBlock = thisBlock;\n\t            }\n\t        });\n\n\t        function xorBlock(words, offset, blockSize) {\n\t            var block;\n\n\t            // Shortcut\n\t            var iv = this._iv;\n\n\t            // Choose mixing block\n\t            if (iv) {\n\t                block = iv;\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            } else {\n\t                block = this._prevBlock;\n\t            }\n\n\t            // XOR blocks\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= block[i];\n\t            }\n\t        }\n\n\t        return CBC;\n\t    }());\n\n\t    /**\n\t     * Padding namespace.\n\t     */\n\t    var C_pad = C.pad = {};\n\n\t    /**\n\t     * PKCS #5/7 padding strategy.\n\t     */\n\t    var Pkcs7 = C_pad.Pkcs7 = {\n\t        /**\n\t         * Pads data using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to pad.\n\t         * @param {number} blockSize The multiple that the data should be padded to.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n\t         */\n\t        pad: function (data, blockSize) {\n\t            // Shortcut\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count padding bytes\n\t            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t            // Create padding word\n\t            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n\t            // Create padding\n\t            var paddingWords = [];\n\t            for (var i = 0; i < nPaddingBytes; i += 4) {\n\t                paddingWords.push(paddingWord);\n\t            }\n\t            var padding = WordArray.create(paddingWords, nPaddingBytes);\n\n\t            // Add padding\n\t            data.concat(padding);\n\t        },\n\n\t        /**\n\t         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to unpad.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n\t         */\n\t        unpad: function (data) {\n\t            // Get number of padding bytes from last byte\n\t            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t            // Remove padding\n\t            data.sigBytes -= nPaddingBytes;\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract base block cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n\t     */\n\t    var BlockCipher = C_lib.BlockCipher = Cipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Mode} mode The block mode to use. Default: CBC\n\t         * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n\t         */\n\t        cfg: Cipher.cfg.extend({\n\t            mode: CBC,\n\t            padding: Pkcs7\n\t        }),\n\n\t        reset: function () {\n\t            var modeCreator;\n\n\t            // Reset cipher\n\t            Cipher.reset.call(this);\n\n\t            // Shortcuts\n\t            var cfg = this.cfg;\n\t            var iv = cfg.iv;\n\t            var mode = cfg.mode;\n\n\t            // Reset block mode\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                modeCreator = mode.createEncryptor;\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                modeCreator = mode.createDecryptor;\n\t                // Keep at least one block in the buffer for unpadding\n\t                this._minBufferSize = 1;\n\t            }\n\n\t            if (this._mode && this._mode.__creator == modeCreator) {\n\t                this._mode.init(this, iv && iv.words);\n\t            } else {\n\t                this._mode = modeCreator.call(mode, this, iv && iv.words);\n\t                this._mode.__creator = modeCreator;\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (words, offset) {\n\t            this._mode.processBlock(words, offset);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var finalProcessedBlocks;\n\n\t            // Shortcut\n\t            var padding = this.cfg.padding;\n\n\t            // Finalize\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                // Pad data\n\t                padding.pad(this._data, this.blockSize);\n\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\n\t                // Unpad data\n\t                padding.unpad(finalProcessedBlocks);\n\t            }\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 128/32\n\t    });\n\n\t    /**\n\t     * A collection of cipher parameters.\n\t     *\n\t     * @property {WordArray} ciphertext The raw ciphertext.\n\t     * @property {WordArray} key The key to this ciphertext.\n\t     * @property {WordArray} iv The IV used in the ciphering operation.\n\t     * @property {WordArray} salt The salt used with a key derivation function.\n\t     * @property {Cipher} algorithm The cipher algorithm.\n\t     * @property {Mode} mode The block mode used in the ciphering operation.\n\t     * @property {Padding} padding The padding scheme used in the ciphering operation.\n\t     * @property {number} blockSize The block size of the cipher.\n\t     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\n\t     */\n\t    var CipherParams = C_lib.CipherParams = Base.extend({\n\t        /**\n\t         * Initializes a newly created cipher params object.\n\t         *\n\t         * @param {Object} cipherParams An object with any of the possible cipher parameters.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.lib.CipherParams.create({\n\t         *         ciphertext: ciphertextWordArray,\n\t         *         key: keyWordArray,\n\t         *         iv: ivWordArray,\n\t         *         salt: saltWordArray,\n\t         *         algorithm: CryptoJS.algo.AES,\n\t         *         mode: CryptoJS.mode.CBC,\n\t         *         padding: CryptoJS.pad.PKCS7,\n\t         *         blockSize: 4,\n\t         *         formatter: CryptoJS.format.OpenSSL\n\t         *     });\n\t         */\n\t        init: function (cipherParams) {\n\t            this.mixIn(cipherParams);\n\t        },\n\n\t        /**\n\t         * Converts this cipher params object to a string.\n\t         *\n\t         * @param {Format} formatter (Optional) The formatting strategy to use.\n\t         *\n\t         * @return {string} The stringified cipher params.\n\t         *\n\t         * @throws Error If neither the formatter nor the default formatter is set.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = cipherParams + '';\n\t         *     var string = cipherParams.toString();\n\t         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n\t         */\n\t        toString: function (formatter) {\n\t            return (formatter || this.formatter).stringify(this);\n\t        }\n\t    });\n\n\t    /**\n\t     * Format namespace.\n\t     */\n\t    var C_format = C.format = {};\n\n\t    /**\n\t     * OpenSSL formatting strategy.\n\t     */\n\t    var OpenSSLFormatter = C_format.OpenSSL = {\n\t        /**\n\t         * Converts a cipher params object to an OpenSSL-compatible string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The OpenSSL-compatible string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            var wordArray;\n\n\t            // Shortcuts\n\t            var ciphertext = cipherParams.ciphertext;\n\t            var salt = cipherParams.salt;\n\n\t            // Format\n\t            if (salt) {\n\t                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n\t            } else {\n\t                wordArray = ciphertext;\n\t            }\n\n\t            return wordArray.toString(Base64);\n\t        },\n\n\t        /**\n\t         * Converts an OpenSSL-compatible string to a cipher params object.\n\t         *\n\t         * @param {string} openSSLStr The OpenSSL-compatible string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n\t         */\n\t        parse: function (openSSLStr) {\n\t            var salt;\n\n\t            // Parse base64\n\t            var ciphertext = Base64.parse(openSSLStr);\n\n\t            // Shortcut\n\t            var ciphertextWords = ciphertext.words;\n\n\t            // Test for salt\n\t            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\n\t                // Extract salt\n\t                salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n\t                // Remove salt from ciphertext\n\t                ciphertextWords.splice(0, 4);\n\t                ciphertext.sigBytes -= 16;\n\t            }\n\n\t            return CipherParams.create({ ciphertext: ciphertext, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var SerializableCipher = C_lib.SerializableCipher = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\n\t         */\n\t        cfg: Base.extend({\n\t            format: OpenSSLFormatter\n\t        }),\n\n\t        /**\n\t         * Encrypts a message.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Encrypt\n\t            var encryptor = cipher.createEncryptor(key, cfg);\n\t            var ciphertext = encryptor.finalize(message);\n\n\t            // Shortcut\n\t            var cipherCfg = encryptor.cfg;\n\n\t            // Create and return serializable cipher params\n\t            return CipherParams.create({\n\t                ciphertext: ciphertext,\n\t                key: key,\n\t                iv: cipherCfg.iv,\n\t                algorithm: cipher,\n\t                mode: cipherCfg.mode,\n\t                padding: cipherCfg.padding,\n\t                blockSize: cipher.blockSize,\n\t                formatter: cfg.format\n\t            });\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Decrypt\n\t            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n\t            return plaintext;\n\t        },\n\n\t        /**\n\t         * Converts serialized ciphertext to CipherParams,\n\t         * else assumed CipherParams already and returns ciphertext unchanged.\n\t         *\n\t         * @param {CipherParams|string} ciphertext The ciphertext.\n\t         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n\t         *\n\t         * @return {CipherParams} The unserialized ciphertext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n\t         */\n\t        _parse: function (ciphertext, format) {\n\t            if (typeof ciphertext == 'string') {\n\t                return format.parse(ciphertext, this);\n\t            } else {\n\t                return ciphertext;\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Key derivation function namespace.\n\t     */\n\t    var C_kdf = C.kdf = {};\n\n\t    /**\n\t     * OpenSSL key derivation function.\n\t     */\n\t    var OpenSSLKdf = C_kdf.OpenSSL = {\n\t        /**\n\t         * Derives a key and IV from a password.\n\t         *\n\t         * @param {string} password The password to derive from.\n\t         * @param {number} keySize The size in words of the key to generate.\n\t         * @param {number} ivSize The size in words of the IV to generate.\n\t         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n\t         *\n\t         * @return {CipherParams} A cipher params object with the key, IV, and salt.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n\t         */\n\t        execute: function (password, keySize, ivSize, salt, hasher) {\n\t            // Generate random salt\n\t            if (!salt) {\n\t                salt = WordArray.random(64/8);\n\t            }\n\n\t            // Derive key and IV\n\t            if (!hasher) {\n\t                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\n\t            } else {\n\t                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher: hasher }).compute(password, salt);\n\t            }\n\n\n\t            // Separate key and IV\n\t            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n\t            key.sigBytes = keySize * 4;\n\n\t            // Return params\n\t            return CipherParams.create({ key: key, iv: iv, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A serializable cipher wrapper that derives the key from a password,\n\t     * and returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\n\t         */\n\t        cfg: SerializableCipher.cfg.extend({\n\t            kdf: OpenSSLKdf\n\t        }),\n\n\t        /**\n\t         * Encrypts a message using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Encrypt\n\t            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\n\n\t            // Mix in derived params\n\t            ciphertext.mixIn(derivedParams);\n\n\t            return ciphertext;\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Decrypt\n\t            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\n\n\t            return plaintext;\n\t        }\n\t    });\n\t}());\n\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/cipher-core.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native crypto in web worker (Browser)\n\t    if (typeof self !== 'undefined' && self.crypto) {\n\t        crypto = self.crypto;\n\t    }\n\n\t    // Native crypto from worker\n\t    if (typeof globalThis !== 'undefined' && globalThis.crypto) {\n\t        crypto = globalThis.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {\n\t        crypto = __webpack_require__.g.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && \"function\" === 'function') {\n\t        try {\n\t            crypto = __webpack_require__(/*! crypto */ \"?9157\");\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }());\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var j = 0; j < thatSigBytes; j += 4) {\n\t                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/core.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/enc-base64.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64 encoding strategy.\n\t     */\n\t    var Base64 = C_enc.Base64 = {\n\t        /**\n\t         * Converts a word array to a Base64 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Base64 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64 string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n\t         */\n\t        parse: function (base64Str) {\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                    reverseMap = this._reverseMap = [];\n\t                    for (var j = 0; j < map.length; j++) {\n\t                        reverseMap[map.charCodeAt(j)] = j;\n\t                    }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t      var words = [];\n\t      var nBytes = 0;\n\t      for (var i = 0; i < base64StrLength; i++) {\n\t          if (i % 4) {\n\t              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t              var bitsCombined = bits1 | bits2;\n\t              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t              nBytes++;\n\t          }\n\t      }\n\t      return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Base64;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/enc-base64.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64url.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/enc-base64url.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64url encoding strategy.\n\t     */\n\t    var Base64url = C_enc.Base64url = {\n\t        /**\n\t         * Converts a word array to a Base64url string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @param {boolean} urlSafe Whether to use url safe\n\t         *\n\t         * @return {string} The Base64url string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray, urlSafe) {\n\t            if (urlSafe === undefined) {\n\t                urlSafe = true\n\t            }\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = urlSafe ? this._safe_map : this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64url string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64url string.\n\t         *\n\t         * @param {boolean} urlSafe Whether to use url safe\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);\n\t         */\n\t        parse: function (base64Str, urlSafe) {\n\t            if (urlSafe === undefined) {\n\t                urlSafe = true\n\t            }\n\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = urlSafe ? this._safe_map : this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                reverseMap = this._reverseMap = [];\n\t                for (var j = 0; j < map.length; j++) {\n\t                    reverseMap[map.charCodeAt(j)] = j;\n\t                }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n\t        _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t        var words = [];\n\t        var nBytes = 0;\n\t        for (var i = 0; i < base64StrLength; i++) {\n\t            if (i % 4) {\n\t                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t                var bitsCombined = bits1 | bits2;\n\t                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t                nBytes++;\n\t            }\n\t        }\n\t        return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Base64url;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/enc-base64url.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/enc-utf16.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/enc-utf16.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * UTF-16 BE encoding strategy.\n\t     */\n\t    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 BE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 BE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 BE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 BE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-16 LE encoding strategy.\n\t     */\n\t    C_enc.Utf16LE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 LE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 LE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 LE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 LE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    function swapEndian(word) {\n\t        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Utf16;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/enc-utf16.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/evpkdf.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/evpkdf.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./sha1 */ \"./node_modules/crypto-js/sha1.js\"), __webpack_require__(/*! ./hmac */ \"./node_modules/crypto-js/hmac.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var MD5 = C_algo.MD5;\n\n\t    /**\n\t     * This key derivation function is meant to conform with EVP_BytesToKey.\n\t     * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n\t     */\n\t    var EvpKDF = C_algo.EvpKDF = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n\t         * @property {number} iterations The number of iterations to perform. Default: 1\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: MD5,\n\t            iterations: 1\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create();\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Derives a key from a password.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            var block;\n\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init hasher\n\t            var hasher = cfg.hasher.create();\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                if (block) {\n\t                    hasher.update(block);\n\t                }\n\t                block = hasher.update(password).finalize(salt);\n\t                hasher.reset();\n\n\t                // Iterations\n\t                for (var i = 1; i < iterations; i++) {\n\t                    block = hasher.finalize(block);\n\t                    hasher.reset();\n\t                }\n\n\t                derivedKey.concat(block);\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Derives a key from a password.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.EvpKDF(password, salt);\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.EvpKDF = function (password, salt, cfg) {\n\t        return EvpKDF.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.EvpKDF;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/evpkdf.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/format-hex.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/format-hex.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var CipherParams = C_lib.CipherParams;\n\t    var C_enc = C.enc;\n\t    var Hex = C_enc.Hex;\n\t    var C_format = C.format;\n\n\t    var HexFormatter = C_format.Hex = {\n\t        /**\n\t         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The hexadecimally encoded string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            return cipherParams.ciphertext.toString(Hex);\n\t        },\n\n\t        /**\n\t         * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n\t         *\n\t         * @param {string} input The hexadecimally encoded string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n\t         */\n\t        parse: function (input) {\n\t            var ciphertext = Hex.parse(input);\n\t            return CipherParams.create({ ciphertext: ciphertext });\n\t        }\n\t    };\n\t}());\n\n\n\treturn CryptoJS.format.Hex;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/format-hex.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/hmac.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/hmac.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * HMAC algorithm.\n\t     */\n\t    var HMAC = C_algo.HMAC = Base.extend({\n\t        /**\n\t         * Initializes a newly created HMAC.\n\t         *\n\t         * @param {Hasher} hasher The hash algorithm to use.\n\t         * @param {WordArray|string} key The secret key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n\t         */\n\t        init: function (hasher, key) {\n\t            // Init hasher\n\t            hasher = this._hasher = new hasher.init();\n\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof key == 'string') {\n\t                key = Utf8.parse(key);\n\t            }\n\n\t            // Shortcuts\n\t            var hasherBlockSize = hasher.blockSize;\n\t            var hasherBlockSizeBytes = hasherBlockSize * 4;\n\n\t            // Allow arbitrary length keys\n\t            if (key.sigBytes > hasherBlockSizeBytes) {\n\t                key = hasher.finalize(key);\n\t            }\n\n\t            // Clamp excess bits\n\t            key.clamp();\n\n\t            // Clone key for inner and outer pads\n\t            var oKey = this._oKey = key.clone();\n\t            var iKey = this._iKey = key.clone();\n\n\t            // Shortcuts\n\t            var oKeyWords = oKey.words;\n\t            var iKeyWords = iKey.words;\n\n\t            // XOR keys with pad constants\n\t            for (var i = 0; i < hasherBlockSize; i++) {\n\t                oKeyWords[i] ^= 0x5c5c5c5c;\n\t                iKeyWords[i] ^= 0x36363636;\n\t            }\n\t            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this HMAC to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Reset\n\t            hasher.reset();\n\t            hasher.update(this._iKey);\n\t        },\n\n\t        /**\n\t         * Updates this HMAC with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {HMAC} This HMAC instance.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.update('message');\n\t         *     hmacHasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            this._hasher.update(messageUpdate);\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the HMAC computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The HMAC.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmac = hmacHasher.finalize();\n\t         *     var hmac = hmacHasher.finalize('message');\n\t         *     var hmac = hmacHasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Compute HMAC\n\t            var innerHash = hasher.finalize(messageUpdate);\n\t            hasher.reset();\n\t            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n\t            return hmac;\n\t        }\n\t    });\n\t}());\n\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/hmac.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/crypto-js/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"), __webpack_require__(/*! ./lib-typedarrays */ \"./node_modules/crypto-js/lib-typedarrays.js\"), __webpack_require__(/*! ./enc-utf16 */ \"./node_modules/crypto-js/enc-utf16.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./enc-base64url */ \"./node_modules/crypto-js/enc-base64url.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./sha1 */ \"./node_modules/crypto-js/sha1.js\"), __webpack_require__(/*! ./sha256 */ \"./node_modules/crypto-js/sha256.js\"), __webpack_require__(/*! ./sha224 */ \"./node_modules/crypto-js/sha224.js\"), __webpack_require__(/*! ./sha512 */ \"./node_modules/crypto-js/sha512.js\"), __webpack_require__(/*! ./sha384 */ \"./node_modules/crypto-js/sha384.js\"), __webpack_require__(/*! ./sha3 */ \"./node_modules/crypto-js/sha3.js\"), __webpack_require__(/*! ./ripemd160 */ \"./node_modules/crypto-js/ripemd160.js\"), __webpack_require__(/*! ./hmac */ \"./node_modules/crypto-js/hmac.js\"), __webpack_require__(/*! ./pbkdf2 */ \"./node_modules/crypto-js/pbkdf2.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"), __webpack_require__(/*! ./mode-cfb */ \"./node_modules/crypto-js/mode-cfb.js\"), __webpack_require__(/*! ./mode-ctr */ \"./node_modules/crypto-js/mode-ctr.js\"), __webpack_require__(/*! ./mode-ctr-gladman */ \"./node_modules/crypto-js/mode-ctr-gladman.js\"), __webpack_require__(/*! ./mode-ofb */ \"./node_modules/crypto-js/mode-ofb.js\"), __webpack_require__(/*! ./mode-ecb */ \"./node_modules/crypto-js/mode-ecb.js\"), __webpack_require__(/*! ./pad-ansix923 */ \"./node_modules/crypto-js/pad-ansix923.js\"), __webpack_require__(/*! ./pad-iso10126 */ \"./node_modules/crypto-js/pad-iso10126.js\"), __webpack_require__(/*! ./pad-iso97971 */ \"./node_modules/crypto-js/pad-iso97971.js\"), __webpack_require__(/*! ./pad-zeropadding */ \"./node_modules/crypto-js/pad-zeropadding.js\"), __webpack_require__(/*! ./pad-nopadding */ \"./node_modules/crypto-js/pad-nopadding.js\"), __webpack_require__(/*! ./format-hex */ \"./node_modules/crypto-js/format-hex.js\"), __webpack_require__(/*! ./aes */ \"./node_modules/crypto-js/aes.js\"), __webpack_require__(/*! ./tripledes */ \"./node_modules/crypto-js/tripledes.js\"), __webpack_require__(/*! ./rc4 */ \"./node_modules/crypto-js/rc4.js\"), __webpack_require__(/*! ./rabbit */ \"./node_modules/crypto-js/rabbit.js\"), __webpack_require__(/*! ./rabbit-legacy */ \"./node_modules/crypto-js/rabbit-legacy.js\"), __webpack_require__(/*! ./blowfish */ \"./node_modules/crypto-js/blowfish.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/index.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/lib-typedarrays.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/lib-typedarrays.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Check if typed arrays are supported\n\t    if (typeof ArrayBuffer != 'function') {\n\t        return;\n\t    }\n\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\n\t    // Reference original init\n\t    var superInit = WordArray.init;\n\n\t    // Augment WordArray.init to handle typed arrays\n\t    var subInit = WordArray.init = function (typedArray) {\n\t        // Convert buffers to uint8\n\t        if (typedArray instanceof ArrayBuffer) {\n\t            typedArray = new Uint8Array(typedArray);\n\t        }\n\n\t        // Convert other array views to uint8\n\t        if (\n\t            typedArray instanceof Int8Array ||\n\t            (typeof Uint8ClampedArray !== \"undefined\" && typedArray instanceof Uint8ClampedArray) ||\n\t            typedArray instanceof Int16Array ||\n\t            typedArray instanceof Uint16Array ||\n\t            typedArray instanceof Int32Array ||\n\t            typedArray instanceof Uint32Array ||\n\t            typedArray instanceof Float32Array ||\n\t            typedArray instanceof Float64Array\n\t        ) {\n\t            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n\t        }\n\n\t        // Handle Uint8Array\n\t        if (typedArray instanceof Uint8Array) {\n\t            // Shortcut\n\t            var typedArrayByteLength = typedArray.byteLength;\n\n\t            // Extract bytes\n\t            var words = [];\n\t            for (var i = 0; i < typedArrayByteLength; i++) {\n\t                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n\t            }\n\n\t            // Initialize this word array\n\t            superInit.call(this, words, typedArrayByteLength);\n\t        } else {\n\t            // Else call normal init\n\t            superInit.apply(this, arguments);\n\t        }\n\t    };\n\n\t    subInit.prototype = WordArray;\n\t}());\n\n\n\treturn CryptoJS.lib.WordArray;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/lib-typedarrays.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/md5.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/md5.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var T = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        for (var i = 0; i < 64; i++) {\n\t            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n\t        }\n\t    }());\n\n\t    /**\n\t     * MD5 hash algorithm.\n\t     */\n\t    var MD5 = C_algo.MD5 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var M_offset_0  = M[offset + 0];\n\t            var M_offset_1  = M[offset + 1];\n\t            var M_offset_2  = M[offset + 2];\n\t            var M_offset_3  = M[offset + 3];\n\t            var M_offset_4  = M[offset + 4];\n\t            var M_offset_5  = M[offset + 5];\n\t            var M_offset_6  = M[offset + 6];\n\t            var M_offset_7  = M[offset + 7];\n\t            var M_offset_8  = M[offset + 8];\n\t            var M_offset_9  = M[offset + 9];\n\t            var M_offset_10 = M[offset + 10];\n\t            var M_offset_11 = M[offset + 11];\n\t            var M_offset_12 = M[offset + 12];\n\t            var M_offset_13 = M[offset + 13];\n\t            var M_offset_14 = M[offset + 14];\n\t            var M_offset_15 = M[offset + 15];\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\n\t            // Computation\n\t            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);\n\t            d = FF(d, a, b, c, M_offset_1,  12, T[1]);\n\t            c = FF(c, d, a, b, M_offset_2,  17, T[2]);\n\t            b = FF(b, c, d, a, M_offset_3,  22, T[3]);\n\t            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);\n\t            d = FF(d, a, b, c, M_offset_5,  12, T[5]);\n\t            c = FF(c, d, a, b, M_offset_6,  17, T[6]);\n\t            b = FF(b, c, d, a, M_offset_7,  22, T[7]);\n\t            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);\n\t            d = FF(d, a, b, c, M_offset_9,  12, T[9]);\n\t            c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n\t            b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n\t            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);\n\t            d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n\t            c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n\t            b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n\t            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);\n\t            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);\n\t            c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n\t            b = GG(b, c, d, a, M_offset_0,  20, T[19]);\n\t            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);\n\t            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);\n\t            c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n\t            b = GG(b, c, d, a, M_offset_4,  20, T[23]);\n\t            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);\n\t            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);\n\t            c = GG(c, d, a, b, M_offset_3,  14, T[26]);\n\t            b = GG(b, c, d, a, M_offset_8,  20, T[27]);\n\t            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);\n\t            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);\n\t            c = GG(c, d, a, b, M_offset_7,  14, T[30]);\n\t            b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n\t            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);\n\t            d = HH(d, a, b, c, M_offset_8,  11, T[33]);\n\t            c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n\t            b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n\t            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);\n\t            d = HH(d, a, b, c, M_offset_4,  11, T[37]);\n\t            c = HH(c, d, a, b, M_offset_7,  16, T[38]);\n\t            b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n\t            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);\n\t            d = HH(d, a, b, c, M_offset_0,  11, T[41]);\n\t            c = HH(c, d, a, b, M_offset_3,  16, T[42]);\n\t            b = HH(b, c, d, a, M_offset_6,  23, T[43]);\n\t            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);\n\t            d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n\t            c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n\t            b = HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n\t            a = II(a, b, c, d, M_offset_0,  6,  T[48]);\n\t            d = II(d, a, b, c, M_offset_7,  10, T[49]);\n\t            c = II(c, d, a, b, M_offset_14, 15, T[50]);\n\t            b = II(b, c, d, a, M_offset_5,  21, T[51]);\n\t            a = II(a, b, c, d, M_offset_12, 6,  T[52]);\n\t            d = II(d, a, b, c, M_offset_3,  10, T[53]);\n\t            c = II(c, d, a, b, M_offset_10, 15, T[54]);\n\t            b = II(b, c, d, a, M_offset_1,  21, T[55]);\n\t            a = II(a, b, c, d, M_offset_8,  6,  T[56]);\n\t            d = II(d, a, b, c, M_offset_15, 10, T[57]);\n\t            c = II(c, d, a, b, M_offset_6,  15, T[58]);\n\t            b = II(b, c, d, a, M_offset_13, 21, T[59]);\n\t            a = II(a, b, c, d, M_offset_4,  6,  T[60]);\n\t            d = II(d, a, b, c, M_offset_11, 10, T[61]);\n\t            c = II(c, d, a, b, M_offset_2,  15, T[62]);\n\t            b = II(b, c, d, a, M_offset_9,  21, T[63]);\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n\t            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n\t            var nBitsTotalL = nBitsTotal;\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n\t                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n\t            );\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n\t            );\n\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    function FF(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & c) | (~b & d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function GG(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & d) | (c & ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function HH(a, b, c, d, x, s, t) {\n\t        var n = a + (b ^ c ^ d) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function II(a, b, c, d, x, s, t) {\n\t        var n = a + (c ^ (b | ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.MD5('message');\n\t     *     var hash = CryptoJS.MD5(wordArray);\n\t     */\n\t    C.MD5 = Hasher._createHelper(MD5);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacMD5(message, key);\n\t     */\n\t    C.HmacMD5 = Hasher._createHmacHelper(MD5);\n\t}(Math));\n\n\n\treturn CryptoJS.MD5;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/md5.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/mode-cfb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-cfb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher Feedback block mode.\n\t */\n\tCryptoJS.mode.CFB = (function () {\n\t    var CFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    CFB.Encryptor = CFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher;\n\t            var blockSize = cipher.blockSize;\n\n\t            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t            // Remember this block to use with next block\n\t            this._prevBlock = words.slice(offset, offset + blockSize);\n\t        }\n\t    });\n\n\t    CFB.Decryptor = CFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher;\n\t            var blockSize = cipher.blockSize;\n\n\t            // Remember this block to use with next block\n\t            var thisBlock = words.slice(offset, offset + blockSize);\n\n\t            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t            // This block becomes the previous block\n\t            this._prevBlock = thisBlock;\n\t        }\n\t    });\n\n\t    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n\t        var keystream;\n\n\t        // Shortcut\n\t        var iv = this._iv;\n\n\t        // Generate keystream\n\t        if (iv) {\n\t            keystream = iv.slice(0);\n\n\t            // Remove IV for subsequent blocks\n\t            this._iv = undefined;\n\t        } else {\n\t            keystream = this._prevBlock;\n\t        }\n\t        cipher.encryptBlock(keystream, 0);\n\n\t        // Encrypt\n\t        for (var i = 0; i < blockSize; i++) {\n\t            words[offset + i] ^= keystream[i];\n\t        }\n\t    }\n\n\t    return CFB;\n\t}());\n\n\n\treturn CryptoJS.mode.CFB;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/mode-cfb.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ctr-gladman.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-js/mode-ctr-gladman.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/** @preserve\n\t * Counter block mode compatible with  Dr Brian Gladman fileenc.c\n\t * derived from CryptoJS.mode.CTR\n\t * Jan Hruby jhruby.web@gmail.com\n\t */\n\tCryptoJS.mode.CTRGladman = (function () {\n\t    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();\n\n\t\tfunction incWord(word)\n\t\t{\n\t\t\tif (((word >> 24) & 0xff) === 0xff) { //overflow\n\t\t\tvar b1 = (word >> 16)&0xff;\n\t\t\tvar b2 = (word >> 8)&0xff;\n\t\t\tvar b3 = word & 0xff;\n\n\t\t\tif (b1 === 0xff) // overflow b1\n\t\t\t{\n\t\t\tb1 = 0;\n\t\t\tif (b2 === 0xff)\n\t\t\t{\n\t\t\t\tb2 = 0;\n\t\t\t\tif (b3 === 0xff)\n\t\t\t\t{\n\t\t\t\t\tb3 = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++b3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++b2;\n\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t++b1;\n\t\t\t}\n\n\t\t\tword = 0;\n\t\t\tword += (b1 << 16);\n\t\t\tword += (b2 << 8);\n\t\t\tword += b3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tword += (0x01 << 24);\n\t\t\t}\n\t\t\treturn word;\n\t\t}\n\n\t\tfunction incCounter(counter)\n\t\t{\n\t\t\tif ((counter[0] = incWord(counter[0])) === 0)\n\t\t\t{\n\t\t\t\t// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8\n\t\t\t\tcounter[1] = incWord(counter[1]);\n\t\t\t}\n\t\t\treturn counter;\n\t\t}\n\n\t    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var counter = this._counter;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                counter = this._counter = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\n\t\t\t\tincCounter(counter);\n\n\t\t\t\tvar keystream = counter.slice(0);\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    CTRGladman.Decryptor = Encryptor;\n\n\t    return CTRGladman;\n\t}());\n\n\n\n\n\treturn CryptoJS.mode.CTRGladman;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/mode-ctr-gladman.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ctr.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ctr.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Counter block mode.\n\t */\n\tCryptoJS.mode.CTR = (function () {\n\t    var CTR = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    var Encryptor = CTR.Encryptor = CTR.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var counter = this._counter;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                counter = this._counter = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\t            var keystream = counter.slice(0);\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Increment counter\n\t            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    CTR.Decryptor = Encryptor;\n\n\t    return CTR;\n\t}());\n\n\n\treturn CryptoJS.mode.CTR;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/mode-ctr.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ecb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ecb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Electronic Codebook block mode.\n\t */\n\tCryptoJS.mode.ECB = (function () {\n\t    var ECB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    ECB.Encryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.encryptBlock(words, offset);\n\t        }\n\t    });\n\n\t    ECB.Decryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.decryptBlock(words, offset);\n\t        }\n\t    });\n\n\t    return ECB;\n\t}());\n\n\n\treturn CryptoJS.mode.ECB;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/mode-ecb.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ofb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ofb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Output Feedback block mode.\n\t */\n\tCryptoJS.mode.OFB = (function () {\n\t    var OFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    var Encryptor = OFB.Encryptor = OFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var keystream = this._keystream;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                keystream = this._keystream = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    OFB.Decryptor = Encryptor;\n\n\t    return OFB;\n\t}());\n\n\n\treturn CryptoJS.mode.OFB;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/mode-ofb.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/pad-ansix923.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-ansix923.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ANSI X.923 padding strategy.\n\t */\n\tCryptoJS.pad.AnsiX923 = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcuts\n\t        var dataSigBytes = data.sigBytes;\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Count padding bytes\n\t        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;\n\n\t        // Compute last byte position\n\t        var lastBytePos = dataSigBytes + nPaddingBytes - 1;\n\n\t        // Pad\n\t        data.clamp();\n\t        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);\n\t        data.sigBytes += nPaddingBytes;\n\t    },\n\n\t    unpad: function (data) {\n\t        // Get number of padding bytes from last byte\n\t        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t        // Remove padding\n\t        data.sigBytes -= nPaddingBytes;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Ansix923;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/pad-ansix923.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/pad-iso10126.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-iso10126.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ISO 10126 padding strategy.\n\t */\n\tCryptoJS.pad.Iso10126 = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcut\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Count padding bytes\n\t        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t        // Pad\n\t        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).\n\t             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));\n\t    },\n\n\t    unpad: function (data) {\n\t        // Get number of padding bytes from last byte\n\t        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t        // Remove padding\n\t        data.sigBytes -= nPaddingBytes;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Iso10126;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/pad-iso10126.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/pad-iso97971.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-iso97971.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ISO/IEC 9797-1 Padding Method 2.\n\t */\n\tCryptoJS.pad.Iso97971 = {\n\t    pad: function (data, blockSize) {\n\t        // Add 0x80 byte\n\t        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));\n\n\t        // Zero pad the rest\n\t        CryptoJS.pad.ZeroPadding.pad(data, blockSize);\n\t    },\n\n\t    unpad: function (data) {\n\t        // Remove zero padding\n\t        CryptoJS.pad.ZeroPadding.unpad(data);\n\n\t        // Remove one more byte -- the 0x80 byte\n\t        data.sigBytes--;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Iso97971;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/pad-iso97971.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/pad-nopadding.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/pad-nopadding.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * A noop padding strategy.\n\t */\n\tCryptoJS.pad.NoPadding = {\n\t    pad: function () {\n\t    },\n\n\t    unpad: function () {\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.NoPadding;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/pad-nopadding.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/pad-zeropadding.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/pad-zeropadding.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Zero padding strategy.\n\t */\n\tCryptoJS.pad.ZeroPadding = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcut\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Pad\n\t        data.clamp();\n\t        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);\n\t    },\n\n\t    unpad: function (data) {\n\t        // Shortcut\n\t        var dataWords = data.words;\n\n\t        // Unpad\n\t        var i = data.sigBytes - 1;\n\t        for (var i = data.sigBytes - 1; i >= 0; i--) {\n\t            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {\n\t                data.sigBytes = i + 1;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.ZeroPadding;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/pad-zeropadding.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/pbkdf2.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/pbkdf2.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./sha256 */ \"./node_modules/crypto-js/sha256.js\"), __webpack_require__(/*! ./hmac */ \"./node_modules/crypto-js/hmac.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA256 = C_algo.SHA256;\n\t    var HMAC = C_algo.HMAC;\n\n\t    /**\n\t     * Password-Based Key Derivation Function 2 algorithm.\n\t     */\n\t    var PBKDF2 = C_algo.PBKDF2 = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hasher to use. Default: SHA256\n\t         * @property {number} iterations The number of iterations to perform. Default: 250000\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: SHA256,\n\t            iterations: 250000\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create();\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Computes the Password-Based Key Derivation Function 2.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init HMAC\n\t            var hmac = HMAC.create(cfg.hasher, password);\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\t            var blockIndex = WordArray.create([0x00000001]);\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var blockIndexWords = blockIndex.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                var block = hmac.update(salt).finalize(blockIndex);\n\t                hmac.reset();\n\n\t                // Shortcuts\n\t                var blockWords = block.words;\n\t                var blockWordsLength = blockWords.length;\n\n\t                // Iterations\n\t                var intermediate = block;\n\t                for (var i = 1; i < iterations; i++) {\n\t                    intermediate = hmac.finalize(intermediate);\n\t                    hmac.reset();\n\n\t                    // Shortcut\n\t                    var intermediateWords = intermediate.words;\n\n\t                    // XOR intermediate with block\n\t                    for (var j = 0; j < blockWordsLength; j++) {\n\t                        blockWords[j] ^= intermediateWords[j];\n\t                    }\n\t                }\n\n\t                derivedKey.concat(block);\n\t                blockIndexWords[0]++;\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Computes the Password-Based Key Derivation Function 2.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.PBKDF2(password, salt);\n\t     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.PBKDF2 = function (password, salt, cfg) {\n\t        return PBKDF2.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.PBKDF2;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/pbkdf2.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/rabbit-legacy.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/rabbit-legacy.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable objects\n\t    var S  = [];\n\t    var C_ = [];\n\t    var G  = [];\n\n\t    /**\n\t     * Rabbit stream cipher algorithm.\n\t     *\n\t     * This is a legacy version that neglected to convert the key to little-endian.\n\t     * This error doesn't affect the cipher's security,\n\t     * but it does affect its compatibility with other implementations.\n\t     */\n\t    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var K = this._key.words;\n\t            var iv = this.cfg.iv;\n\n\t            // Generate initial state values\n\t            var X = this._X = [\n\t                K[0], (K[3] << 16) | (K[2] >>> 16),\n\t                K[1], (K[0] << 16) | (K[3] >>> 16),\n\t                K[2], (K[1] << 16) | (K[0] >>> 16),\n\t                K[3], (K[2] << 16) | (K[1] >>> 16)\n\t            ];\n\n\t            // Generate initial counter values\n\t            var C = this._C = [\n\t                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n\t                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n\t                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n\t                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\n\t            ];\n\n\t            // Carry bit\n\t            this._b = 0;\n\n\t            // Iterate the system four times\n\t            for (var i = 0; i < 4; i++) {\n\t                nextState.call(this);\n\t            }\n\n\t            // Modify the counters\n\t            for (var i = 0; i < 8; i++) {\n\t                C[i] ^= X[(i + 4) & 7];\n\t            }\n\n\t            // IV setup\n\t            if (iv) {\n\t                // Shortcuts\n\t                var IV = iv.words;\n\t                var IV_0 = IV[0];\n\t                var IV_1 = IV[1];\n\n\t                // Generate four subvectors\n\t                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n\t                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n\t                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n\t                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);\n\n\t                // Modify counter values\n\t                C[0] ^= i0;\n\t                C[1] ^= i1;\n\t                C[2] ^= i2;\n\t                C[3] ^= i3;\n\t                C[4] ^= i0;\n\t                C[5] ^= i1;\n\t                C[6] ^= i2;\n\t                C[7] ^= i3;\n\n\t                // Iterate the system four times\n\t                for (var i = 0; i < 4; i++) {\n\t                    nextState.call(this);\n\t                }\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var X = this._X;\n\n\t            // Iterate the system\n\t            nextState.call(this);\n\n\t            // Generate four keystream words\n\t            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n\t            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n\t            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n\t            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n\t            for (var i = 0; i < 4; i++) {\n\t                // Swap endian\n\t                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);\n\n\t                // Encrypt\n\t                M[offset + i] ^= S[i];\n\t            }\n\t        },\n\n\t        blockSize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    function nextState() {\n\t        // Shortcuts\n\t        var X = this._X;\n\t        var C = this._C;\n\n\t        // Save old counter values\n\t        for (var i = 0; i < 8; i++) {\n\t            C_[i] = C[i];\n\t        }\n\n\t        // Calculate new counter values\n\t        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n\t        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n\t        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n\t        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n\t        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n\t        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n\t        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n\t        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n\t        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n\t        // Calculate the g-values\n\t        for (var i = 0; i < 8; i++) {\n\t            var gx = X[i] + C[i];\n\n\t            // Construct high and low argument for squaring\n\t            var ga = gx & 0xffff;\n\t            var gb = gx >>> 16;\n\n\t            // Calculate high and low result of squaring\n\t            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n\t            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n\t            // High XOR low\n\t            G[i] = gh ^ gl;\n\t        }\n\n\t        // Calculate new state values\n\t        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n\t        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;\n\t        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n\t        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;\n\t        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n\t        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;\n\t        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n\t        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);\n\t}());\n\n\n\treturn CryptoJS.RabbitLegacy;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/rabbit-legacy.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/rabbit.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/rabbit.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable objects\n\t    var S  = [];\n\t    var C_ = [];\n\t    var G  = [];\n\n\t    /**\n\t     * Rabbit stream cipher algorithm\n\t     */\n\t    var Rabbit = C_algo.Rabbit = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var K = this._key.words;\n\t            var iv = this.cfg.iv;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Generate initial state values\n\t            var X = this._X = [\n\t                K[0], (K[3] << 16) | (K[2] >>> 16),\n\t                K[1], (K[0] << 16) | (K[3] >>> 16),\n\t                K[2], (K[1] << 16) | (K[0] >>> 16),\n\t                K[3], (K[2] << 16) | (K[1] >>> 16)\n\t            ];\n\n\t            // Generate initial counter values\n\t            var C = this._C = [\n\t                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n\t                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n\t                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n\t                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\n\t            ];\n\n\t            // Carry bit\n\t            this._b = 0;\n\n\t            // Iterate the system four times\n\t            for (var i = 0; i < 4; i++) {\n\t                nextState.call(this);\n\t            }\n\n\t            // Modify the counters\n\t            for (var i = 0; i < 8; i++) {\n\t                C[i] ^= X[(i + 4) & 7];\n\t            }\n\n\t            // IV setup\n\t            if (iv) {\n\t                // Shortcuts\n\t                var IV = iv.words;\n\t                var IV_0 = IV[0];\n\t                var IV_1 = IV[1];\n\n\t                // Generate four subvectors\n\t                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n\t                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n\t                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n\t                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);\n\n\t                // Modify counter values\n\t                C[0] ^= i0;\n\t                C[1] ^= i1;\n\t                C[2] ^= i2;\n\t                C[3] ^= i3;\n\t                C[4] ^= i0;\n\t                C[5] ^= i1;\n\t                C[6] ^= i2;\n\t                C[7] ^= i3;\n\n\t                // Iterate the system four times\n\t                for (var i = 0; i < 4; i++) {\n\t                    nextState.call(this);\n\t                }\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var X = this._X;\n\n\t            // Iterate the system\n\t            nextState.call(this);\n\n\t            // Generate four keystream words\n\t            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n\t            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n\t            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n\t            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n\t            for (var i = 0; i < 4; i++) {\n\t                // Swap endian\n\t                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);\n\n\t                // Encrypt\n\t                M[offset + i] ^= S[i];\n\t            }\n\t        },\n\n\t        blockSize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    function nextState() {\n\t        // Shortcuts\n\t        var X = this._X;\n\t        var C = this._C;\n\n\t        // Save old counter values\n\t        for (var i = 0; i < 8; i++) {\n\t            C_[i] = C[i];\n\t        }\n\n\t        // Calculate new counter values\n\t        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n\t        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n\t        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n\t        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n\t        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n\t        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n\t        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n\t        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n\t        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n\t        // Calculate the g-values\n\t        for (var i = 0; i < 8; i++) {\n\t            var gx = X[i] + C[i];\n\n\t            // Construct high and low argument for squaring\n\t            var ga = gx & 0xffff;\n\t            var gb = gx >>> 16;\n\n\t            // Calculate high and low result of squaring\n\t            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n\t            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n\t            // High XOR low\n\t            G[i] = gh ^ gl;\n\t        }\n\n\t        // Calculate new state values\n\t        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n\t        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;\n\t        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n\t        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;\n\t        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n\t        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;\n\t        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n\t        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.Rabbit = StreamCipher._createHelper(Rabbit);\n\t}());\n\n\n\treturn CryptoJS.Rabbit;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/rabbit.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/rc4.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/rc4.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * RC4 stream cipher algorithm.\n\t     */\n\t    var RC4 = C_algo.RC4 = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\t            var keySigBytes = key.sigBytes;\n\n\t            // Init sbox\n\t            var S = this._S = [];\n\t            for (var i = 0; i < 256; i++) {\n\t                S[i] = i;\n\t            }\n\n\t            // Key setup\n\t            for (var i = 0, j = 0; i < 256; i++) {\n\t                var keyByteIndex = i % keySigBytes;\n\t                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;\n\n\t                j = (j + S[i] + keyByte) % 256;\n\n\t                // Swap\n\t                var t = S[i];\n\t                S[i] = S[j];\n\t                S[j] = t;\n\t            }\n\n\t            // Counters\n\t            this._i = this._j = 0;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            M[offset] ^= generateKeystreamWord.call(this);\n\t        },\n\n\t        keySize: 256/32,\n\n\t        ivSize: 0\n\t    });\n\n\t    function generateKeystreamWord() {\n\t        // Shortcuts\n\t        var S = this._S;\n\t        var i = this._i;\n\t        var j = this._j;\n\n\t        // Generate keystream word\n\t        var keystreamWord = 0;\n\t        for (var n = 0; n < 4; n++) {\n\t            i = (i + 1) % 256;\n\t            j = (j + S[i]) % 256;\n\n\t            // Swap\n\t            var t = S[i];\n\t            S[i] = S[j];\n\t            S[j] = t;\n\n\t            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);\n\t        }\n\n\t        // Update counters\n\t        this._i = i;\n\t        this._j = j;\n\n\t        return keystreamWord;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RC4 = StreamCipher._createHelper(RC4);\n\n\t    /**\n\t     * Modified RC4 stream cipher algorithm.\n\t     */\n\t    var RC4Drop = C_algo.RC4Drop = RC4.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} drop The number of keystream words to drop. Default 192\n\t         */\n\t        cfg: RC4.cfg.extend({\n\t            drop: 192\n\t        }),\n\n\t        _doReset: function () {\n\t            RC4._doReset.call(this);\n\n\t            // Drop\n\t            for (var i = this.cfg.drop; i > 0; i--) {\n\t                generateKeystreamWord.call(this);\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RC4Drop = StreamCipher._createHelper(RC4Drop);\n\t}());\n\n\n\treturn CryptoJS.RC4;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/rc4.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/ripemd160.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/ripemd160.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t/** @preserve\n\t(c) 2012 by Cdric Mesnil. All rights reserved.\n\n\tRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\t    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\t    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t*/\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var _zl = WordArray.create([\n\t        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,\n\t        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,\n\t        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,\n\t        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);\n\t    var _zr = WordArray.create([\n\t        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,\n\t        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,\n\t        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,\n\t        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,\n\t        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);\n\t    var _sl = WordArray.create([\n\t         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,\n\t        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,\n\t        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,\n\t          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,\n\t        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);\n\t    var _sr = WordArray.create([\n\t        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,\n\t        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,\n\t        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,\n\t        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,\n\t        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);\n\n\t    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\n\t    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\n\n\t    /**\n\t     * RIPEMD160 hash algorithm.\n\t     */\n\t    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                // Swap\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\t            // Shortcut\n\t            var H  = this._hash.words;\n\t            var hl = _hl.words;\n\t            var hr = _hr.words;\n\t            var zl = _zl.words;\n\t            var zr = _zr.words;\n\t            var sl = _sl.words;\n\t            var sr = _sr.words;\n\n\t            // Working variables\n\t            var al, bl, cl, dl, el;\n\t            var ar, br, cr, dr, er;\n\n\t            ar = al = H[0];\n\t            br = bl = H[1];\n\t            cr = cl = H[2];\n\t            dr = dl = H[3];\n\t            er = el = H[4];\n\t            // Computation\n\t            var t;\n\t            for (var i = 0; i < 80; i += 1) {\n\t                t = (al +  M[offset+zl[i]])|0;\n\t                if (i<16){\n\t\t            t +=  f1(bl,cl,dl) + hl[0];\n\t                } else if (i<32) {\n\t\t            t +=  f2(bl,cl,dl) + hl[1];\n\t                } else if (i<48) {\n\t\t            t +=  f3(bl,cl,dl) + hl[2];\n\t                } else if (i<64) {\n\t\t            t +=  f4(bl,cl,dl) + hl[3];\n\t                } else {// if (i<80) {\n\t\t            t +=  f5(bl,cl,dl) + hl[4];\n\t                }\n\t                t = t|0;\n\t                t =  rotl(t,sl[i]);\n\t                t = (t+el)|0;\n\t                al = el;\n\t                el = dl;\n\t                dl = rotl(cl, 10);\n\t                cl = bl;\n\t                bl = t;\n\n\t                t = (ar + M[offset+zr[i]])|0;\n\t                if (i<16){\n\t\t            t +=  f5(br,cr,dr) + hr[0];\n\t                } else if (i<32) {\n\t\t            t +=  f4(br,cr,dr) + hr[1];\n\t                } else if (i<48) {\n\t\t            t +=  f3(br,cr,dr) + hr[2];\n\t                } else if (i<64) {\n\t\t            t +=  f2(br,cr,dr) + hr[3];\n\t                } else {// if (i<80) {\n\t\t            t +=  f1(br,cr,dr) + hr[4];\n\t                }\n\t                t = t|0;\n\t                t =  rotl(t,sr[i]) ;\n\t                t = (t+er)|0;\n\t                ar = er;\n\t                er = dr;\n\t                dr = rotl(cr, 10);\n\t                cr = br;\n\t                br = t;\n\t            }\n\t            // Intermediate hash value\n\t            t    = (H[1] + cl + dr)|0;\n\t            H[1] = (H[2] + dl + er)|0;\n\t            H[2] = (H[3] + el + ar)|0;\n\t            H[3] = (H[4] + al + br)|0;\n\t            H[4] = (H[0] + bl + cr)|0;\n\t            H[0] =  t;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)\n\t            );\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 5; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                // Swap\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\n\t    function f1(x, y, z) {\n\t        return ((x) ^ (y) ^ (z));\n\n\t    }\n\n\t    function f2(x, y, z) {\n\t        return (((x)&(y)) | ((~x)&(z)));\n\t    }\n\n\t    function f3(x, y, z) {\n\t        return (((x) | (~(y))) ^ (z));\n\t    }\n\n\t    function f4(x, y, z) {\n\t        return (((x) & (z)) | ((y)&(~(z))));\n\t    }\n\n\t    function f5(x, y, z) {\n\t        return ((x) ^ ((y) |(~(z))));\n\n\t    }\n\n\t    function rotl(x,n) {\n\t        return (x<<n) | (x>>>(32-n));\n\t    }\n\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.RIPEMD160('message');\n\t     *     var hash = CryptoJS.RIPEMD160(wordArray);\n\t     */\n\t    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);\n\t     */\n\t    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);\n\t}(Math));\n\n\n\treturn CryptoJS.RIPEMD160;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/ripemd160.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/sha1.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha1.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-1 hash algorithm.\n\t     */\n\t    var SHA1 = C_algo.SHA1 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476,\n\t                0xc3d2e1f0\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\n\t            // Computation\n\t            for (var i = 0; i < 80; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n\t                    W[i] = (n << 1) | (n >>> 31);\n\t                }\n\n\t                var t = ((a << 5) | (a >>> 27)) + e + W[i];\n\t                if (i < 20) {\n\t                    t += ((b & c) | (~b & d)) + 0x5a827999;\n\t                } else if (i < 40) {\n\t                    t += (b ^ c ^ d) + 0x6ed9eba1;\n\t                } else if (i < 60) {\n\t                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\n\t                } else /* if (i < 80) */ {\n\t                    t += (b ^ c ^ d) - 0x359d3e2a;\n\t                }\n\n\t                e = d;\n\t                d = c;\n\t                c = (b << 30) | (b >>> 2);\n\t                b = a;\n\t                a = t;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA1('message');\n\t     *     var hash = CryptoJS.SHA1(wordArray);\n\t     */\n\t    C.SHA1 = Hasher._createHelper(SHA1);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA1(message, key);\n\t     */\n\t    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);\n\t}());\n\n\n\treturn CryptoJS.SHA1;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/sha1.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/sha224.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha224.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./sha256 */ \"./node_modules/crypto-js/sha256.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA256 = C_algo.SHA256;\n\n\t    /**\n\t     * SHA-224 hash algorithm.\n\t     */\n\t    var SHA224 = C_algo.SHA224 = SHA256.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n\t                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA256._doFinalize.call(this);\n\n\t            hash.sigBytes -= 4;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA224('message');\n\t     *     var hash = CryptoJS.SHA224(wordArray);\n\t     */\n\t    C.SHA224 = SHA256._createHelper(SHA224);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA224(message, key);\n\t     */\n\t    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);\n\t}());\n\n\n\treturn CryptoJS.SHA224;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/sha224.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/sha256.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha256.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/sha256.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/sha3.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha3.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var C_algo = C.algo;\n\n\t    // Constants tables\n\t    var RHO_OFFSETS = [];\n\t    var PI_INDEXES  = [];\n\t    var ROUND_CONSTANTS = [];\n\n\t    // Compute Constants\n\t    (function () {\n\t        // Compute rho offset constants\n\t        var x = 1, y = 0;\n\t        for (var t = 0; t < 24; t++) {\n\t            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\n\n\t            var newX = y % 5;\n\t            var newY = (2 * x + 3 * y) % 5;\n\t            x = newX;\n\t            y = newY;\n\t        }\n\n\t        // Compute pi index constants\n\t        for (var x = 0; x < 5; x++) {\n\t            for (var y = 0; y < 5; y++) {\n\t                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n\t            }\n\t        }\n\n\t        // Compute round constants\n\t        var LFSR = 0x01;\n\t        for (var i = 0; i < 24; i++) {\n\t            var roundConstantMsw = 0;\n\t            var roundConstantLsw = 0;\n\n\t            for (var j = 0; j < 7; j++) {\n\t                if (LFSR & 0x01) {\n\t                    var bitPosition = (1 << j) - 1;\n\t                    if (bitPosition < 32) {\n\t                        roundConstantLsw ^= 1 << bitPosition;\n\t                    } else /* if (bitPosition >= 32) */ {\n\t                        roundConstantMsw ^= 1 << (bitPosition - 32);\n\t                    }\n\t                }\n\n\t                // Compute next LFSR\n\t                if (LFSR & 0x80) {\n\t                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n\t                    LFSR = (LFSR << 1) ^ 0x71;\n\t                } else {\n\t                    LFSR <<= 1;\n\t                }\n\t            }\n\n\t            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n\t        }\n\t    }());\n\n\t    // Reusable objects for temporary values\n\t    var T = [];\n\t    (function () {\n\t        for (var i = 0; i < 25; i++) {\n\t            T[i] = X64Word.create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-3 hash algorithm.\n\t     */\n\t    var SHA3 = C_algo.SHA3 = Hasher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} outputLength\n\t         *   The desired number of bits in the output hash.\n\t         *   Only values permitted are: 224, 256, 384, 512.\n\t         *   Default: 512\n\t         */\n\t        cfg: Hasher.cfg.extend({\n\t            outputLength: 512\n\t        }),\n\n\t        _doReset: function () {\n\t            var state = this._state = []\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = new X64Word.init();\n\t            }\n\n\t            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var nBlockSizeLanes = this.blockSize / 2;\n\n\t            // Absorb\n\t            for (var i = 0; i < nBlockSizeLanes; i++) {\n\t                // Shortcuts\n\t                var M2i  = M[offset + 2 * i];\n\t                var M2i1 = M[offset + 2 * i + 1];\n\n\t                // Swap endian\n\t                M2i = (\n\t                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)\n\t                );\n\t                M2i1 = (\n\t                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Absorb message into state\n\t                var lane = state[i];\n\t                lane.high ^= M2i1;\n\t                lane.low  ^= M2i;\n\t            }\n\n\t            // Rounds\n\t            for (var round = 0; round < 24; round++) {\n\t                // Theta\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Mix column lanes\n\t                    var tMsw = 0, tLsw = 0;\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        tMsw ^= lane.high;\n\t                        tLsw ^= lane.low;\n\t                    }\n\n\t                    // Temporary values\n\t                    var Tx = T[x];\n\t                    Tx.high = tMsw;\n\t                    Tx.low  = tLsw;\n\t                }\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Shortcuts\n\t                    var Tx4 = T[(x + 4) % 5];\n\t                    var Tx1 = T[(x + 1) % 5];\n\t                    var Tx1Msw = Tx1.high;\n\t                    var Tx1Lsw = Tx1.low;\n\n\t                    // Mix surrounding columns\n\t                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n\t                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        lane.high ^= tMsw;\n\t                        lane.low  ^= tLsw;\n\t                    }\n\t                }\n\n\t                // Rho Pi\n\t                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {\n\t                    var tMsw;\n\t                    var tLsw;\n\n\t                    // Shortcuts\n\t                    var lane = state[laneIndex];\n\t                    var laneMsw = lane.high;\n\t                    var laneLsw = lane.low;\n\t                    var rhoOffset = RHO_OFFSETS[laneIndex];\n\n\t                    // Rotate lanes\n\t                    if (rhoOffset < 32) {\n\t                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n\t                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n\t                    } else /* if (rhoOffset >= 32) */ {\n\t                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n\t                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n\t                    }\n\n\t                    // Transpose lanes\n\t                    var TPiLane = T[PI_INDEXES[laneIndex]];\n\t                    TPiLane.high = tMsw;\n\t                    TPiLane.low  = tLsw;\n\t                }\n\n\t                // Rho pi at x = y = 0\n\t                var T0 = T[0];\n\t                var state0 = state[0];\n\t                T0.high = state0.high;\n\t                T0.low  = state0.low;\n\n\t                // Chi\n\t                for (var x = 0; x < 5; x++) {\n\t                    for (var y = 0; y < 5; y++) {\n\t                        // Shortcuts\n\t                        var laneIndex = x + 5 * y;\n\t                        var lane = state[laneIndex];\n\t                        var TLane = T[laneIndex];\n\t                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];\n\t                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n\t                        // Mix rows\n\t                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n\t                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);\n\t                    }\n\t                }\n\n\t                // Iota\n\t                var lane = state[0];\n\t                var roundConstant = ROUND_CONSTANTS[round];\n\t                lane.high ^= roundConstant.high;\n\t                lane.low  ^= roundConstant.low;\n\t            }\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\t            var blockSizeBits = this.blockSize * 32;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\n\t            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var outputLengthBytes = this.cfg.outputLength / 8;\n\t            var outputLengthLanes = outputLengthBytes / 8;\n\n\t            // Squeeze\n\t            var hashWords = [];\n\t            for (var i = 0; i < outputLengthLanes; i++) {\n\t                // Shortcuts\n\t                var lane = state[i];\n\t                var laneMsw = lane.high;\n\t                var laneLsw = lane.low;\n\n\t                // Swap endian\n\t                laneMsw = (\n\t                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)\n\t                );\n\t                laneLsw = (\n\t                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Squeeze state to retrieve hash\n\t                hashWords.push(laneLsw);\n\t                hashWords.push(laneMsw);\n\t            }\n\n\t            // Return final computed hash\n\t            return new WordArray.init(hashWords, outputLengthBytes);\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\n\t            var state = clone._state = this._state.slice(0);\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = state[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA3('message');\n\t     *     var hash = CryptoJS.SHA3(wordArray);\n\t     */\n\t    C.SHA3 = Hasher._createHelper(SHA3);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA3(message, key);\n\t     */\n\t    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA3;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/sha3.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/sha384.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha384.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"), __webpack_require__(/*! ./sha512 */ \"./node_modules/crypto-js/sha512.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var X64WordArray = C_x64.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA512 = C_algo.SHA512;\n\n\t    /**\n\t     * SHA-384 hash algorithm.\n\t     */\n\t    var SHA384 = C_algo.SHA384 = SHA512.extend({\n\t        _doReset: function () {\n\t            this._hash = new X64WordArray.init([\n\t                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),\n\t                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),\n\t                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),\n\t                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA512._doFinalize.call(this);\n\n\t            hash.sigBytes -= 16;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA384('message');\n\t     *     var hash = CryptoJS.SHA384(wordArray);\n\t     */\n\t    C.SHA384 = SHA512._createHelper(SHA384);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA384(message, key);\n\t     */\n\t    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);\n\t}());\n\n\n\treturn CryptoJS.SHA384;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/sha384.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/sha512.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha512.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var X64WordArray = C_x64.WordArray;\n\t    var C_algo = C.algo;\n\n\t    function X64Word_create() {\n\t        return X64Word.create.apply(X64Word, arguments);\n\t    }\n\n\t    // Constants\n\t    var K = [\n\t        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),\n\t        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),\n\t        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),\n\t        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),\n\t        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),\n\t        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),\n\t        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),\n\t        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),\n\t        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),\n\t        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),\n\t        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),\n\t        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),\n\t        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),\n\t        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),\n\t        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),\n\t        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),\n\t        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),\n\t        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),\n\t        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),\n\t        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),\n\t        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),\n\t        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),\n\t        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),\n\t        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),\n\t        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),\n\t        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),\n\t        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),\n\t        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),\n\t        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),\n\t        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),\n\t        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),\n\t        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),\n\t        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),\n\t        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),\n\t        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),\n\t        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),\n\t        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),\n\t        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),\n\t        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),\n\t        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)\n\t    ];\n\n\t    // Reusable objects\n\t    var W = [];\n\t    (function () {\n\t        for (var i = 0; i < 80; i++) {\n\t            W[i] = X64Word_create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-512 hash algorithm.\n\t     */\n\t    var SHA512 = C_algo.SHA512 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new X64WordArray.init([\n\t                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),\n\t                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),\n\t                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),\n\t                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var H0 = H[0];\n\t            var H1 = H[1];\n\t            var H2 = H[2];\n\t            var H3 = H[3];\n\t            var H4 = H[4];\n\t            var H5 = H[5];\n\t            var H6 = H[6];\n\t            var H7 = H[7];\n\n\t            var H0h = H0.high;\n\t            var H0l = H0.low;\n\t            var H1h = H1.high;\n\t            var H1l = H1.low;\n\t            var H2h = H2.high;\n\t            var H2l = H2.low;\n\t            var H3h = H3.high;\n\t            var H3l = H3.low;\n\t            var H4h = H4.high;\n\t            var H4l = H4.low;\n\t            var H5h = H5.high;\n\t            var H5l = H5.low;\n\t            var H6h = H6.high;\n\t            var H6l = H6.low;\n\t            var H7h = H7.high;\n\t            var H7l = H7.low;\n\n\t            // Working variables\n\t            var ah = H0h;\n\t            var al = H0l;\n\t            var bh = H1h;\n\t            var bl = H1l;\n\t            var ch = H2h;\n\t            var cl = H2l;\n\t            var dh = H3h;\n\t            var dl = H3l;\n\t            var eh = H4h;\n\t            var el = H4l;\n\t            var fh = H5h;\n\t            var fl = H5l;\n\t            var gh = H6h;\n\t            var gl = H6l;\n\t            var hh = H7h;\n\t            var hl = H7l;\n\n\t            // Rounds\n\t            for (var i = 0; i < 80; i++) {\n\t                var Wil;\n\t                var Wih;\n\n\t                // Shortcut\n\t                var Wi = W[i];\n\n\t                // Extend message\n\t                if (i < 16) {\n\t                    Wih = Wi.high = M[offset + i * 2]     | 0;\n\t                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;\n\t                } else {\n\t                    // Gamma0\n\t                    var gamma0x  = W[i - 15];\n\t                    var gamma0xh = gamma0x.high;\n\t                    var gamma0xl = gamma0x.low;\n\t                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);\n\t                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));\n\n\t                    // Gamma1\n\t                    var gamma1x  = W[i - 2];\n\t                    var gamma1xh = gamma1x.high;\n\t                    var gamma1xl = gamma1x.low;\n\t                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);\n\t                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));\n\n\t                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n\t                    var Wi7  = W[i - 7];\n\t                    var Wi7h = Wi7.high;\n\t                    var Wi7l = Wi7.low;\n\n\t                    var Wi16  = W[i - 16];\n\t                    var Wi16h = Wi16.high;\n\t                    var Wi16l = Wi16.low;\n\n\t                    Wil = gamma0l + Wi7l;\n\t                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n\t                    Wil = Wil + gamma1l;\n\t                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n\t                    Wil = Wil + Wi16l;\n\t                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);\n\n\t                    Wi.high = Wih;\n\t                    Wi.low  = Wil;\n\t                }\n\n\t                var chh  = (eh & fh) ^ (~eh & gh);\n\t                var chl  = (el & fl) ^ (~el & gl);\n\t                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n\t                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n\t                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n\t                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\t                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));\n\t                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));\n\n\t                // t1 = h + sigma1 + ch + K[i] + W[i]\n\t                var Ki  = K[i];\n\t                var Kih = Ki.high;\n\t                var Kil = Ki.low;\n\n\t                var t1l = hl + sigma1l;\n\t                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n\t                var t1l = t1l + chl;\n\t                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n\t                var t1l = t1l + Kil;\n\t                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);\n\t                var t1l = t1l + Wil;\n\t                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);\n\n\t                // t2 = sigma0 + maj\n\t                var t2l = sigma0l + majl;\n\t                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n\t                // Update working variables\n\t                hh = gh;\n\t                hl = gl;\n\t                gh = fh;\n\t                gl = fl;\n\t                fh = eh;\n\t                fl = el;\n\t                el = (dl + t1l) | 0;\n\t                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n\t                dh = ch;\n\t                dl = cl;\n\t                ch = bh;\n\t                cl = bl;\n\t                bh = ah;\n\t                bl = al;\n\t                al = (t1l + t2l) | 0;\n\t                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H0l = H0.low  = (H0l + al);\n\t            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));\n\t            H1l = H1.low  = (H1l + bl);\n\t            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));\n\t            H2l = H2.low  = (H2l + cl);\n\t            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));\n\t            H3l = H3.low  = (H3l + dl);\n\t            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));\n\t            H4l = H4.low  = (H4l + el);\n\t            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));\n\t            H5l = H5.low  = (H5l + fl);\n\t            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));\n\t            H6l = H6.low  = (H6l + gl);\n\t            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));\n\t            H7l = H7.low  = (H7l + hl);\n\t            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Convert hash to 32-bit word array before returning\n\t            var hash = this._hash.toX32();\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        },\n\n\t        blockSize: 1024/32\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA512('message');\n\t     *     var hash = CryptoJS.SHA512(wordArray);\n\t     */\n\t    C.SHA512 = Hasher._createHelper(SHA512);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA512(message, key);\n\t     */\n\t    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);\n\t}());\n\n\n\treturn CryptoJS.SHA512;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/sha512.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/tripledes.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/tripledes.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Permuted Choice 1 constants\n\t    var PC1 = [\n\t        57, 49, 41, 33, 25, 17, 9,  1,\n\t        58, 50, 42, 34, 26, 18, 10, 2,\n\t        59, 51, 43, 35, 27, 19, 11, 3,\n\t        60, 52, 44, 36, 63, 55, 47, 39,\n\t        31, 23, 15, 7,  62, 54, 46, 38,\n\t        30, 22, 14, 6,  61, 53, 45, 37,\n\t        29, 21, 13, 5,  28, 20, 12, 4\n\t    ];\n\n\t    // Permuted Choice 2 constants\n\t    var PC2 = [\n\t        14, 17, 11, 24, 1,  5,\n\t        3,  28, 15, 6,  21, 10,\n\t        23, 19, 12, 4,  26, 8,\n\t        16, 7,  27, 20, 13, 2,\n\t        41, 52, 31, 37, 47, 55,\n\t        30, 40, 51, 45, 33, 48,\n\t        44, 49, 39, 56, 34, 53,\n\t        46, 42, 50, 36, 29, 32\n\t    ];\n\n\t    // Cumulative bit shift constants\n\t    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];\n\n\t    // SBOXes and round permutation constants\n\t    var SBOX_P = [\n\t        {\n\t            0x0: 0x808200,\n\t            0x10000000: 0x8000,\n\t            0x20000000: 0x808002,\n\t            0x30000000: 0x2,\n\t            0x40000000: 0x200,\n\t            0x50000000: 0x808202,\n\t            0x60000000: 0x800202,\n\t            0x70000000: 0x800000,\n\t            0x80000000: 0x202,\n\t            0x90000000: 0x800200,\n\t            0xa0000000: 0x8200,\n\t            0xb0000000: 0x808000,\n\t            0xc0000000: 0x8002,\n\t            0xd0000000: 0x800002,\n\t            0xe0000000: 0x0,\n\t            0xf0000000: 0x8202,\n\t            0x8000000: 0x0,\n\t            0x18000000: 0x808202,\n\t            0x28000000: 0x8202,\n\t            0x38000000: 0x8000,\n\t            0x48000000: 0x808200,\n\t            0x58000000: 0x200,\n\t            0x68000000: 0x808002,\n\t            0x78000000: 0x2,\n\t            0x88000000: 0x800200,\n\t            0x98000000: 0x8200,\n\t            0xa8000000: 0x808000,\n\t            0xb8000000: 0x800202,\n\t            0xc8000000: 0x800002,\n\t            0xd8000000: 0x8002,\n\t            0xe8000000: 0x202,\n\t            0xf8000000: 0x800000,\n\t            0x1: 0x8000,\n\t            0x10000001: 0x2,\n\t            0x20000001: 0x808200,\n\t            0x30000001: 0x800000,\n\t            0x40000001: 0x808002,\n\t            0x50000001: 0x8200,\n\t            0x60000001: 0x200,\n\t            0x70000001: 0x800202,\n\t            0x80000001: 0x808202,\n\t            0x90000001: 0x808000,\n\t            0xa0000001: 0x800002,\n\t            0xb0000001: 0x8202,\n\t            0xc0000001: 0x202,\n\t            0xd0000001: 0x800200,\n\t            0xe0000001: 0x8002,\n\t            0xf0000001: 0x0,\n\t            0x8000001: 0x808202,\n\t            0x18000001: 0x808000,\n\t            0x28000001: 0x800000,\n\t            0x38000001: 0x200,\n\t            0x48000001: 0x8000,\n\t            0x58000001: 0x800002,\n\t            0x68000001: 0x2,\n\t            0x78000001: 0x8202,\n\t            0x88000001: 0x8002,\n\t            0x98000001: 0x800202,\n\t            0xa8000001: 0x202,\n\t            0xb8000001: 0x808200,\n\t            0xc8000001: 0x800200,\n\t            0xd8000001: 0x0,\n\t            0xe8000001: 0x8200,\n\t            0xf8000001: 0x808002\n\t        },\n\t        {\n\t            0x0: 0x40084010,\n\t            0x1000000: 0x4000,\n\t            0x2000000: 0x80000,\n\t            0x3000000: 0x40080010,\n\t            0x4000000: 0x40000010,\n\t            0x5000000: 0x40084000,\n\t            0x6000000: 0x40004000,\n\t            0x7000000: 0x10,\n\t            0x8000000: 0x84000,\n\t            0x9000000: 0x40004010,\n\t            0xa000000: 0x40000000,\n\t            0xb000000: 0x84010,\n\t            0xc000000: 0x80010,\n\t            0xd000000: 0x0,\n\t            0xe000000: 0x4010,\n\t            0xf000000: 0x40080000,\n\t            0x800000: 0x40004000,\n\t            0x1800000: 0x84010,\n\t            0x2800000: 0x10,\n\t            0x3800000: 0x40004010,\n\t            0x4800000: 0x40084010,\n\t            0x5800000: 0x40000000,\n\t            0x6800000: 0x80000,\n\t            0x7800000: 0x40080010,\n\t            0x8800000: 0x80010,\n\t            0x9800000: 0x0,\n\t            0xa800000: 0x4000,\n\t            0xb800000: 0x40080000,\n\t            0xc800000: 0x40000010,\n\t            0xd800000: 0x84000,\n\t            0xe800000: 0x40084000,\n\t            0xf800000: 0x4010,\n\t            0x10000000: 0x0,\n\t            0x11000000: 0x40080010,\n\t            0x12000000: 0x40004010,\n\t            0x13000000: 0x40084000,\n\t            0x14000000: 0x40080000,\n\t            0x15000000: 0x10,\n\t            0x16000000: 0x84010,\n\t            0x17000000: 0x4000,\n\t            0x18000000: 0x4010,\n\t            0x19000000: 0x80000,\n\t            0x1a000000: 0x80010,\n\t            0x1b000000: 0x40000010,\n\t            0x1c000000: 0x84000,\n\t            0x1d000000: 0x40004000,\n\t            0x1e000000: 0x40000000,\n\t            0x1f000000: 0x40084010,\n\t            0x10800000: 0x84010,\n\t            0x11800000: 0x80000,\n\t            0x12800000: 0x40080000,\n\t            0x13800000: 0x4000,\n\t            0x14800000: 0x40004000,\n\t            0x15800000: 0x40084010,\n\t            0x16800000: 0x10,\n\t            0x17800000: 0x40000000,\n\t            0x18800000: 0x40084000,\n\t            0x19800000: 0x40000010,\n\t            0x1a800000: 0x40004010,\n\t            0x1b800000: 0x80010,\n\t            0x1c800000: 0x0,\n\t            0x1d800000: 0x4010,\n\t            0x1e800000: 0x40080010,\n\t            0x1f800000: 0x84000\n\t        },\n\t        {\n\t            0x0: 0x104,\n\t            0x100000: 0x0,\n\t            0x200000: 0x4000100,\n\t            0x300000: 0x10104,\n\t            0x400000: 0x10004,\n\t            0x500000: 0x4000004,\n\t            0x600000: 0x4010104,\n\t            0x700000: 0x4010000,\n\t            0x800000: 0x4000000,\n\t            0x900000: 0x4010100,\n\t            0xa00000: 0x10100,\n\t            0xb00000: 0x4010004,\n\t            0xc00000: 0x4000104,\n\t            0xd00000: 0x10000,\n\t            0xe00000: 0x4,\n\t            0xf00000: 0x100,\n\t            0x80000: 0x4010100,\n\t            0x180000: 0x4010004,\n\t            0x280000: 0x0,\n\t            0x380000: 0x4000100,\n\t            0x480000: 0x4000004,\n\t            0x580000: 0x10000,\n\t            0x680000: 0x10004,\n\t            0x780000: 0x104,\n\t            0x880000: 0x4,\n\t            0x980000: 0x100,\n\t            0xa80000: 0x4010000,\n\t            0xb80000: 0x10104,\n\t            0xc80000: 0x10100,\n\t            0xd80000: 0x4000104,\n\t            0xe80000: 0x4010104,\n\t            0xf80000: 0x4000000,\n\t            0x1000000: 0x4010100,\n\t            0x1100000: 0x10004,\n\t            0x1200000: 0x10000,\n\t            0x1300000: 0x4000100,\n\t            0x1400000: 0x100,\n\t            0x1500000: 0x4010104,\n\t            0x1600000: 0x4000004,\n\t            0x1700000: 0x0,\n\t            0x1800000: 0x4000104,\n\t            0x1900000: 0x4000000,\n\t            0x1a00000: 0x4,\n\t            0x1b00000: 0x10100,\n\t            0x1c00000: 0x4010000,\n\t            0x1d00000: 0x104,\n\t            0x1e00000: 0x10104,\n\t            0x1f00000: 0x4010004,\n\t            0x1080000: 0x4000000,\n\t            0x1180000: 0x104,\n\t            0x1280000: 0x4010100,\n\t            0x1380000: 0x0,\n\t            0x1480000: 0x10004,\n\t            0x1580000: 0x4000100,\n\t            0x1680000: 0x100,\n\t            0x1780000: 0x4010004,\n\t            0x1880000: 0x10000,\n\t            0x1980000: 0x4010104,\n\t            0x1a80000: 0x10104,\n\t            0x1b80000: 0x4000004,\n\t            0x1c80000: 0x4000104,\n\t            0x1d80000: 0x4010000,\n\t            0x1e80000: 0x4,\n\t            0x1f80000: 0x10100\n\t        },\n\t        {\n\t            0x0: 0x80401000,\n\t            0x10000: 0x80001040,\n\t            0x20000: 0x401040,\n\t            0x30000: 0x80400000,\n\t            0x40000: 0x0,\n\t            0x50000: 0x401000,\n\t            0x60000: 0x80000040,\n\t            0x70000: 0x400040,\n\t            0x80000: 0x80000000,\n\t            0x90000: 0x400000,\n\t            0xa0000: 0x40,\n\t            0xb0000: 0x80001000,\n\t            0xc0000: 0x80400040,\n\t            0xd0000: 0x1040,\n\t            0xe0000: 0x1000,\n\t            0xf0000: 0x80401040,\n\t            0x8000: 0x80001040,\n\t            0x18000: 0x40,\n\t            0x28000: 0x80400040,\n\t            0x38000: 0x80001000,\n\t            0x48000: 0x401000,\n\t            0x58000: 0x80401040,\n\t            0x68000: 0x0,\n\t            0x78000: 0x80400000,\n\t            0x88000: 0x1000,\n\t            0x98000: 0x80401000,\n\t            0xa8000: 0x400000,\n\t            0xb8000: 0x1040,\n\t            0xc8000: 0x80000000,\n\t            0xd8000: 0x400040,\n\t            0xe8000: 0x401040,\n\t            0xf8000: 0x80000040,\n\t            0x100000: 0x400040,\n\t            0x110000: 0x401000,\n\t            0x120000: 0x80000040,\n\t            0x130000: 0x0,\n\t            0x140000: 0x1040,\n\t            0x150000: 0x80400040,\n\t            0x160000: 0x80401000,\n\t            0x170000: 0x80001040,\n\t            0x180000: 0x80401040,\n\t            0x190000: 0x80000000,\n\t            0x1a0000: 0x80400000,\n\t            0x1b0000: 0x401040,\n\t            0x1c0000: 0x80001000,\n\t            0x1d0000: 0x400000,\n\t            0x1e0000: 0x40,\n\t            0x1f0000: 0x1000,\n\t            0x108000: 0x80400000,\n\t            0x118000: 0x80401040,\n\t            0x128000: 0x0,\n\t            0x138000: 0x401000,\n\t            0x148000: 0x400040,\n\t            0x158000: 0x80000000,\n\t            0x168000: 0x80001040,\n\t            0x178000: 0x40,\n\t            0x188000: 0x80000040,\n\t            0x198000: 0x1000,\n\t            0x1a8000: 0x80001000,\n\t            0x1b8000: 0x80400040,\n\t            0x1c8000: 0x1040,\n\t            0x1d8000: 0x80401000,\n\t            0x1e8000: 0x400000,\n\t            0x1f8000: 0x401040\n\t        },\n\t        {\n\t            0x0: 0x80,\n\t            0x1000: 0x1040000,\n\t            0x2000: 0x40000,\n\t            0x3000: 0x20000000,\n\t            0x4000: 0x20040080,\n\t            0x5000: 0x1000080,\n\t            0x6000: 0x21000080,\n\t            0x7000: 0x40080,\n\t            0x8000: 0x1000000,\n\t            0x9000: 0x20040000,\n\t            0xa000: 0x20000080,\n\t            0xb000: 0x21040080,\n\t            0xc000: 0x21040000,\n\t            0xd000: 0x0,\n\t            0xe000: 0x1040080,\n\t            0xf000: 0x21000000,\n\t            0x800: 0x1040080,\n\t            0x1800: 0x21000080,\n\t            0x2800: 0x80,\n\t            0x3800: 0x1040000,\n\t            0x4800: 0x40000,\n\t            0x5800: 0x20040080,\n\t            0x6800: 0x21040000,\n\t            0x7800: 0x20000000,\n\t            0x8800: 0x20040000,\n\t            0x9800: 0x0,\n\t            0xa800: 0x21040080,\n\t            0xb800: 0x1000080,\n\t            0xc800: 0x20000080,\n\t            0xd800: 0x21000000,\n\t            0xe800: 0x1000000,\n\t            0xf800: 0x40080,\n\t            0x10000: 0x40000,\n\t            0x11000: 0x80,\n\t            0x12000: 0x20000000,\n\t            0x13000: 0x21000080,\n\t            0x14000: 0x1000080,\n\t            0x15000: 0x21040000,\n\t            0x16000: 0x20040080,\n\t            0x17000: 0x1000000,\n\t            0x18000: 0x21040080,\n\t            0x19000: 0x21000000,\n\t            0x1a000: 0x1040000,\n\t            0x1b000: 0x20040000,\n\t            0x1c000: 0x40080,\n\t            0x1d000: 0x20000080,\n\t            0x1e000: 0x0,\n\t            0x1f000: 0x1040080,\n\t            0x10800: 0x21000080,\n\t            0x11800: 0x1000000,\n\t            0x12800: 0x1040000,\n\t            0x13800: 0x20040080,\n\t            0x14800: 0x20000000,\n\t            0x15800: 0x1040080,\n\t            0x16800: 0x80,\n\t            0x17800: 0x21040000,\n\t            0x18800: 0x40080,\n\t            0x19800: 0x21040080,\n\t            0x1a800: 0x0,\n\t            0x1b800: 0x21000000,\n\t            0x1c800: 0x1000080,\n\t            0x1d800: 0x40000,\n\t            0x1e800: 0x20040000,\n\t            0x1f800: 0x20000080\n\t        },\n\t        {\n\t            0x0: 0x10000008,\n\t            0x100: 0x2000,\n\t            0x200: 0x10200000,\n\t            0x300: 0x10202008,\n\t            0x400: 0x10002000,\n\t            0x500: 0x200000,\n\t            0x600: 0x200008,\n\t            0x700: 0x10000000,\n\t            0x800: 0x0,\n\t            0x900: 0x10002008,\n\t            0xa00: 0x202000,\n\t            0xb00: 0x8,\n\t            0xc00: 0x10200008,\n\t            0xd00: 0x202008,\n\t            0xe00: 0x2008,\n\t            0xf00: 0x10202000,\n\t            0x80: 0x10200000,\n\t            0x180: 0x10202008,\n\t            0x280: 0x8,\n\t            0x380: 0x200000,\n\t            0x480: 0x202008,\n\t            0x580: 0x10000008,\n\t            0x680: 0x10002000,\n\t            0x780: 0x2008,\n\t            0x880: 0x200008,\n\t            0x980: 0x2000,\n\t            0xa80: 0x10002008,\n\t            0xb80: 0x10200008,\n\t            0xc80: 0x0,\n\t            0xd80: 0x10202000,\n\t            0xe80: 0x202000,\n\t            0xf80: 0x10000000,\n\t            0x1000: 0x10002000,\n\t            0x1100: 0x10200008,\n\t            0x1200: 0x10202008,\n\t            0x1300: 0x2008,\n\t            0x1400: 0x200000,\n\t            0x1500: 0x10000000,\n\t            0x1600: 0x10000008,\n\t            0x1700: 0x202000,\n\t            0x1800: 0x202008,\n\t            0x1900: 0x0,\n\t            0x1a00: 0x8,\n\t            0x1b00: 0x10200000,\n\t            0x1c00: 0x2000,\n\t            0x1d00: 0x10002008,\n\t            0x1e00: 0x10202000,\n\t            0x1f00: 0x200008,\n\t            0x1080: 0x8,\n\t            0x1180: 0x202000,\n\t            0x1280: 0x200000,\n\t            0x1380: 0x10000008,\n\t            0x1480: 0x10002000,\n\t            0x1580: 0x2008,\n\t            0x1680: 0x10202008,\n\t            0x1780: 0x10200000,\n\t            0x1880: 0x10202000,\n\t            0x1980: 0x10200008,\n\t            0x1a80: 0x2000,\n\t            0x1b80: 0x202008,\n\t            0x1c80: 0x200008,\n\t            0x1d80: 0x0,\n\t            0x1e80: 0x10000000,\n\t            0x1f80: 0x10002008\n\t        },\n\t        {\n\t            0x0: 0x100000,\n\t            0x10: 0x2000401,\n\t            0x20: 0x400,\n\t            0x30: 0x100401,\n\t            0x40: 0x2100401,\n\t            0x50: 0x0,\n\t            0x60: 0x1,\n\t            0x70: 0x2100001,\n\t            0x80: 0x2000400,\n\t            0x90: 0x100001,\n\t            0xa0: 0x2000001,\n\t            0xb0: 0x2100400,\n\t            0xc0: 0x2100000,\n\t            0xd0: 0x401,\n\t            0xe0: 0x100400,\n\t            0xf0: 0x2000000,\n\t            0x8: 0x2100001,\n\t            0x18: 0x0,\n\t            0x28: 0x2000401,\n\t            0x38: 0x2100400,\n\t            0x48: 0x100000,\n\t            0x58: 0x2000001,\n\t            0x68: 0x2000000,\n\t            0x78: 0x401,\n\t            0x88: 0x100401,\n\t            0x98: 0x2000400,\n\t            0xa8: 0x2100000,\n\t            0xb8: 0x100001,\n\t            0xc8: 0x400,\n\t            0xd8: 0x2100401,\n\t            0xe8: 0x1,\n\t            0xf8: 0x100400,\n\t            0x100: 0x2000000,\n\t            0x110: 0x100000,\n\t            0x120: 0x2000401,\n\t            0x130: 0x2100001,\n\t            0x140: 0x100001,\n\t            0x150: 0x2000400,\n\t            0x160: 0x2100400,\n\t            0x170: 0x100401,\n\t            0x180: 0x401,\n\t            0x190: 0x2100401,\n\t            0x1a0: 0x100400,\n\t            0x1b0: 0x1,\n\t            0x1c0: 0x0,\n\t            0x1d0: 0x2100000,\n\t            0x1e0: 0x2000001,\n\t            0x1f0: 0x400,\n\t            0x108: 0x100400,\n\t            0x118: 0x2000401,\n\t            0x128: 0x2100001,\n\t            0x138: 0x1,\n\t            0x148: 0x2000000,\n\t            0x158: 0x100000,\n\t            0x168: 0x401,\n\t            0x178: 0x2100400,\n\t            0x188: 0x2000001,\n\t            0x198: 0x2100000,\n\t            0x1a8: 0x0,\n\t            0x1b8: 0x2100401,\n\t            0x1c8: 0x100401,\n\t            0x1d8: 0x400,\n\t            0x1e8: 0x2000400,\n\t            0x1f8: 0x100001\n\t        },\n\t        {\n\t            0x0: 0x8000820,\n\t            0x1: 0x20000,\n\t            0x2: 0x8000000,\n\t            0x3: 0x20,\n\t            0x4: 0x20020,\n\t            0x5: 0x8020820,\n\t            0x6: 0x8020800,\n\t            0x7: 0x800,\n\t            0x8: 0x8020000,\n\t            0x9: 0x8000800,\n\t            0xa: 0x20800,\n\t            0xb: 0x8020020,\n\t            0xc: 0x820,\n\t            0xd: 0x0,\n\t            0xe: 0x8000020,\n\t            0xf: 0x20820,\n\t            0x80000000: 0x800,\n\t            0x80000001: 0x8020820,\n\t            0x80000002: 0x8000820,\n\t            0x80000003: 0x8000000,\n\t            0x80000004: 0x8020000,\n\t            0x80000005: 0x20800,\n\t            0x80000006: 0x20820,\n\t            0x80000007: 0x20,\n\t            0x80000008: 0x8000020,\n\t            0x80000009: 0x820,\n\t            0x8000000a: 0x20020,\n\t            0x8000000b: 0x8020800,\n\t            0x8000000c: 0x0,\n\t            0x8000000d: 0x8020020,\n\t            0x8000000e: 0x8000800,\n\t            0x8000000f: 0x20000,\n\t            0x10: 0x20820,\n\t            0x11: 0x8020800,\n\t            0x12: 0x20,\n\t            0x13: 0x800,\n\t            0x14: 0x8000800,\n\t            0x15: 0x8000020,\n\t            0x16: 0x8020020,\n\t            0x17: 0x20000,\n\t            0x18: 0x0,\n\t            0x19: 0x20020,\n\t            0x1a: 0x8020000,\n\t            0x1b: 0x8000820,\n\t            0x1c: 0x8020820,\n\t            0x1d: 0x20800,\n\t            0x1e: 0x820,\n\t            0x1f: 0x8000000,\n\t            0x80000010: 0x20000,\n\t            0x80000011: 0x800,\n\t            0x80000012: 0x8020020,\n\t            0x80000013: 0x20820,\n\t            0x80000014: 0x20,\n\t            0x80000015: 0x8020000,\n\t            0x80000016: 0x8000000,\n\t            0x80000017: 0x8000820,\n\t            0x80000018: 0x8020820,\n\t            0x80000019: 0x8000020,\n\t            0x8000001a: 0x8000800,\n\t            0x8000001b: 0x0,\n\t            0x8000001c: 0x20800,\n\t            0x8000001d: 0x820,\n\t            0x8000001e: 0x20020,\n\t            0x8000001f: 0x8020800\n\t        }\n\t    ];\n\n\t    // Masks that select the SBOX input\n\t    var SBOX_MASK = [\n\t        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,\n\t        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f\n\t    ];\n\n\t    /**\n\t     * DES block cipher algorithm.\n\t     */\n\t    var DES = C_algo.DES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\n\t            // Select 56 bits according to PC1\n\t            var keyBits = [];\n\t            for (var i = 0; i < 56; i++) {\n\t                var keyBitPos = PC1[i] - 1;\n\t                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;\n\t            }\n\n\t            // Assemble 16 subkeys\n\t            var subKeys = this._subKeys = [];\n\t            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {\n\t                // Create subkey\n\t                var subKey = subKeys[nSubKey] = [];\n\n\t                // Shortcut\n\t                var bitShift = BIT_SHIFTS[nSubKey];\n\n\t                // Select 48 bits according to PC2\n\t                for (var i = 0; i < 24; i++) {\n\t                    // Select from the left 28 key bits\n\t                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);\n\n\t                    // Select from the right 28 key bits\n\t                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);\n\t                }\n\n\t                // Since each subkey is applied to an expanded 32-bit input,\n\t                // the subkey can be broken into 8 values scaled to 32-bits,\n\t                // which allows the key to be used without expansion\n\t                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);\n\t                for (var i = 1; i < 7; i++) {\n\t                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);\n\t                }\n\t                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);\n\t            }\n\n\t            // Compute inverse subkeys\n\t            var invSubKeys = this._invSubKeys = [];\n\t            for (var i = 0; i < 16; i++) {\n\t                invSubKeys[i] = subKeys[15 - i];\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._subKeys);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._invSubKeys);\n\t        },\n\n\t        _doCryptBlock: function (M, offset, subKeys) {\n\t            // Get input\n\t            this._lBlock = M[offset];\n\t            this._rBlock = M[offset + 1];\n\n\t            // Initial permutation\n\t            exchangeLR.call(this, 4,  0x0f0f0f0f);\n\t            exchangeLR.call(this, 16, 0x0000ffff);\n\t            exchangeRL.call(this, 2,  0x33333333);\n\t            exchangeRL.call(this, 8,  0x00ff00ff);\n\t            exchangeLR.call(this, 1,  0x55555555);\n\n\t            // Rounds\n\t            for (var round = 0; round < 16; round++) {\n\t                // Shortcuts\n\t                var subKey = subKeys[round];\n\t                var lBlock = this._lBlock;\n\t                var rBlock = this._rBlock;\n\n\t                // Feistel function\n\t                var f = 0;\n\t                for (var i = 0; i < 8; i++) {\n\t                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];\n\t                }\n\t                this._lBlock = rBlock;\n\t                this._rBlock = lBlock ^ f;\n\t            }\n\n\t            // Undo swap from last round\n\t            var t = this._lBlock;\n\t            this._lBlock = this._rBlock;\n\t            this._rBlock = t;\n\n\t            // Final permutation\n\t            exchangeLR.call(this, 1,  0x55555555);\n\t            exchangeRL.call(this, 8,  0x00ff00ff);\n\t            exchangeRL.call(this, 2,  0x33333333);\n\t            exchangeLR.call(this, 16, 0x0000ffff);\n\t            exchangeLR.call(this, 4,  0x0f0f0f0f);\n\n\t            // Set output\n\t            M[offset] = this._lBlock;\n\t            M[offset + 1] = this._rBlock;\n\t        },\n\n\t        keySize: 64/32,\n\n\t        ivSize: 64/32,\n\n\t        blockSize: 64/32\n\t    });\n\n\t    // Swap bits across the left and right words\n\t    function exchangeLR(offset, mask) {\n\t        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;\n\t        this._rBlock ^= t;\n\t        this._lBlock ^= t << offset;\n\t    }\n\n\t    function exchangeRL(offset, mask) {\n\t        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;\n\t        this._lBlock ^= t;\n\t        this._rBlock ^= t << offset;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.DES = BlockCipher._createHelper(DES);\n\n\t    /**\n\t     * Triple-DES block cipher algorithm.\n\t     */\n\t    var TripleDES = C_algo.TripleDES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\t            // Make sure the key length is valid (64, 128 or >= 192 bit)\n\t            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {\n\t                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');\n\t            }\n\n\t            // Extend the key according to the keying options defined in 3DES standard\n\t            var key1 = keyWords.slice(0, 2);\n\t            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);\n\t            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);\n\n\t            // Create DES instances\n\t            this._des1 = DES.createEncryptor(WordArray.create(key1));\n\t            this._des2 = DES.createEncryptor(WordArray.create(key2));\n\t            this._des3 = DES.createEncryptor(WordArray.create(key3));\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._des1.encryptBlock(M, offset);\n\t            this._des2.decryptBlock(M, offset);\n\t            this._des3.encryptBlock(M, offset);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            this._des3.decryptBlock(M, offset);\n\t            this._des2.encryptBlock(M, offset);\n\t            this._des1.decryptBlock(M, offset);\n\t        },\n\n\t        keySize: 192/32,\n\n\t        ivSize: 64/32,\n\n\t        blockSize: 64/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.TripleDES = BlockCipher._createHelper(TripleDES);\n\t}());\n\n\n\treturn CryptoJS.TripleDES;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/tripledes.js?\n}");

/***/ }),

/***/ "./node_modules/crypto-js/x64-core.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/x64-core.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse // removed by dead control flow\n{}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var X32WordArray = C_lib.WordArray;\n\n\t    /**\n\t     * x64 namespace.\n\t     */\n\t    var C_x64 = C.x64 = {};\n\n\t    /**\n\t     * A 64-bit word.\n\t     */\n\t    var X64Word = C_x64.Word = Base.extend({\n\t        /**\n\t         * Initializes a newly created 64-bit word.\n\t         *\n\t         * @param {number} high The high 32 bits.\n\t         * @param {number} low The low 32 bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);\n\t         */\n\t        init: function (high, low) {\n\t            this.high = high;\n\t            this.low = low;\n\t        }\n\n\t        /**\n\t         * Bitwise NOTs this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after negating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var negated = x64Word.not();\n\t         */\n\t        // not: function () {\n\t            // var high = ~this.high;\n\t            // var low = ~this.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise ANDs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to AND with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after ANDing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var anded = x64Word.and(anotherX64Word);\n\t         */\n\t        // and: function (word) {\n\t            // var high = this.high & word.high;\n\t            // var low = this.low & word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise ORs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to OR with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after ORing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var ored = x64Word.or(anotherX64Word);\n\t         */\n\t        // or: function (word) {\n\t            // var high = this.high | word.high;\n\t            // var low = this.low | word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise XORs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to XOR with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after XORing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var xored = x64Word.xor(anotherX64Word);\n\t         */\n\t        // xor: function (word) {\n\t            // var high = this.high ^ word.high;\n\t            // var low = this.low ^ word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Shifts this word n bits to the left.\n\t         *\n\t         * @param {number} n The number of bits to shift.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after shifting.\n\t         *\n\t         * @example\n\t         *\n\t         *     var shifted = x64Word.shiftL(25);\n\t         */\n\t        // shiftL: function (n) {\n\t            // if (n < 32) {\n\t                // var high = (this.high << n) | (this.low >>> (32 - n));\n\t                // var low = this.low << n;\n\t            // } else {\n\t                // var high = this.low << (n - 32);\n\t                // var low = 0;\n\t            // }\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Shifts this word n bits to the right.\n\t         *\n\t         * @param {number} n The number of bits to shift.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after shifting.\n\t         *\n\t         * @example\n\t         *\n\t         *     var shifted = x64Word.shiftR(7);\n\t         */\n\t        // shiftR: function (n) {\n\t            // if (n < 32) {\n\t                // var low = (this.low >>> n) | (this.high << (32 - n));\n\t                // var high = this.high >>> n;\n\t            // } else {\n\t                // var low = this.high >>> (n - 32);\n\t                // var high = 0;\n\t            // }\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Rotates this word n bits to the left.\n\t         *\n\t         * @param {number} n The number of bits to rotate.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after rotating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var rotated = x64Word.rotL(25);\n\t         */\n\t        // rotL: function (n) {\n\t            // return this.shiftL(n).or(this.shiftR(64 - n));\n\t        // },\n\n\t        /**\n\t         * Rotates this word n bits to the right.\n\t         *\n\t         * @param {number} n The number of bits to rotate.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after rotating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var rotated = x64Word.rotR(7);\n\t         */\n\t        // rotR: function (n) {\n\t            // return this.shiftR(n).or(this.shiftL(64 - n));\n\t        // },\n\n\t        /**\n\t         * Adds this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to add with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after adding.\n\t         *\n\t         * @example\n\t         *\n\t         *     var added = x64Word.add(anotherX64Word);\n\t         */\n\t        // add: function (word) {\n\t            // var low = (this.low + word.low) | 0;\n\t            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;\n\t            // var high = (this.high + word.high + carry) | 0;\n\n\t            // return X64Word.create(high, low);\n\t        // }\n\t    });\n\n\t    /**\n\t     * An array of 64-bit words.\n\t     *\n\t     * @property {Array} words The array of CryptoJS.x64.Word objects.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var X64WordArray = C_x64.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create();\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create([\n\t         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n\t         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n\t         *     ]);\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create([\n\t         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n\t         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n\t         *     ], 10);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 8;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this 64-bit word array to a 32-bit word array.\n\t         *\n\t         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var x32WordArray = x64WordArray.toX32();\n\t         */\n\t        toX32: function () {\n\t            // Shortcuts\n\t            var x64Words = this.words;\n\t            var x64WordsLength = x64Words.length;\n\n\t            // Convert\n\t            var x32Words = [];\n\t            for (var i = 0; i < x64WordsLength; i++) {\n\t                var x64Word = x64Words[i];\n\t                x32Words.push(x64Word.high);\n\t                x32Words.push(x64Word.low);\n\t            }\n\n\t            return X32WordArray.create(x32Words, this.sigBytes);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {X64WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = x64WordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\n\t            // Clone \"words\" array\n\t            var words = clone.words = this.words.slice(0);\n\n\t            // Clone each X64Word object\n\t            var wordsLength = words.length;\n\t            for (var i = 0; i < wordsLength; i++) {\n\t                words[i] = words[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\t}());\n\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack://prom1009/./node_modules/crypto-js/x64-core.js?\n}");

/***/ }),

/***/ "./node_modules/moment/locale sync recursive [/\\\\](es-us(\\.js)?)$":
/*!***************************************************************!*\
  !*** ./node_modules/moment/locale/ sync [/\\](es-us(\.js)?)$ ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var map = {\n\t\"./es-us\": \"./node_modules/moment/locale/es-us.js\",\n\t\"./es-us.js\": \"./node_modules/moment/locale/es-us.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./node_modules/moment/locale sync recursive [/\\\\\\\\](es-us(\\\\.js)?)$\";\n\n//# sourceURL=webpack://prom1009/./node_modules/moment/locale/_sync_%5B/\\\\%5D(es-us(\\.js)?\n}");

/***/ }),

/***/ "./node_modules/moment/locale/es-us.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/es-us.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("{//! moment.js locale configuration\n//! locale : Spanish (United States) [es-us]\n//! author : bustta : https://github.com/bustta\n//! author : chrisrodz : https://github.com/chrisrodz\n\n;(function (global, factory) {\n    true ? factory(__webpack_require__(/*! ../moment */ \"./node_modules/moment/moment.js\")) :\n   0\n}(this, (function (moment) { 'use strict';\n\n    //! moment.js locale configuration\n\n    var monthsShortDot =\n            'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(\n                '_'\n            ),\n        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),\n        monthsParse = [\n            /^ene/i,\n            /^feb/i,\n            /^mar/i,\n            /^abr/i,\n            /^may/i,\n            /^jun/i,\n            /^jul/i,\n            /^ago/i,\n            /^sep/i,\n            /^oct/i,\n            /^nov/i,\n            /^dic/i,\n        ],\n        monthsRegex =\n            /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\\.?|feb\\.?|mar\\.?|abr\\.?|may\\.?|jun\\.?|jul\\.?|ago\\.?|sep\\.?|oct\\.?|nov\\.?|dic\\.?)/i;\n\n    var esUs = moment.defineLocale('es-us', {\n        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(\n            '_'\n        ),\n        monthsShort: function (m, format) {\n            if (!m) {\n                return monthsShortDot;\n            } else if (/-MMM-/.test(format)) {\n                return monthsShort[m.month()];\n            } else {\n                return monthsShortDot[m.month()];\n            }\n        },\n        monthsRegex: monthsRegex,\n        monthsShortRegex: monthsRegex,\n        monthsStrictRegex:\n            /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,\n        monthsShortStrictRegex:\n            /^(ene\\.?|feb\\.?|mar\\.?|abr\\.?|may\\.?|jun\\.?|jul\\.?|ago\\.?|sep\\.?|oct\\.?|nov\\.?|dic\\.?)/i,\n        monthsParse: monthsParse,\n        longMonthsParse: monthsParse,\n        shortMonthsParse: monthsParse,\n        weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),\n        weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),\n        weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),\n        weekdaysParseExact: true,\n        longDateFormat: {\n            LT: 'h:mm A',\n            LTS: 'h:mm:ss A',\n            L: 'MM/DD/YYYY',\n            LL: 'D [de] MMMM [de] YYYY',\n            LLL: 'D [de] MMMM [de] YYYY h:mm A',\n            LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',\n        },\n        calendar: {\n            sameDay: function () {\n                return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';\n            },\n            nextDay: function () {\n                return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';\n            },\n            nextWeek: function () {\n                return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';\n            },\n            lastDay: function () {\n                return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';\n            },\n            lastWeek: function () {\n                return (\n                    '[el] dddd [pasado a la' +\n                    (this.hours() !== 1 ? 's' : '') +\n                    '] LT'\n                );\n            },\n            sameElse: 'L',\n        },\n        relativeTime: {\n            future: 'en %s',\n            past: 'hace %s',\n            s: 'unos segundos',\n            ss: '%d segundos',\n            m: 'un minuto',\n            mm: '%d minutos',\n            h: 'una hora',\n            hh: '%d horas',\n            d: 'un da',\n            dd: '%d das',\n            w: 'una semana',\n            ww: '%d semanas',\n            M: 'un mes',\n            MM: '%d meses',\n            y: 'un ao',\n            yy: '%d aos',\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}/,\n        ordinal: '%d',\n        week: {\n            dow: 0, // Sunday is the first day of the week.\n            doy: 6, // The week that contains Jan 6th is the first week of the year.\n        },\n    });\n\n    return esUs;\n\n})));\n\n\n//# sourceURL=webpack://prom1009/./node_modules/moment/locale/es-us.js?\n}");

/***/ }),

/***/ "./node_modules/moment/moment.js":
/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("{/* module decorator */ module = __webpack_require__.nmd(module);\n//! moment.js\n//! version : 2.30.1\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n;(function (global, factory) {\n     true ? module.exports = factory() :\n    0\n}(this, (function () { 'use strict';\n\n    var hookCallback;\n\n    function hooks() {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback(callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return (\n            input instanceof Array ||\n            Object.prototype.toString.call(input) === '[object Array]'\n        );\n    }\n\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return (\n            input != null &&\n            Object.prototype.toString.call(input) === '[object Object]'\n        );\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return Object.getOwnPropertyNames(obj).length === 0;\n        } else {\n            var k;\n            for (k in obj) {\n                if (hasOwnProp(obj, k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function isNumber(input) {\n        return (\n            typeof input === 'number' ||\n            Object.prototype.toString.call(input) === '[object Number]'\n        );\n    }\n\n    function isDate(input) {\n        return (\n            input instanceof Date ||\n            Object.prototype.toString.call(input) === '[object Date]'\n        );\n    }\n\n    function map(arr, fn) {\n        var res = [],\n            i,\n            arrLen = arr.length;\n        for (i = 0; i < arrLen; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty: false,\n            unusedTokens: [],\n            unusedInput: [],\n            overflow: -2,\n            charsLeftOver: 0,\n            nullInput: false,\n            invalidEra: null,\n            invalidMonth: null,\n            invalidFormat: false,\n            userInvalidated: false,\n            iso: false,\n            parsedDateParts: [],\n            era: null,\n            meridiem: null,\n            rfc2822: false,\n            weekdayMismatch: false,\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function (fun) {\n            var t = Object(this),\n                len = t.length >>> 0,\n                i;\n\n            for (i = 0; i < len; i++) {\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    function isValid(m) {\n        var flags = null,\n            parsedParts = false,\n            isNowValid = m._d && !isNaN(m._d.getTime());\n        if (isNowValid) {\n            flags = getParsingFlags(m);\n            parsedParts = some.call(flags.parsedDateParts, function (i) {\n                return i != null;\n            });\n            isNowValid =\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidEra &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.weekdayMismatch &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated &&\n                (!flags.meridiem || (flags.meridiem && parsedParts));\n            if (m._strict) {\n                isNowValid =\n                    isNowValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n        }\n        if (Object.isFrozen == null || !Object.isFrozen(m)) {\n            m._isValid = isNowValid;\n        } else {\n            return isNowValid;\n        }\n        return m._isValid;\n    }\n\n    function createInvalid(flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        } else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = (hooks.momentProperties = []),\n        updateInProgress = false;\n\n    function copyConfig(to, from) {\n        var i,\n            prop,\n            val,\n            momentPropertiesLen = momentProperties.length;\n\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n\n        if (momentPropertiesLen > 0) {\n            for (i = 0; i < momentPropertiesLen; i++) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment(obj) {\n        return (\n            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)\n        );\n    }\n\n    function warn(msg) {\n        if (\n            hooks.suppressDeprecationWarnings === false &&\n            typeof console !== 'undefined' &&\n            console.warn\n        ) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [],\n                    arg,\n                    i,\n                    key,\n                    argLen = arguments.length;\n                for (i = 0; i < argLen; i++) {\n                    arg = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg += '\\n[' + i + '] ';\n                        for (key in arguments[0]) {\n                            if (hasOwnProp(arguments[0], key)) {\n                                arg += key + ': ' + arguments[0][key] + ', ';\n                            }\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(\n                    msg +\n                        '\\nArguments: ' +\n                        Array.prototype.slice.call(args).join('') +\n                        '\\n' +\n                        new Error().stack\n                );\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return (\n            (typeof Function !== 'undefined' && input instanceof Function) ||\n            Object.prototype.toString.call(input) === '[object Function]'\n        );\n    }\n\n    function set(config) {\n        var prop, i;\n        for (i in config) {\n            if (hasOwnProp(config, i)) {\n                prop = config[i];\n                if (isFunction(prop)) {\n                    this[i] = prop;\n                } else {\n                    this['_' + i] = prop;\n                }\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n                '|' +\n                /\\d{1,2}/.source\n        );\n    }\n\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig),\n            prop;\n        for (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for (prop in parentConfig) {\n            if (\n                hasOwnProp(parentConfig, prop) &&\n                !hasOwnProp(childConfig, prop) &&\n                isObject(parentConfig[prop])\n            ) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function (obj) {\n            var i,\n                res = [];\n            for (i in obj) {\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n\n    var defaultCalendar = {\n        sameDay: '[Today at] LT',\n        nextDay: '[Tomorrow at] LT',\n        nextWeek: 'dddd [at] LT',\n        lastDay: '[Yesterday at] LT',\n        lastWeek: '[Last] dddd [at] LT',\n        sameElse: 'L',\n    };\n\n    function calendar(key, mom, now) {\n        var output = this._calendar[key] || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (\n            (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +\n            absNumber\n        );\n    }\n\n    var formattingTokens =\n            /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,\n        localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,\n        formatFunctions = {},\n        formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken(token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(\n                    func.apply(this, arguments),\n                    token\n                );\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens),\n            i,\n            length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '',\n                i;\n            for (i = 0; i < length; i++) {\n                output += isFunction(array[i])\n                    ? array[i].call(mom, format)\n                    : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] =\n            formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(\n                localFormattingTokens,\n                replaceLongDateFormatTokens\n            );\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var defaultLongDateFormat = {\n        LTS: 'h:mm:ss A',\n        LT: 'h:mm A',\n        L: 'MM/DD/YYYY',\n        LL: 'MMMM D, YYYY',\n        LLL: 'MMMM D, YYYY h:mm A',\n        LLLL: 'dddd, MMMM D, YYYY h:mm A',\n    };\n\n    function longDateFormat(key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper\n            .match(formattingTokens)\n            .map(function (tok) {\n                if (\n                    tok === 'MMMM' ||\n                    tok === 'MM' ||\n                    tok === 'DD' ||\n                    tok === 'dddd'\n                ) {\n                    return tok.slice(1);\n                }\n                return tok;\n            })\n            .join('');\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate() {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d',\n        defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal(number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime = {\n        future: 'in %s',\n        past: '%s ago',\n        s: 'a few seconds',\n        ss: '%d seconds',\n        m: 'a minute',\n        mm: '%d minutes',\n        h: 'an hour',\n        hh: '%d hours',\n        d: 'a day',\n        dd: '%d days',\n        w: 'a week',\n        ww: '%d weeks',\n        M: 'a month',\n        MM: '%d months',\n        y: 'a year',\n        yy: '%d years',\n    };\n\n    function relativeTime(number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return isFunction(output)\n            ? output(number, withoutSuffix, string, isFuture)\n            : output.replace(/%d/i, number);\n    }\n\n    function pastFuture(diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n\n    var aliases = {\n        D: 'date',\n        dates: 'date',\n        date: 'date',\n        d: 'day',\n        days: 'day',\n        day: 'day',\n        e: 'weekday',\n        weekdays: 'weekday',\n        weekday: 'weekday',\n        E: 'isoWeekday',\n        isoweekdays: 'isoWeekday',\n        isoweekday: 'isoWeekday',\n        DDD: 'dayOfYear',\n        dayofyears: 'dayOfYear',\n        dayofyear: 'dayOfYear',\n        h: 'hour',\n        hours: 'hour',\n        hour: 'hour',\n        ms: 'millisecond',\n        milliseconds: 'millisecond',\n        millisecond: 'millisecond',\n        m: 'minute',\n        minutes: 'minute',\n        minute: 'minute',\n        M: 'month',\n        months: 'month',\n        month: 'month',\n        Q: 'quarter',\n        quarters: 'quarter',\n        quarter: 'quarter',\n        s: 'second',\n        seconds: 'second',\n        second: 'second',\n        gg: 'weekYear',\n        weekyears: 'weekYear',\n        weekyear: 'weekYear',\n        GG: 'isoWeekYear',\n        isoweekyears: 'isoWeekYear',\n        isoweekyear: 'isoWeekYear',\n        w: 'week',\n        weeks: 'week',\n        week: 'week',\n        W: 'isoWeek',\n        isoweeks: 'isoWeek',\n        isoweek: 'isoWeek',\n        y: 'year',\n        years: 'year',\n        year: 'year',\n    };\n\n    function normalizeUnits(units) {\n        return typeof units === 'string'\n            ? aliases[units] || aliases[units.toLowerCase()]\n            : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    var priorities = {\n        date: 9,\n        day: 11,\n        weekday: 11,\n        isoWeekday: 11,\n        dayOfYear: 4,\n        hour: 13,\n        millisecond: 16,\n        minute: 14,\n        month: 8,\n        quarter: 7,\n        second: 15,\n        weekYear: 1,\n        isoWeekYear: 1,\n        week: 5,\n        isoWeek: 5,\n        year: 1,\n    };\n\n    function getPrioritizedUnits(unitsObj) {\n        var units = [],\n            u;\n        for (u in unitsObj) {\n            if (hasOwnProp(unitsObj, u)) {\n                units.push({ unit: u, priority: priorities[u] });\n            }\n        }\n        units.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n\n    var match1 = /\\d/, //       0 - 9\n        match2 = /\\d\\d/, //      00 - 99\n        match3 = /\\d{3}/, //     000 - 999\n        match4 = /\\d{4}/, //    0000 - 9999\n        match6 = /[+-]?\\d{6}/, // -999999 - 999999\n        match1to2 = /\\d\\d?/, //       0 - 99\n        match3to4 = /\\d\\d\\d\\d?/, //     999 - 9999\n        match5to6 = /\\d\\d\\d\\d\\d\\d?/, //   99999 - 999999\n        match1to3 = /\\d{1,3}/, //       0 - 999\n        match1to4 = /\\d{1,4}/, //       0 - 9999\n        match1to6 = /[+-]?\\d{1,6}/, // -999999 - 999999\n        matchUnsigned = /\\d+/, //       0 - inf\n        matchSigned = /[+-]?\\d+/, //    -inf - inf\n        matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi, // +00:00 -00:00 +0000 -0000 or Z\n        matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n        matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/, // 123456789 123456789.123\n        // any word (or two) characters or numbers including two/three word month in arabic.\n        // includes scottish gaelic two word and hyphenated months\n        matchWord =\n            /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i,\n        match1to2NoLeadingZero = /^[1-9]\\d?/, //         1-99\n        match1to2HasZero = /^([1-9]\\d|\\d)/, //           0-99\n        regexes;\n\n    regexes = {};\n\n    function addRegexToken(token, regex, strictRegex) {\n        regexes[token] = isFunction(regex)\n            ? regex\n            : function (isStrict, localeData) {\n                  return isStrict && strictRegex ? strictRegex : regex;\n              };\n    }\n\n    function getParseRegexForToken(token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(\n            s\n                .replace('\\\\', '')\n                .replace(\n                    /\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g,\n                    function (matched, p1, p2, p3, p4) {\n                        return p1 || p2 || p3 || p4;\n                    }\n                )\n        );\n    }\n\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    function absFloor(number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    var tokens = {};\n\n    function addParseToken(token, callback) {\n        var i,\n            func = callback,\n            tokenLen;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        tokenLen = token.length;\n        for (i = 0; i < tokenLen; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken(token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    var YEAR = 0,\n        MONTH = 1,\n        DATE = 2,\n        HOUR = 3,\n        MINUTE = 4,\n        SECOND = 5,\n        MILLISECOND = 6,\n        WEEK = 7,\n        WEEKDAY = 8;\n\n    // FORMATTING\n\n    addFormatToken('Y', 0, 0, function () {\n        var y = this.year();\n        return y <= 9999 ? zeroFill(y, 4) : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY', 4], 0, 'year');\n    addFormatToken(0, ['YYYYY', 5], 0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // PARSING\n\n    addRegexToken('Y', matchSigned);\n    addRegexToken('YY', match1to2, match2);\n    addRegexToken('YYYY', match1to4, match4);\n    addRegexToken('YYYYY', match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] =\n            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken('Y', function (input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    // HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear() {\n        return isLeapYear(this.year());\n    }\n\n    function makeGetSet(unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n\n    function get(mom, unit) {\n        if (!mom.isValid()) {\n            return NaN;\n        }\n\n        var d = mom._d,\n            isUTC = mom._isUTC;\n\n        switch (unit) {\n            case 'Milliseconds':\n                return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();\n            case 'Seconds':\n                return isUTC ? d.getUTCSeconds() : d.getSeconds();\n            case 'Minutes':\n                return isUTC ? d.getUTCMinutes() : d.getMinutes();\n            case 'Hours':\n                return isUTC ? d.getUTCHours() : d.getHours();\n            case 'Date':\n                return isUTC ? d.getUTCDate() : d.getDate();\n            case 'Day':\n                return isUTC ? d.getUTCDay() : d.getDay();\n            case 'Month':\n                return isUTC ? d.getUTCMonth() : d.getMonth();\n            case 'FullYear':\n                return isUTC ? d.getUTCFullYear() : d.getFullYear();\n            default:\n                return NaN; // Just in case\n        }\n    }\n\n    function set$1(mom, unit, value) {\n        var d, isUTC, year, month, date;\n\n        if (!mom.isValid() || isNaN(value)) {\n            return;\n        }\n\n        d = mom._d;\n        isUTC = mom._isUTC;\n\n        switch (unit) {\n            case 'Milliseconds':\n                return void (isUTC\n                    ? d.setUTCMilliseconds(value)\n                    : d.setMilliseconds(value));\n            case 'Seconds':\n                return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));\n            case 'Minutes':\n                return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));\n            case 'Hours':\n                return void (isUTC ? d.setUTCHours(value) : d.setHours(value));\n            case 'Date':\n                return void (isUTC ? d.setUTCDate(value) : d.setDate(value));\n            // case 'Day': // Not real\n            //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));\n            // case 'Month': // Not used because we need to pass two variables\n            //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));\n            case 'FullYear':\n                break; // See below ...\n            default:\n                return; // Just in case\n        }\n\n        year = value;\n        month = mom.month();\n        date = mom.date();\n        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;\n        void (isUTC\n            ? d.setUTCFullYear(year, month, date)\n            : d.setFullYear(year, month, date));\n    }\n\n    // MOMENTS\n\n    function stringGet(units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n\n    function stringSet(units, value) {\n        if (typeof units === 'object') {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units),\n                i,\n                prioritizedLen = prioritized.length;\n            for (i = 0; i < prioritizedLen; i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function mod(n, x) {\n        return ((n % x) + x) % x;\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1\n            ? isLeapYear(year)\n                ? 29\n                : 28\n            : 31 - ((modMonth % 7) % 2);\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // PARSING\n\n    addRegexToken('M', match1to2, match1to2NoLeadingZero);\n    addRegexToken('MM', match1to2, match2);\n    addRegexToken('MMM', function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var defaultLocaleMonths =\n            'January_February_March_April_May_June_July_August_September_October_November_December'.split(\n                '_'\n            ),\n        defaultLocaleMonthsShort =\n            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/,\n        defaultMonthsShortRegex = matchWord,\n        defaultMonthsRegex = matchWord;\n\n    function localeMonths(m, format) {\n        if (!m) {\n            return isArray(this._months)\n                ? this._months\n                : this._months['standalone'];\n        }\n        return isArray(this._months)\n            ? this._months[m.month()]\n            : this._months[\n                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)\n                      ? 'format'\n                      : 'standalone'\n              ][m.month()];\n    }\n\n    function localeMonthsShort(m, format) {\n        if (!m) {\n            return isArray(this._monthsShort)\n                ? this._monthsShort\n                : this._monthsShort['standalone'];\n        }\n        return isArray(this._monthsShort)\n            ? this._monthsShort[m.month()]\n            : this._monthsShort[\n                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'\n              ][m.month()];\n    }\n\n    function handleStrictParse(monthName, format, strict) {\n        var i,\n            ii,\n            mom,\n            llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000, i]);\n                this._shortMonthsParse[i] = this.monthsShort(\n                    mom,\n                    ''\n                ).toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse(monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp(\n                    '^' + this.months(mom, '').replace('.', '') + '$',\n                    'i'\n                );\n                this._shortMonthsParse[i] = new RegExp(\n                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',\n                    'i'\n                );\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex =\n                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (\n                strict &&\n                format === 'MMMM' &&\n                this._longMonthsParse[i].test(monthName)\n            ) {\n                return i;\n            } else if (\n                strict &&\n                format === 'MMM' &&\n                this._shortMonthsParse[i].test(monthName)\n            ) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth(mom, value) {\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n\n        if (typeof value === 'string') {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n\n        var month = value,\n            date = mom.date();\n\n        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));\n        void (mom._isUTC\n            ? mom._d.setUTCMonth(month, date)\n            : mom._d.setMonth(month, date));\n        return mom;\n    }\n\n    function getSetMonth(value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth() {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    function monthsShortRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict\n                ? this._monthsShortStrictRegex\n                : this._monthsShortRegex;\n        }\n    }\n\n    function monthsRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict\n                ? this._monthsStrictRegex\n                : this._monthsRegex;\n        }\n    }\n\n    function computeMonthsParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces = [],\n            longPieces = [],\n            mixedPieces = [],\n            i,\n            mom,\n            shortP,\n            longP;\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            shortP = regexEscape(this.monthsShort(mom, ''));\n            longP = regexEscape(this.months(mom, ''));\n            shortPieces.push(shortP);\n            longPieces.push(longP);\n            mixedPieces.push(longP);\n            mixedPieces.push(shortP);\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp(\n            '^(' + longPieces.join('|') + ')',\n            'i'\n        );\n        this._monthsShortStrictRegex = new RegExp(\n            '^(' + shortPieces.join('|') + ')',\n            'i'\n        );\n    }\n\n    function createDate(y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date;\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            date = new Date(y + 400, m, d, h, M, s, ms);\n            if (isFinite(date.getFullYear())) {\n                date.setFullYear(y);\n            }\n        } else {\n            date = new Date(y, m, d, h, M, s, ms);\n        }\n\n        return date;\n    }\n\n    function createUTCDate(y) {\n        var date, args;\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            args = Array.prototype.slice.call(arguments);\n            // preserve leap years using a full 400 year cycle, then reset\n            args[0] = y + 400;\n            date = new Date(Date.UTC.apply(null, args));\n            if (isFinite(date.getUTCFullYear())) {\n                date.setUTCFullYear(y);\n            }\n        } else {\n            date = new Date(Date.UTC.apply(null, arguments));\n        }\n\n        return date;\n    }\n\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            fwd = 7 + dow - doy,\n            // first-week day local weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year, dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n            resYear,\n            resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear,\n        };\n    }\n\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n            resWeek,\n            resYear;\n\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n\n        return {\n            week: resWeek,\n            year: resYear,\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n\n    // FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // PARSING\n\n    addRegexToken('w', match1to2, match1to2NoLeadingZero);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W', match1to2, match1to2NoLeadingZero);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(\n        ['w', 'ww', 'W', 'WW'],\n        function (input, week, config, token) {\n            week[token.substr(0, 1)] = toInt(input);\n        }\n    );\n\n    // HELPERS\n\n    // LOCALES\n\n    function localeWeek(mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow: 0, // Sunday is the first day of the week.\n        doy: 6, // The week that contains Jan 6th is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek() {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear() {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek(input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek(input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // PARSING\n\n    addRegexToken('d', match1to2);\n    addRegexToken('e', match1to2);\n    addRegexToken('E', match1to2);\n    addRegexToken('dd', function (isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd', function (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken('dddd', function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n\n    // LOCALES\n    function shiftWeekdays(ws, n) {\n        return ws.slice(n, 7).concat(ws.slice(0, n));\n    }\n\n    var defaultLocaleWeekdays =\n            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        defaultWeekdaysRegex = matchWord,\n        defaultWeekdaysShortRegex = matchWord,\n        defaultWeekdaysMinRegex = matchWord;\n\n    function localeWeekdays(m, format) {\n        var weekdays = isArray(this._weekdays)\n            ? this._weekdays\n            : this._weekdays[\n                  m && m !== true && this._weekdays.isFormat.test(format)\n                      ? 'format'\n                      : 'standalone'\n              ];\n        return m === true\n            ? shiftWeekdays(weekdays, this._week.dow)\n            : m\n              ? weekdays[m.day()]\n              : weekdays;\n    }\n\n    function localeWeekdaysShort(m) {\n        return m === true\n            ? shiftWeekdays(this._weekdaysShort, this._week.dow)\n            : m\n              ? this._weekdaysShort[m.day()]\n              : this._weekdaysShort;\n    }\n\n    function localeWeekdaysMin(m) {\n        return m === true\n            ? shiftWeekdays(this._weekdaysMin, this._week.dow)\n            : m\n              ? this._weekdaysMin[m.day()]\n              : this._weekdaysMin;\n    }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i,\n            ii,\n            mom,\n            llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i < 7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(\n                    mom,\n                    ''\n                ).toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(\n                    mom,\n                    ''\n                ).toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse(weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n            mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp(\n                    '^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$',\n                    'i'\n                );\n                this._shortWeekdaysParse[i] = new RegExp(\n                    '^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$',\n                    'i'\n                );\n                this._minWeekdaysParse[i] = new RegExp(\n                    '^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$',\n                    'i'\n                );\n            }\n            if (!this._weekdaysParse[i]) {\n                regex =\n                    '^' +\n                    this.weekdays(mom, '') +\n                    '|^' +\n                    this.weekdaysShort(mom, '') +\n                    '|^' +\n                    this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (\n                strict &&\n                format === 'dddd' &&\n                this._fullWeekdaysParse[i].test(weekdayName)\n            ) {\n                return i;\n            } else if (\n                strict &&\n                format === 'ddd' &&\n                this._shortWeekdaysParse[i].test(weekdayName)\n            ) {\n                return i;\n            } else if (\n                strict &&\n                format === 'dd' &&\n                this._minWeekdaysParse[i].test(weekdayName)\n            ) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        var day = get(this, 'Day');\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n    function weekdaysRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict\n                ? this._weekdaysStrictRegex\n                : this._weekdaysRegex;\n        }\n    }\n\n    function weekdaysShortRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict\n                ? this._weekdaysShortStrictRegex\n                : this._weekdaysShortRegex;\n        }\n    }\n\n    function weekdaysMinRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict\n                ? this._weekdaysMinStrictRegex\n                : this._weekdaysMinRegex;\n        }\n    }\n\n    function computeWeekdaysParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var minPieces = [],\n            shortPieces = [],\n            longPieces = [],\n            mixedPieces = [],\n            i,\n            mom,\n            minp,\n            shortp,\n            longp;\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, 1]).day(i);\n            minp = regexEscape(this.weekdaysMin(mom, ''));\n            shortp = regexEscape(this.weekdaysShort(mom, ''));\n            longp = regexEscape(this.weekdays(mom, ''));\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n        this._weekdaysStrictRegex = new RegExp(\n            '^(' + longPieces.join('|') + ')',\n            'i'\n        );\n        this._weekdaysShortStrictRegex = new RegExp(\n            '^(' + shortPieces.join('|') + ')',\n            'i'\n        );\n        this._weekdaysMinStrictRegex = new RegExp(\n            '^(' + minPieces.join('|') + ')',\n            'i'\n        );\n    }\n\n    // FORMATTING\n\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours() || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return (\n            '' +\n            hFormat.apply(this) +\n            zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2)\n        );\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss', 0, 0, function () {\n        return (\n            '' +\n            this.hours() +\n            zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2)\n        );\n    });\n\n    function meridiem(token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(\n                this.hours(),\n                this.minutes(),\n                lowercase\n            );\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // PARSING\n\n    function matchMeridiem(isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a', matchMeridiem);\n    addRegexToken('A', matchMeridiem);\n    addRegexToken('H', match1to2, match1to2HasZero);\n    addRegexToken('h', match1to2, match1to2NoLeadingZero);\n    addRegexToken('k', match1to2, match1to2NoLeadingZero);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk', match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss', match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss', match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k', 'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n        var pos1 = input.length - 4,\n            pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss', function (input, array, config) {\n        var pos1 = input.length - 4,\n            pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n\n    // LOCALES\n\n    function localeIsPM(input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return (input + '').toLowerCase().charAt(0) === 'p';\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i,\n        // Setting the hour should keep the time, because the user explicitly\n        // specified which hour they want. So trying to maintain the same hour (in\n        // a new timezone) makes sense. Adding/subtracting hours does not follow\n        // this rule.\n        getSetHour = makeGetSet('Hours', true);\n\n    function localeMeridiem(hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n        week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n        meridiemParse: defaultLocaleMeridiemParse,\n    };\n\n    // internal storage for locale config files\n    var locales = {},\n        localeFamilies = {},\n        globalLocale;\n\n    function commonPrefix(arr1, arr2) {\n        var i,\n            minl = Math.min(arr1.length, arr2.length);\n        for (i = 0; i < minl; i += 1) {\n            if (arr1[i] !== arr2[i]) {\n                return i;\n            }\n        }\n        return minl;\n    }\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0,\n            j,\n            next,\n            locale,\n            split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (\n                    next &&\n                    next.length >= j &&\n                    commonPrefix(split, next) >= j - 1\n                ) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n\n    function isLocaleNameSane(name) {\n        // Prevent names that look like filesystem paths, i.e contain '/' or '\\'\n        // Ensure name is available and function returns boolean\n        return !!(name && name.match('^[^/\\\\\\\\]*$'));\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null,\n            aliasedRequire;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (\n            locales[name] === undefined &&\n            \"object\" !== 'undefined' &&\n            module &&\n            module.exports &&\n            isLocaleNameSane(name)\n        ) {\n            try {\n                oldLocale = globalLocale._abbr;\n                aliasedRequire = undefined;\n                __webpack_require__(\"./node_modules/moment/locale sync recursive [/\\\\\\\\](es-us(\\\\.js)?)$\")(\"./\" + name);\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {\n                // mark as not found to avoid repeating expensive file require call causing high CPU\n                // when trying to find en-US, en_US, en-us for every format call\n                locales[name] = null; // null means not found\n            }\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale(key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            } else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            } else {\n                if (typeof console !== 'undefined' && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn(\n                        'Locale ' + key + ' not found. Did you forget to load it?'\n                    );\n                }\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale(name, config) {\n        if (config !== null) {\n            var locale,\n                parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple(\n                    'defineLocaleOverride',\n                    'use moment.updateLocale(localeName, config) to change ' +\n                        'an existing locale. moment.defineLocale(localeName, ' +\n                        'config) should only be used for creating a new locale ' +\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'\n                );\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config,\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function (x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale,\n                tmpLocale,\n                parentConfig = baseConfig;\n\n            if (locales[name] != null && locales[name].parentLocale != null) {\n                // Update existing child locale in-place to avoid memory-leaks\n                locales[name].set(mergeConfigs(locales[name]._config, config));\n            } else {\n                // MERGE\n                tmpLocale = loadLocale(name);\n                if (tmpLocale != null) {\n                    parentConfig = tmpLocale._config;\n                }\n                config = mergeConfigs(parentConfig, config);\n                if (tmpLocale == null) {\n                    // updateLocale is called for creating a new locale\n                    // Set abbr so it will have a name (getters return\n                    // undefined otherwise).\n                    config.abbr = name;\n                }\n                locale = new Locale(config);\n                locale.parentLocale = locales[name];\n                locales[name] = locale;\n            }\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                    if (name === getSetGlobalLocale()) {\n                        getSetGlobalLocale(name);\n                    }\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n\n    // returns locale data\n    function getLocale(key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys(locales);\n    }\n\n    function checkOverflow(m) {\n        var overflow,\n            a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH] < 0 || a[MONTH] > 11\n                    ? MONTH\n                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])\n                      ? DATE\n                      : a[HOUR] < 0 ||\n                          a[HOUR] > 24 ||\n                          (a[HOUR] === 24 &&\n                              (a[MINUTE] !== 0 ||\n                                  a[SECOND] !== 0 ||\n                                  a[MILLISECOND] !== 0))\n                        ? HOUR\n                        : a[MINUTE] < 0 || a[MINUTE] > 59\n                          ? MINUTE\n                          : a[SECOND] < 0 || a[SECOND] > 59\n                            ? SECOND\n                            : a[MILLISECOND] < 0 || a[MILLISECOND] > 999\n                              ? MILLISECOND\n                              : -1;\n\n            if (\n                getParsingFlags(m)._overflowDayOfYear &&\n                (overflow < YEAR || overflow > DATE)\n            ) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex =\n            /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n        basicIsoRegex =\n            /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n        tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/,\n        isoDates = [\n            ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n            ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n            ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n            ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n            ['YYYY-DDD', /\\d{4}-\\d{3}/],\n            ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n            ['YYYYYYMMDD', /[+-]\\d{10}/],\n            ['YYYYMMDD', /\\d{8}/],\n            ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n            ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n            ['YYYYDDD', /\\d{7}/],\n            ['YYYYMM', /\\d{6}/, false],\n            ['YYYY', /\\d{4}/, false],\n        ],\n        // iso time formats and regexes\n        isoTimes = [\n            ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n            ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n            ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n            ['HH:mm', /\\d\\d:\\d\\d/],\n            ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n            ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n            ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n            ['HHmm', /\\d\\d\\d\\d/],\n            ['HH', /\\d\\d/],\n        ],\n        aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i,\n        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n        rfc2822 =\n            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/,\n        obsOffsets = {\n            UT: 0,\n            GMT: 0,\n            EDT: -4 * 60,\n            EST: -5 * 60,\n            CDT: -5 * 60,\n            CST: -6 * 60,\n            MDT: -6 * 60,\n            MST: -7 * 60,\n            PDT: -7 * 60,\n            PST: -8 * 60,\n        };\n\n    // date from iso format\n    function configFromISO(config) {\n        var i,\n            l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n            allowTime,\n            dateFormat,\n            timeFormat,\n            tzFormat,\n            isoDatesLen = isoDates.length,\n            isoTimesLen = isoTimes.length;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n            for (i = 0, l = isoDatesLen; i < l; i++) {\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for (i = 0, l = isoTimesLen; i < l; i++) {\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = 'Z';\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    function extractFromRFC2822Strings(\n        yearStr,\n        monthStr,\n        dayStr,\n        hourStr,\n        minuteStr,\n        secondStr\n    ) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10),\n        ];\n\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n\n        return result;\n    }\n\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s\n            .replace(/\\([^()]*\\)|[\\n\\t]/g, ' ')\n            .replace(/(\\s\\s+)/g, ' ')\n            .replace(/^\\s\\s*/, '')\n            .replace(/\\s\\s*$/, '');\n    }\n\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n                weekdayActual = new Date(\n                    parsedInput[0],\n                    parsedInput[1],\n                    parsedInput[2]\n                ).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10),\n                m = hm % 100,\n                h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i)),\n            parsedArray;\n        if (match) {\n            parsedArray = extractFromRFC2822Strings(\n                match[4],\n                match[3],\n                match[2],\n                match[5],\n                match[6],\n                match[7]\n            );\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        if (config._strict) {\n            config._isValid = false;\n        } else {\n            // Final attempt, use Input Fallback\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [\n                nowValue.getUTCFullYear(),\n                nowValue.getUTCMonth(),\n                nowValue.getUTCDate(),\n            ];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray(config) {\n        var i,\n            date,\n            input = [],\n            currentDate,\n            expectedWeekday,\n            yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (\n                config._dayOfYear > daysInYear(yearToUse) ||\n                config._dayOfYear === 0\n            ) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] =\n                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (\n            config._a[HOUR] === 24 &&\n            config._a[MINUTE] === 0 &&\n            config._a[SECOND] === 0 &&\n            config._a[MILLISECOND] === 0\n        ) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(\n            null,\n            input\n        );\n        expectedWeekday = config._useUTC\n            ? config._d.getUTCDay()\n            : config._d.getDay();\n\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n\n        // check for mismatching day of week\n        if (\n            config._w &&\n            typeof config._w.d !== 'undefined' &&\n            config._w.d !== expectedWeekday\n        ) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(\n                w.GG,\n                config._a[YEAR],\n                weekOfYear(createLocal(), 1, 4).year\n            );\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from beginning of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to beginning of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i,\n            parsedInput,\n            tokens,\n            token,\n            skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0,\n            era,\n            tokenLen;\n\n        tokens =\n            expandFormat(config._f, config._locale).match(formattingTokens) || [];\n        tokenLen = tokens.length;\n        for (i = 0; i < tokenLen; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) ||\n                [])[0];\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(\n                    string.indexOf(parsedInput) + parsedInput.length\n                );\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                } else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            } else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver =\n            stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (\n            config._a[HOUR] <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR] > 0\n        ) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(\n            config._locale,\n            config._a[HOUR],\n            config._meridiem\n        );\n\n        // handle era\n        era = getParsingFlags(config).era;\n        if (era !== null) {\n            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n        }\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n    function meridiemFixWrap(locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n            scoreToBeat,\n            i,\n            currentScore,\n            validFormatFound,\n            bestFormatIsValid = false,\n            configfLen = config._f.length;\n\n        if (configfLen === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < configfLen; i++) {\n            currentScore = 0;\n            validFormatFound = false;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (isValid(tempConfig)) {\n                validFormatFound = true;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (!bestFormatIsValid) {\n                if (\n                    scoreToBeat == null ||\n                    currentScore < scoreToBeat ||\n                    validFormatFound\n                ) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                    if (validFormatFound) {\n                        bestFormatIsValid = true;\n                    }\n                }\n            } else {\n                if (currentScore < scoreToBeat) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                }\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i),\n            dayOrDate = i.day === undefined ? i.date : i.day;\n        config._a = map(\n            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],\n            function (obj) {\n                return obj && parseInt(obj, 10);\n            }\n        );\n\n        configFromArray(config);\n    }\n\n    function createFromConfig(config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig(config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return createInvalid({ nullInput: true });\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        } else {\n            configFromInput(config);\n        }\n\n        if (!isValid(config)) {\n            config._d = null;\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC(input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (format === true || format === false) {\n            strict = format;\n            format = undefined;\n        }\n\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n\n        if (\n            (isObject(input) && isObjectEmpty(input)) ||\n            (isArray(input) && input.length === 0)\n        ) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n            function () {\n                var other = createLocal.apply(null, arguments);\n                if (this.isValid() && other.isValid()) {\n                    return other < this ? this : other;\n                } else {\n                    return createInvalid();\n                }\n            }\n        ),\n        prototypeMax = deprecate(\n            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n            function () {\n                var other = createLocal.apply(null, arguments);\n                if (this.isValid() && other.isValid()) {\n                    return other > this ? this : other;\n                } else {\n                    return createInvalid();\n                }\n            }\n        );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min() {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max() {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    var now = function () {\n        return Date.now ? Date.now() : +new Date();\n    };\n\n    var ordering = [\n        'year',\n        'quarter',\n        'month',\n        'week',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'millisecond',\n    ];\n\n    function isDurationValid(m) {\n        var key,\n            unitHasDecimal = false,\n            i,\n            orderLen = ordering.length;\n        for (key in m) {\n            if (\n                hasOwnProp(m, key) &&\n                !(\n                    indexOf.call(ordering, key) !== -1 &&\n                    (m[key] == null || !isNaN(m[key]))\n                )\n            ) {\n                return false;\n            }\n        }\n\n        for (i = 0; i < orderLen; ++i) {\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function isValid$1() {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n\n    function Duration(duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n        // representation for dateAddRemove\n        this._milliseconds =\n            +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days + weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months + quarters * 3 + years * 12;\n\n        this._data = {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration(obj) {\n        return obj instanceof Duration;\n    }\n\n    function absRound(number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if (\n                (dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))\n            ) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    // FORMATTING\n\n    function offset(token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset(),\n                sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return (\n                sign +\n                zeroFill(~~(offset / 60), 2) +\n                separator +\n                zeroFill(~~offset % 60, 2)\n            );\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z', matchShortOffset);\n    addRegexToken('ZZ', matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(matcher, string) {\n        var matches = (string || '').match(matcher),\n            chunk,\n            parts,\n            minutes;\n\n        if (matches === null) {\n            return null;\n        }\n\n        chunk = matches[matches.length - 1] || [];\n        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff =\n                (isMoment(input) || isDate(input)\n                    ? input.valueOf()\n                    : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n\n    function getDateOffset(m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset());\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset(input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(\n                        this,\n                        createDuration(input - offset, 'm'),\n                        1,\n                        false\n                    );\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone(input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC(keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal(keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset() {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === 'string') {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            } else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset(input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime() {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted() {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n\n        var c = {},\n            other;\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted =\n                this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal() {\n        return this.isValid() ? !this._isUTC : false;\n    }\n\n    function isUtcOffset() {\n        return this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc() {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/,\n        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n        // and further modified to allow for strings containing both week and day\n        isoRegex =\n            /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n    function createDuration(input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms: input._milliseconds,\n                d: input._days,\n                M: input._months,\n            };\n        } else if (isNumber(input) || !isNaN(+input)) {\n            duration = {};\n            if (key) {\n                duration[key] = +input;\n            } else {\n                duration.milliseconds = +input;\n            }\n        } else if ((match = aspNetRegex.exec(input))) {\n            sign = match[1] === '-' ? -1 : 1;\n            duration = {\n                y: 0,\n                d: toInt(match[DATE]) * sign,\n                h: toInt(match[HOUR]) * sign,\n                m: toInt(match[MINUTE]) * sign,\n                s: toInt(match[SECOND]) * sign,\n                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match\n            };\n        } else if ((match = isoRegex.exec(input))) {\n            sign = match[1] === '-' ? -1 : 1;\n            duration = {\n                y: parseIso(match[2], sign),\n                M: parseIso(match[3], sign),\n                w: parseIso(match[4], sign),\n                d: parseIso(match[5], sign),\n                h: parseIso(match[6], sign),\n                m: parseIso(match[7], sign),\n                s: parseIso(match[8], sign),\n            };\n        } else if (duration == null) {\n            // checks for null or undefined\n            duration = {};\n        } else if (\n            typeof duration === 'object' &&\n            ('from' in duration || 'to' in duration)\n        ) {\n            diffRes = momentsDifference(\n                createLocal(duration.from),\n                createLocal(duration.to)\n            );\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        if (isDuration(input) && hasOwnProp(input, '_isValid')) {\n            ret._isValid = input._isValid;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function parseIso(inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {};\n\n        res.months =\n            other.month() - base.month() + (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +base.clone().add(res.months, 'M');\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return { milliseconds: 0, months: 0 };\n        }\n\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(\n                    name,\n                    'moment().' +\n                        name +\n                        '(period, number) is deprecated. Please use moment().' +\n                        name +\n                        '(number, period). ' +\n                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'\n                );\n                tmp = val;\n                val = period;\n                period = tmp;\n            }\n\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addSubtract(mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n            months = absRound(duration._months);\n\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (months) {\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add = createAdder(1, 'add'),\n        subtract = createAdder(-1, 'subtract');\n\n    function isString(input) {\n        return typeof input === 'string' || input instanceof String;\n    }\n\n    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined\n    function isMomentInput(input) {\n        return (\n            isMoment(input) ||\n            isDate(input) ||\n            isString(input) ||\n            isNumber(input) ||\n            isNumberOrStringArray(input) ||\n            isMomentInputObject(input) ||\n            input === null ||\n            input === undefined\n        );\n    }\n\n    function isMomentInputObject(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input),\n            propertyTest = false,\n            properties = [\n                'years',\n                'year',\n                'y',\n                'months',\n                'month',\n                'M',\n                'days',\n                'day',\n                'd',\n                'dates',\n                'date',\n                'D',\n                'hours',\n                'hour',\n                'h',\n                'minutes',\n                'minute',\n                'm',\n                'seconds',\n                'second',\n                's',\n                'milliseconds',\n                'millisecond',\n                'ms',\n            ],\n            i,\n            property,\n            propertyLen = properties.length;\n\n        for (i = 0; i < propertyLen; i += 1) {\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n\n        return objectTest && propertyTest;\n    }\n\n    function isNumberOrStringArray(input) {\n        var arrayTest = isArray(input),\n            dataTypeTest = false;\n        if (arrayTest) {\n            dataTypeTest =\n                input.filter(function (item) {\n                    return !isNumber(item) && isString(input);\n                }).length === 0;\n        }\n        return arrayTest && dataTypeTest;\n    }\n\n    function isCalendarSpec(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input),\n            propertyTest = false,\n            properties = [\n                'sameDay',\n                'nextDay',\n                'lastDay',\n                'nextWeek',\n                'lastWeek',\n                'sameElse',\n            ],\n            i,\n            property;\n\n        for (i = 0; i < properties.length; i += 1) {\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n\n        return objectTest && propertyTest;\n    }\n\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff < -6\n            ? 'sameElse'\n            : diff < -1\n              ? 'lastWeek'\n              : diff < 0\n                ? 'lastDay'\n                : diff < 1\n                  ? 'sameDay'\n                  : diff < 2\n                    ? 'nextDay'\n                    : diff < 7\n                      ? 'nextWeek'\n                      : 'sameElse';\n    }\n\n    function calendar$1(time, formats) {\n        // Support for single parameter, formats only overload to the calendar function\n        if (arguments.length === 1) {\n            if (!arguments[0]) {\n                time = undefined;\n                formats = undefined;\n            } else if (isMomentInput(arguments[0])) {\n                time = arguments[0];\n                formats = undefined;\n            } else if (isCalendarSpec(arguments[0])) {\n                formats = arguments[0];\n                time = undefined;\n            }\n        }\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this, sod) || 'sameElse',\n            output =\n                formats &&\n                (isFunction(formats[format])\n                    ? formats[format].call(this, now)\n                    : formats[format]);\n\n        return this.format(\n            output || this.localeData().calendar(format, this, createLocal(now))\n        );\n    }\n\n    function clone() {\n        return new Moment(this);\n    }\n\n    function isAfter(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n\n    function isBefore(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n\n    function isBetween(from, to, units, inclusivity) {\n        var localFrom = isMoment(from) ? from : createLocal(from),\n            localTo = isMoment(to) ? to : createLocal(to);\n        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n            return false;\n        }\n        inclusivity = inclusivity || '()';\n        return (\n            (inclusivity[0] === '('\n                ? this.isAfter(localFrom, units)\n                : !this.isBefore(localFrom, units)) &&\n            (inclusivity[1] === ')'\n                ? this.isBefore(localTo, units)\n                : !this.isAfter(localTo, units))\n        );\n    }\n\n    function isSame(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return (\n                this.clone().startOf(units).valueOf() <= inputMs &&\n                inputMs <= this.clone().endOf(units).valueOf()\n            );\n        }\n    }\n\n    function isSameOrAfter(input, units) {\n        return this.isSame(input, units) || this.isAfter(input, units);\n    }\n\n    function isSameOrBefore(input, units) {\n        return this.isSame(input, units) || this.isBefore(input, units);\n    }\n\n    function diff(input, units, asFloat) {\n        var that, zoneDelta, output;\n\n        if (!this.isValid()) {\n            return NaN;\n        }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid()) {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        switch (units) {\n            case 'year':\n                output = monthDiff(this, that) / 12;\n                break;\n            case 'month':\n                output = monthDiff(this, that);\n                break;\n            case 'quarter':\n                output = monthDiff(this, that) / 3;\n                break;\n            case 'second':\n                output = (this - that) / 1e3;\n                break; // 1000\n            case 'minute':\n                output = (this - that) / 6e4;\n                break; // 1000 * 60\n            case 'hour':\n                output = (this - that) / 36e5;\n                break; // 1000 * 60 * 60\n            case 'day':\n                output = (this - that - zoneDelta) / 864e5;\n                break; // 1000 * 60 * 60 * 24, negate dst\n            case 'week':\n                output = (this - that - zoneDelta) / 6048e5;\n                break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default:\n                output = this - that;\n        }\n\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff(a, b) {\n        if (a.date() < b.date()) {\n            // end-of-month calculations work correct when the start month has more\n            // days than the end month.\n            return -monthDiff(b, a);\n        }\n        // difference in months\n        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2,\n            adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n    function toString() {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true,\n            m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(\n                m,\n                utc\n                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'\n                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'\n            );\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)\n                    .toISOString()\n                    .replace('Z', formatMoment(m, 'Z'));\n            }\n        }\n        return formatMoment(\n            m,\n            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'\n        );\n    }\n\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */\n    function inspect() {\n        if (!this.isValid()) {\n            return 'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment',\n            zone = '',\n            prefix,\n            year,\n            datetime,\n            suffix;\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n        prefix = '[' + func + '(\"]';\n        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';\n        datetime = '-MM-DD[T]HH:mm:ss.SSS';\n        suffix = zone + '[\")]';\n\n        return this.format(prefix + year + datetime + suffix);\n    }\n\n    function format(inputString) {\n        if (!inputString) {\n            inputString = this.isUtc()\n                ? hooks.defaultFormatUtc\n                : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n\n    function from(time, withoutSuffix) {\n        if (\n            this.isValid() &&\n            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())\n        ) {\n            return createDuration({ to: this, from: time })\n                .locale(this.locale())\n                .humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function fromNow(withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n\n    function to(time, withoutSuffix) {\n        if (\n            this.isValid() &&\n            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())\n        ) {\n            return createDuration({ from: this, to: time })\n                .locale(this.locale())\n                .humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function toNow(withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale(key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData() {\n        return this._locale;\n    }\n\n    var MS_PER_SECOND = 1000,\n        MS_PER_MINUTE = 60 * MS_PER_SECOND,\n        MS_PER_HOUR = 60 * MS_PER_MINUTE,\n        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n\n    // actual modulo - handles negative numbers (for dates before 1970):\n    function mod$1(dividend, divisor) {\n        return ((dividend % divisor) + divisor) % divisor;\n    }\n\n    function localStartOfDate(y, m, d) {\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return new Date(y, m, d).valueOf();\n        }\n    }\n\n    function utcStartOfDate(y, m, d) {\n        // Date.UTC remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return Date.UTC(y, m, d);\n        }\n    }\n\n    function startOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond' || !this.isValid()) {\n            return this;\n        }\n\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n        switch (units) {\n            case 'year':\n                time = startOfDate(this.year(), 0, 1);\n                break;\n            case 'quarter':\n                time = startOfDate(\n                    this.year(),\n                    this.month() - (this.month() % 3),\n                    1\n                );\n                break;\n            case 'month':\n                time = startOfDate(this.year(), this.month(), 1);\n                break;\n            case 'week':\n                time = startOfDate(\n                    this.year(),\n                    this.month(),\n                    this.date() - this.weekday()\n                );\n                break;\n            case 'isoWeek':\n                time = startOfDate(\n                    this.year(),\n                    this.month(),\n                    this.date() - (this.isoWeekday() - 1)\n                );\n                break;\n            case 'day':\n            case 'date':\n                time = startOfDate(this.year(), this.month(), this.date());\n                break;\n            case 'hour':\n                time = this._d.valueOf();\n                time -= mod$1(\n                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),\n                    MS_PER_HOUR\n                );\n                break;\n            case 'minute':\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_MINUTE);\n                break;\n            case 'second':\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_SECOND);\n                break;\n        }\n\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n\n    function endOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond' || !this.isValid()) {\n            return this;\n        }\n\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n        switch (units) {\n            case 'year':\n                time = startOfDate(this.year() + 1, 0, 1) - 1;\n                break;\n            case 'quarter':\n                time =\n                    startOfDate(\n                        this.year(),\n                        this.month() - (this.month() % 3) + 3,\n                        1\n                    ) - 1;\n                break;\n            case 'month':\n                time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n                break;\n            case 'week':\n                time =\n                    startOfDate(\n                        this.year(),\n                        this.month(),\n                        this.date() - this.weekday() + 7\n                    ) - 1;\n                break;\n            case 'isoWeek':\n                time =\n                    startOfDate(\n                        this.year(),\n                        this.month(),\n                        this.date() - (this.isoWeekday() - 1) + 7\n                    ) - 1;\n                break;\n            case 'day':\n            case 'date':\n                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n                break;\n            case 'hour':\n                time = this._d.valueOf();\n                time +=\n                    MS_PER_HOUR -\n                    mod$1(\n                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),\n                        MS_PER_HOUR\n                    ) -\n                    1;\n                break;\n            case 'minute':\n                time = this._d.valueOf();\n                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n                break;\n            case 'second':\n                time = this._d.valueOf();\n                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n                break;\n        }\n\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n\n    function valueOf() {\n        return this._d.valueOf() - (this._offset || 0) * 60000;\n    }\n\n    function unix() {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function toDate() {\n        return new Date(this.valueOf());\n    }\n\n    function toArray() {\n        var m = this;\n        return [\n            m.year(),\n            m.month(),\n            m.date(),\n            m.hour(),\n            m.minute(),\n            m.second(),\n            m.millisecond(),\n        ];\n    }\n\n    function toObject() {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds(),\n        };\n    }\n\n    function toJSON() {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n    function isValid$2() {\n        return isValid(this);\n    }\n\n    function parsingFlags() {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt() {\n        return getParsingFlags(this).overflow;\n    }\n\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict,\n        };\n    }\n\n    addFormatToken('N', 0, 0, 'eraAbbr');\n    addFormatToken('NN', 0, 0, 'eraAbbr');\n    addFormatToken('NNN', 0, 0, 'eraAbbr');\n    addFormatToken('NNNN', 0, 0, 'eraName');\n    addFormatToken('NNNNN', 0, 0, 'eraNarrow');\n\n    addFormatToken('y', ['y', 1], 'yo', 'eraYear');\n    addFormatToken('y', ['yy', 2], 0, 'eraYear');\n    addFormatToken('y', ['yyy', 3], 0, 'eraYear');\n    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');\n\n    addRegexToken('N', matchEraAbbr);\n    addRegexToken('NN', matchEraAbbr);\n    addRegexToken('NNN', matchEraAbbr);\n    addRegexToken('NNNN', matchEraName);\n    addRegexToken('NNNNN', matchEraNarrow);\n\n    addParseToken(\n        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],\n        function (input, array, config, token) {\n            var era = config._locale.erasParse(input, token, config._strict);\n            if (era) {\n                getParsingFlags(config).era = era;\n            } else {\n                getParsingFlags(config).invalidEra = input;\n            }\n        }\n    );\n\n    addRegexToken('y', matchUnsigned);\n    addRegexToken('yy', matchUnsigned);\n    addRegexToken('yyy', matchUnsigned);\n    addRegexToken('yyyy', matchUnsigned);\n    addRegexToken('yo', matchEraYearOrdinal);\n\n    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);\n    addParseToken(['yo'], function (input, array, config, token) {\n        var match;\n        if (config._locale._eraYearOrdinalRegex) {\n            match = input.match(config._locale._eraYearOrdinalRegex);\n        }\n\n        if (config._locale.eraYearOrdinalParse) {\n            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);\n        } else {\n            array[YEAR] = parseInt(input, 10);\n        }\n    });\n\n    function localeEras(m, format) {\n        var i,\n            l,\n            date,\n            eras = this._eras || getLocale('en')._eras;\n        for (i = 0, l = eras.length; i < l; ++i) {\n            switch (typeof eras[i].since) {\n                case 'string':\n                    // truncate time\n                    date = hooks(eras[i].since).startOf('day');\n                    eras[i].since = date.valueOf();\n                    break;\n            }\n\n            switch (typeof eras[i].until) {\n                case 'undefined':\n                    eras[i].until = +Infinity;\n                    break;\n                case 'string':\n                    // truncate time\n                    date = hooks(eras[i].until).startOf('day').valueOf();\n                    eras[i].until = date.valueOf();\n                    break;\n            }\n        }\n        return eras;\n    }\n\n    function localeErasParse(eraName, format, strict) {\n        var i,\n            l,\n            eras = this.eras(),\n            name,\n            abbr,\n            narrow;\n        eraName = eraName.toUpperCase();\n\n        for (i = 0, l = eras.length; i < l; ++i) {\n            name = eras[i].name.toUpperCase();\n            abbr = eras[i].abbr.toUpperCase();\n            narrow = eras[i].narrow.toUpperCase();\n\n            if (strict) {\n                switch (format) {\n                    case 'N':\n                    case 'NN':\n                    case 'NNN':\n                        if (abbr === eraName) {\n                            return eras[i];\n                        }\n                        break;\n\n                    case 'NNNN':\n                        if (name === eraName) {\n                            return eras[i];\n                        }\n                        break;\n\n                    case 'NNNNN':\n                        if (narrow === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                }\n            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {\n                return eras[i];\n            }\n        }\n    }\n\n    function localeErasConvertYear(era, year) {\n        var dir = era.since <= era.until ? +1 : -1;\n        if (year === undefined) {\n            return hooks(era.since).year();\n        } else {\n            return hooks(era.since).year() + (year - era.offset) * dir;\n        }\n    }\n\n    function getEraName() {\n        var i,\n            l,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].name;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].name;\n            }\n        }\n\n        return '';\n    }\n\n    function getEraNarrow() {\n        var i,\n            l,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].narrow;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].narrow;\n            }\n        }\n\n        return '';\n    }\n\n    function getEraAbbr() {\n        var i,\n            l,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].abbr;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].abbr;\n            }\n        }\n\n        return '';\n    }\n\n    function getEraYear() {\n        var i,\n            l,\n            dir,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            dir = eras[i].since <= eras[i].until ? +1 : -1;\n\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (\n                (eras[i].since <= val && val <= eras[i].until) ||\n                (eras[i].until <= val && val <= eras[i].since)\n            ) {\n                return (\n                    (this.year() - hooks(eras[i].since).year()) * dir +\n                    eras[i].offset\n                );\n            }\n        }\n\n        return this.year();\n    }\n\n    function erasNameRegex(isStrict) {\n        if (!hasOwnProp(this, '_erasNameRegex')) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNameRegex : this._erasRegex;\n    }\n\n    function erasAbbrRegex(isStrict) {\n        if (!hasOwnProp(this, '_erasAbbrRegex')) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasAbbrRegex : this._erasRegex;\n    }\n\n    function erasNarrowRegex(isStrict) {\n        if (!hasOwnProp(this, '_erasNarrowRegex')) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNarrowRegex : this._erasRegex;\n    }\n\n    function matchEraAbbr(isStrict, locale) {\n        return locale.erasAbbrRegex(isStrict);\n    }\n\n    function matchEraName(isStrict, locale) {\n        return locale.erasNameRegex(isStrict);\n    }\n\n    function matchEraNarrow(isStrict, locale) {\n        return locale.erasNarrowRegex(isStrict);\n    }\n\n    function matchEraYearOrdinal(isStrict, locale) {\n        return locale._eraYearOrdinalRegex || matchUnsigned;\n    }\n\n    function computeErasParse() {\n        var abbrPieces = [],\n            namePieces = [],\n            narrowPieces = [],\n            mixedPieces = [],\n            i,\n            l,\n            erasName,\n            erasAbbr,\n            erasNarrow,\n            eras = this.eras();\n\n        for (i = 0, l = eras.length; i < l; ++i) {\n            erasName = regexEscape(eras[i].name);\n            erasAbbr = regexEscape(eras[i].abbr);\n            erasNarrow = regexEscape(eras[i].narrow);\n\n            namePieces.push(erasName);\n            abbrPieces.push(erasAbbr);\n            narrowPieces.push(erasNarrow);\n            mixedPieces.push(erasName);\n            mixedPieces.push(erasAbbr);\n            mixedPieces.push(erasNarrow);\n        }\n\n        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');\n        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');\n        this._erasNarrowRegex = new RegExp(\n            '^(' + narrowPieces.join('|') + ')',\n            'i'\n        );\n    }\n\n    // FORMATTING\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken(token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg', 'weekYear');\n    addWeekYearFormatToken('ggggg', 'weekYear');\n    addWeekYearFormatToken('GGGG', 'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    // PARSING\n\n    addRegexToken('G', matchSigned);\n    addRegexToken('g', matchSigned);\n    addRegexToken('GG', match1to2, match2);\n    addRegexToken('gg', match1to2, match2);\n    addRegexToken('GGGG', match1to4, match4);\n    addRegexToken('gggg', match1to4, match4);\n    addRegexToken('GGGGG', match1to6, match6);\n    addRegexToken('ggggg', match1to6, match6);\n\n    addWeekParseToken(\n        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],\n        function (input, week, config, token) {\n            week[token.substr(0, 2)] = toInt(input);\n        }\n    );\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n    // MOMENTS\n\n    function getSetWeekYear(input) {\n        return getSetWeekYearHelper.call(\n            this,\n            input,\n            this.week(),\n            this.weekday() + this.localeData()._week.dow,\n            this.localeData()._week.dow,\n            this.localeData()._week.doy\n        );\n    }\n\n    function getSetISOWeekYear(input) {\n        return getSetWeekYearHelper.call(\n            this,\n            input,\n            this.isoWeek(),\n            this.isoWeekday(),\n            1,\n            4\n        );\n    }\n\n    function getISOWeeksInYear() {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getISOWeeksInISOWeekYear() {\n        return weeksInYear(this.isoWeekYear(), 1, 4);\n    }\n\n    function getWeeksInYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getWeeksInWeekYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n\n    // FORMATTING\n\n    addFormatToken('Q', 0, 'Qo', 'quarter');\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter(input) {\n        return input == null\n            ? Math.ceil((this.month() + 1) / 3)\n            : this.month((input - 1) * 3 + (this.month() % 3));\n    }\n\n    // FORMATTING\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // PARSING\n\n    addRegexToken('D', match1to2, match1to2NoLeadingZero);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict\n            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse\n            : locale._dayOfMonthOrdinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    // FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // PARSING\n\n    addRegexToken('DDD', match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    // MOMENTS\n\n    function getSetDayOfYear(input) {\n        var dayOfYear =\n            Math.round(\n                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5\n            ) + 1;\n        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // PARSING\n\n    addRegexToken('m', match1to2, match1to2HasZero);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    // FORMATTING\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // PARSING\n\n    addRegexToken('s', match1to2, match1to2HasZero);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    // FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n    // PARSING\n\n    addRegexToken('S', match1to3, match1);\n    addRegexToken('SS', match1to3, match2);\n    addRegexToken('SSS', match1to3, match3);\n\n    var token, getSetMillisecond;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n\n    getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    // FORMATTING\n\n    addFormatToken('z', 0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr() {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName() {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n    proto.add = add;\n    proto.calendar = calendar$1;\n    proto.clone = clone;\n    proto.diff = diff;\n    proto.endOf = endOf;\n    proto.format = format;\n    proto.from = from;\n    proto.fromNow = fromNow;\n    proto.to = to;\n    proto.toNow = toNow;\n    proto.get = stringGet;\n    proto.invalidAt = invalidAt;\n    proto.isAfter = isAfter;\n    proto.isBefore = isBefore;\n    proto.isBetween = isBetween;\n    proto.isSame = isSame;\n    proto.isSameOrAfter = isSameOrAfter;\n    proto.isSameOrBefore = isSameOrBefore;\n    proto.isValid = isValid$2;\n    proto.lang = lang;\n    proto.locale = locale;\n    proto.localeData = localeData;\n    proto.max = prototypeMax;\n    proto.min = prototypeMin;\n    proto.parsingFlags = parsingFlags;\n    proto.set = stringSet;\n    proto.startOf = startOf;\n    proto.subtract = subtract;\n    proto.toArray = toArray;\n    proto.toObject = toObject;\n    proto.toDate = toDate;\n    proto.toISOString = toISOString;\n    proto.inspect = inspect;\n    if (typeof Symbol !== 'undefined' && Symbol.for != null) {\n        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {\n            return 'Moment<' + this.format() + '>';\n        };\n    }\n    proto.toJSON = toJSON;\n    proto.toString = toString;\n    proto.unix = unix;\n    proto.valueOf = valueOf;\n    proto.creationData = creationData;\n    proto.eraName = getEraName;\n    proto.eraNarrow = getEraNarrow;\n    proto.eraAbbr = getEraAbbr;\n    proto.eraYear = getEraYear;\n    proto.year = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week = proto.weeks = getSetWeek;\n    proto.isoWeek = proto.isoWeeks = getSetISOWeek;\n    proto.weeksInYear = getWeeksInYear;\n    proto.weeksInWeekYear = getWeeksInWeekYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;\n    proto.date = getSetDayOfMonth;\n    proto.day = proto.days = getSetDayOfWeek;\n    proto.weekday = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset = getSetOffset;\n    proto.utc = setOffsetToUTC;\n    proto.local = setOffsetToLocal;\n    proto.parseZone = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST = isDaylightSavingTime;\n    proto.isLocal = isLocal;\n    proto.isUtcOffset = isUtcOffset;\n    proto.isUtc = isUtc;\n    proto.isUTC = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates = deprecate(\n        'dates accessor is deprecated. Use date instead.',\n        getSetDayOfMonth\n    );\n    proto.months = deprecate(\n        'months accessor is deprecated. Use month instead',\n        getSetMonth\n    );\n    proto.years = deprecate(\n        'years accessor is deprecated. Use year instead',\n        getSetYear\n    );\n    proto.zone = deprecate(\n        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',\n        getSetZone\n    );\n    proto.isDSTShifted = deprecate(\n        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',\n        isDaylightSavingTimeShifted\n    );\n\n    function createUnix(input) {\n        return createLocal(input * 1000);\n    }\n\n    function createInZone() {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat(string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n    proto$1.calendar = calendar;\n    proto$1.longDateFormat = longDateFormat;\n    proto$1.invalidDate = invalidDate;\n    proto$1.ordinal = ordinal;\n    proto$1.preparse = preParsePostFormat;\n    proto$1.postformat = preParsePostFormat;\n    proto$1.relativeTime = relativeTime;\n    proto$1.pastFuture = pastFuture;\n    proto$1.set = set;\n    proto$1.eras = localeEras;\n    proto$1.erasParse = localeErasParse;\n    proto$1.erasConvertYear = localeErasConvertYear;\n    proto$1.erasAbbrRegex = erasAbbrRegex;\n    proto$1.erasNameRegex = erasNameRegex;\n    proto$1.erasNarrowRegex = erasNarrowRegex;\n\n    proto$1.months = localeMonths;\n    proto$1.monthsShort = localeMonthsShort;\n    proto$1.monthsParse = localeMonthsParse;\n    proto$1.monthsRegex = monthsRegex;\n    proto$1.monthsShortRegex = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n    proto$1.weekdays = localeWeekdays;\n    proto$1.weekdaysMin = localeWeekdaysMin;\n    proto$1.weekdaysShort = localeWeekdaysShort;\n    proto$1.weekdaysParse = localeWeekdaysParse;\n\n    proto$1.weekdaysRegex = weekdaysRegex;\n    proto$1.weekdaysShortRegex = weekdaysShortRegex;\n    proto$1.weekdaysMinRegex = weekdaysMinRegex;\n\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function get$1(format, index, field, setter) {\n        var locale = getLocale(),\n            utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function listMonthsImpl(format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return get$1(format, index, field, 'month');\n        }\n\n        var i,\n            out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format, i, field, 'month');\n        }\n        return out;\n    }\n\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl(localeSorted, format, index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted ? locale._week.dow : 0,\n            i,\n            out = [];\n\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, 'day');\n        }\n\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function listMonths(format, index) {\n        return listMonthsImpl(format, index, 'months');\n    }\n\n    function listMonthsShort(format, index) {\n        return listMonthsImpl(format, index, 'monthsShort');\n    }\n\n    function listWeekdays(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n    }\n\n    function listWeekdaysShort(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function listWeekdaysMin(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        eras: [\n            {\n                since: '0001-01-01',\n                until: +Infinity,\n                offset: 1,\n                name: 'Anno Domini',\n                narrow: 'AD',\n                abbr: 'AD',\n            },\n            {\n                since: '0000-12-31',\n                until: -Infinity,\n                offset: 1,\n                name: 'Before Christ',\n                narrow: 'BC',\n                abbr: 'BC',\n            },\n        ],\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal: function (number) {\n            var b = number % 10,\n                output =\n                    toInt((number % 100) / 10) === 1\n                        ? 'th'\n                        : b === 1\n                          ? 'st'\n                          : b === 2\n                            ? 'nd'\n                            : b === 3\n                              ? 'rd'\n                              : 'th';\n            return number + output;\n        },\n    });\n\n    // Side effect imports\n\n    hooks.lang = deprecate(\n        'moment.lang is deprecated. Use moment.locale instead.',\n        getSetGlobalLocale\n    );\n    hooks.langData = deprecate(\n        'moment.langData is deprecated. Use moment.localeData instead.',\n        getLocale\n    );\n\n    var mathAbs = Math.abs;\n\n    function abs() {\n        var data = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days = mathAbs(this._days);\n        this._months = mathAbs(this._months);\n\n        data.milliseconds = mathAbs(data.milliseconds);\n        data.seconds = mathAbs(data.seconds);\n        data.minutes = mathAbs(data.minutes);\n        data.hours = mathAbs(data.hours);\n        data.months = mathAbs(data.months);\n        data.years = mathAbs(data.years);\n\n        return this;\n    }\n\n    function addSubtract$1(duration, input, value, direction) {\n        var other = createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days += direction * other._days;\n        duration._months += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1(input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1(input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n\n    function absCeil(number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble() {\n        var milliseconds = this._milliseconds,\n            days = this._days,\n            months = this._months,\n            data = this._data,\n            seconds,\n            minutes,\n            hours,\n            years,\n            monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (\n            !(\n                (milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0)\n            )\n        ) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds = absFloor(milliseconds / 1000);\n        data.seconds = seconds % 60;\n\n        minutes = absFloor(seconds / 60);\n        data.minutes = minutes % 60;\n\n        hours = absFloor(minutes / 60);\n        data.hours = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days = days;\n        data.months = months;\n        data.years = years;\n\n        return this;\n    }\n\n    function daysToMonths(days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return (days * 4800) / 146097;\n    }\n\n    function monthsToDays(months) {\n        // the reverse of daysToMonths\n        return (months * 146097) / 4800;\n    }\n\n    function as(units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days,\n            months,\n            milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'quarter' || units === 'year') {\n            days = this._days + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            switch (units) {\n                case 'month':\n                    return months;\n                case 'quarter':\n                    return months / 3;\n                case 'year':\n                    return months / 12;\n            }\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week':\n                    return days / 7 + milliseconds / 6048e5;\n                case 'day':\n                    return days + milliseconds / 864e5;\n                case 'hour':\n                    return days * 24 + milliseconds / 36e5;\n                case 'minute':\n                    return days * 1440 + milliseconds / 6e4;\n                case 'second':\n                    return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond':\n                    return Math.floor(days * 864e5) + milliseconds;\n                default:\n                    throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    function makeAs(alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms'),\n        asSeconds = makeAs('s'),\n        asMinutes = makeAs('m'),\n        asHours = makeAs('h'),\n        asDays = makeAs('d'),\n        asWeeks = makeAs('w'),\n        asMonths = makeAs('M'),\n        asQuarters = makeAs('Q'),\n        asYears = makeAs('y'),\n        valueOf$1 = asMilliseconds;\n\n    function clone$1() {\n        return createDuration(this);\n    }\n\n    function get$2(units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds'),\n        seconds = makeGetter('seconds'),\n        minutes = makeGetter('minutes'),\n        hours = makeGetter('hours'),\n        days = makeGetter('days'),\n        months = makeGetter('months'),\n        years = makeGetter('years');\n\n    function weeks() {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round,\n        thresholds = {\n            ss: 44, // a few seconds to seconds\n            s: 45, // seconds to minute\n            m: 45, // minutes to hour\n            h: 22, // hours to day\n            d: 26, // days to month/week\n            w: null, // weeks to month\n            M: 11, // months to year\n        };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {\n        var duration = createDuration(posNegDuration).abs(),\n            seconds = round(duration.as('s')),\n            minutes = round(duration.as('m')),\n            hours = round(duration.as('h')),\n            days = round(duration.as('d')),\n            months = round(duration.as('M')),\n            weeks = round(duration.as('w')),\n            years = round(duration.as('y')),\n            a =\n                (seconds <= thresholds.ss && ['s', seconds]) ||\n                (seconds < thresholds.s && ['ss', seconds]) ||\n                (minutes <= 1 && ['m']) ||\n                (minutes < thresholds.m && ['mm', minutes]) ||\n                (hours <= 1 && ['h']) ||\n                (hours < thresholds.h && ['hh', hours]) ||\n                (days <= 1 && ['d']) ||\n                (days < thresholds.d && ['dd', days]);\n\n        if (thresholds.w != null) {\n            a =\n                a ||\n                (weeks <= 1 && ['w']) ||\n                (weeks < thresholds.w && ['ww', weeks]);\n        }\n        a = a ||\n            (months <= 1 && ['M']) ||\n            (months < thresholds.M && ['MM', months]) ||\n            (years <= 1 && ['y']) || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding(roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof roundingFunction === 'function') {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold(threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === 's') {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n    function humanize(argWithSuffix, argThresholds) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var withSuffix = false,\n            th = thresholds,\n            locale,\n            output;\n\n        if (typeof argWithSuffix === 'object') {\n            argThresholds = argWithSuffix;\n            argWithSuffix = false;\n        }\n        if (typeof argWithSuffix === 'boolean') {\n            withSuffix = argWithSuffix;\n        }\n        if (typeof argThresholds === 'object') {\n            th = Object.assign({}, thresholds, argThresholds);\n            if (argThresholds.s != null && argThresholds.ss == null) {\n                th.ss = argThresholds.s - 1;\n            }\n        }\n\n        locale = this.localeData();\n        output = relativeTime$1(this, !withSuffix, th, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n    function sign(x) {\n        return (x > 0) - (x < 0) || +x;\n    }\n\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds) / 1000,\n            days = abs$1(this._days),\n            months = abs$1(this._months),\n            minutes,\n            hours,\n            years,\n            s,\n            total = this.asSeconds(),\n            totalSign,\n            ymSign,\n            daysSign,\n            hmsSign;\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes = absFloor(seconds / 60);\n        hours = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n\n        totalSign = total < 0 ? '-' : '';\n        ymSign = sign(this._months) !== sign(total) ? '-' : '';\n        daysSign = sign(this._days) !== sign(total) ? '-' : '';\n        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n        return (\n            totalSign +\n            'P' +\n            (years ? ymSign + years + 'Y' : '') +\n            (months ? ymSign + months + 'M' : '') +\n            (days ? daysSign + days + 'D' : '') +\n            (hours || minutes || seconds ? 'T' : '') +\n            (hours ? hmsSign + hours + 'H' : '') +\n            (minutes ? hmsSign + minutes + 'M' : '') +\n            (seconds ? hmsSign + s + 'S' : '')\n        );\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid = isValid$1;\n    proto$2.abs = abs;\n    proto$2.add = add$1;\n    proto$2.subtract = subtract$1;\n    proto$2.as = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds = asSeconds;\n    proto$2.asMinutes = asMinutes;\n    proto$2.asHours = asHours;\n    proto$2.asDays = asDays;\n    proto$2.asWeeks = asWeeks;\n    proto$2.asMonths = asMonths;\n    proto$2.asQuarters = asQuarters;\n    proto$2.asYears = asYears;\n    proto$2.valueOf = valueOf$1;\n    proto$2._bubble = bubble;\n    proto$2.clone = clone$1;\n    proto$2.get = get$2;\n    proto$2.milliseconds = milliseconds;\n    proto$2.seconds = seconds;\n    proto$2.minutes = minutes;\n    proto$2.hours = hours;\n    proto$2.days = days;\n    proto$2.weeks = weeks;\n    proto$2.months = months;\n    proto$2.years = years;\n    proto$2.humanize = humanize;\n    proto$2.toISOString = toISOString$1;\n    proto$2.toString = toISOString$1;\n    proto$2.toJSON = toISOString$1;\n    proto$2.locale = locale;\n    proto$2.localeData = localeData;\n\n    proto$2.toIsoString = deprecate(\n        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',\n        toISOString$1\n    );\n    proto$2.lang = lang;\n\n    // FORMATTING\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    //! moment.js\n\n    hooks.version = '2.30.1';\n\n    setHookCallback(createLocal);\n\n    hooks.fn = proto;\n    hooks.min = min;\n    hooks.max = max;\n    hooks.now = now;\n    hooks.utc = createUTC;\n    hooks.unix = createUnix;\n    hooks.months = listMonths;\n    hooks.isDate = isDate;\n    hooks.locale = getSetGlobalLocale;\n    hooks.invalid = createInvalid;\n    hooks.duration = createDuration;\n    hooks.isMoment = isMoment;\n    hooks.weekdays = listWeekdays;\n    hooks.parseZone = createInZone;\n    hooks.localeData = getLocale;\n    hooks.isDuration = isDuration;\n    hooks.monthsShort = listMonthsShort;\n    hooks.weekdaysMin = listWeekdaysMin;\n    hooks.defineLocale = defineLocale;\n    hooks.updateLocale = updateLocale;\n    hooks.locales = listLocales;\n    hooks.weekdaysShort = listWeekdaysShort;\n    hooks.normalizeUnits = normalizeUnits;\n    hooks.relativeTimeRounding = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat = getCalendarFormat;\n    hooks.prototype = proto;\n\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type=\"datetime-local\" step=\"1\" />\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type=\"datetime-local\" step=\"0.001\" />\n        DATE: 'YYYY-MM-DD', // <input type=\"date\" />\n        TIME: 'HH:mm', // <input type=\"time\" />\n        TIME_SECONDS: 'HH:mm:ss', // <input type=\"time\" step=\"1\" />\n        TIME_MS: 'HH:mm:ss.SSS', // <input type=\"time\" step=\"0.001\" />\n        WEEK: 'GGGG-[W]WW', // <input type=\"week\" />\n        MONTH: 'YYYY-MM', // <input type=\"month\" />\n    };\n\n    return hooks;\n\n})));\n\n\n//# sourceURL=webpack://prom1009/./node_modules/moment/moment.js?\n}");

/***/ }),

/***/ "./node_modules/ractive/ractive.mjs":
/*!******************************************!*\
  !*** ./node_modules/ractive/ractive.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n\tRactive.js v1.4.4\n\tBuild: 3aeff251497ddb0b9da991576c91e05d37884fc9\n\tDate: Wed May 22 2024 01:58:39 GMT-0400 (Eastern Daylight Time)\n\tWebsite: https://ractive.js.org\n\tLicense: MIT\n*/\n/* istanbul ignore if */\nif (!Object.assign) {\n  Object.assign = function(target) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    if (target == null) { throw new TypeError('Cannot convert undefined or null to object'); }\n\n    var to = Object(target);\n    var sourcesLength = sources.length;\n\n    for (var index = 0; index < sourcesLength; index++) {\n      var nextSource = sources[index];\n      for (var nextKey in nextSource) {\n        if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) { continue; }\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n\n    return to;\n  };\n}\n\nfunction hasOwn(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction fillGaps(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0; i < sources.length; i++) {\n    var source = sources[i];\n    for (var key in source) {\n      // Source can be a prototype-less object.\n      if (key in target || !hasOwn(source, key)) { continue; }\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction toPairs(obj) {\n  if ( obj === void 0 ) obj = {};\n\n  var pairs = [];\n  for (var key in obj) {\n    // Source can be a prototype-less object.\n    if (!hasOwn(obj, key)) { continue; }\n    pairs.push([key, obj[key]]);\n  }\n  return pairs;\n}\n\nvar obj = Object;\n\nvar assign = obj.assign;\n\nvar create = obj.create;\n\nvar defineProperty = obj.defineProperty;\n\nvar defineProperties = obj.defineProperties;\n\nvar keys = obj.keys;\n\nvar toString = Object.prototype.toString;\n\n\nvar isArray = Array.isArray;\n\nfunction isEqual(a, b) {\n  if (a === null && b === null) {\n    return true;\n  }\n\n  if (isObjectType(a) || isObjectType(b)) {\n    return false;\n  }\n\n  return a === b;\n}\n\n// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\nfunction isNumeric(thing) {\n  return !isNaN(parseFloat(thing)) && isFinite(thing);\n}\n\nfunction isObject(thing) {\n  return thing && toString.call(thing) === '[object Object]';\n}\n\nfunction isObjectLike(thing) {\n  return !!(thing && (isObjectType(thing) || isFunction(thing))) && !isDate(thing);\n}\n\nfunction isDate(thing) {\n  return thing instanceof Date;\n}\n\nfunction isObjectType(thing) {\n  return typeof thing === 'object';\n}\n\nfunction isFunction(thing) {\n  return typeof thing === 'function';\n}\n\nfunction isString(thing) {\n  return typeof thing === 'string';\n}\n\nfunction isNumber(thing) {\n  return typeof thing === 'number';\n}\n\nfunction isUndefined(thing) {\n  return thing === undefined;\n}\n\n/* istanbul ignore if */\nif (!Array.prototype.find) {\n  defineProperty(Array.prototype, 'find', {\n    value: function value(callback, thisArg) {\n      if (this === null || isUndefined(this))\n        { throw new TypeError('Array.prototype.find called on null or undefined'); }\n\n      if (!isFunction(callback)) { throw new TypeError((callback + \" is not a function\")); }\n\n      var array = Object(this);\n      var arrayLength = array.length >>> 0;\n\n      for (var index = 0; index < arrayLength; index++) {\n        if (!hasOwn(array, index)) { continue; }\n        if (!callback.call(thisArg, array[index], index, array)) { continue; }\n        return array[index];\n      }\n\n      return undefined;\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\n// NOTE: Node doesn't exist in IE8. Nothing can be done.\n/* istanbul ignore if */\nif (\n  typeof window !== 'undefined' &&\n  window.Node &&\n  window.Node.prototype &&\n  !window.Node.prototype.contains\n) {\n  Node.prototype.contains = function(node) {\n    var this$1 = this;\n\n    if (!node) { throw new TypeError('node required'); }\n\n    do {\n      if (this$1 === node) { return true; }\n    } while ((node = node && node.parentNode));\n\n    return false;\n  };\n}\n\n/* istanbul ignore if */\nif (typeof window !== 'undefined' && window.performance && !window.performance.now) {\n  window.performance = window.performance || {};\n\n  var nowOffset = Date.now();\n\n  window.performance.now = function() {\n    return Date.now() - nowOffset;\n  };\n}\n\n/* eslint no-console:\"off\" */\nvar win = typeof window !== 'undefined' ? window : null;\nvar doc = win ? document : null;\nvar isClient = !!doc;\nvar base = typeof global !== 'undefined' ? global : win;\nvar hasConsole =\n  typeof console !== 'undefined' && isFunction(console.warn) && isFunction(console.warn.apply);\n\nvar svg = doc\n  ? doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')\n  : false;\n\nvar vendors = ['o', 'ms', 'moz', 'webkit'];\n\n/* istanbul ignore if */\nif (!base.Promise) {\n  var PENDING = {};\n  var FULFILLED = {};\n  var REJECTED = {};\n\n  var Promise$1 = (base.Promise = function(callback) {\n    var fulfilledHandlers = [];\n    var rejectedHandlers = [];\n    var state = PENDING;\n    var result;\n    var dispatchHandlers;\n\n    var makeResolver = function (newState) {\n      return function(value) {\n        if (state !== PENDING) { return; }\n        result = value;\n        state = newState;\n        dispatchHandlers = makeDispatcher(\n          state === FULFILLED ? fulfilledHandlers : rejectedHandlers,\n          result\n        );\n        wait(dispatchHandlers);\n      };\n    };\n\n    var fulfill = makeResolver(FULFILLED);\n    var reject = makeResolver(REJECTED);\n\n    try {\n      callback(fulfill, reject);\n    } catch (err) {\n      reject(err);\n    }\n\n    return {\n      // `then()` returns a Promise - 2.2.7\n      then: function then(onFulfilled, onRejected) {\n        var promise2 = new Promise$1(function (fulfill, reject) {\n          var processResolutionHandler = function (handler, handlers, forward) {\n            if (isFunction(handler)) {\n              handlers.push(function (p1result) {\n                try {\n                  resolve$1(promise2, handler(p1result), fulfill, reject);\n                } catch (err) {\n                  reject(err);\n                }\n              });\n            } else {\n              handlers.push(forward);\n            }\n          };\n\n          processResolutionHandler(onFulfilled, fulfilledHandlers, fulfill);\n          processResolutionHandler(onRejected, rejectedHandlers, reject);\n\n          if (state !== PENDING) {\n            wait(dispatchHandlers);\n          }\n        });\n        return promise2;\n      },\n      catch: function catch$1(onRejected) {\n        return this.then(null, onRejected);\n      },\n      finally: function finally$1(callback) {\n        return this.then(\n          function (v) {\n            callback();\n            return v;\n          },\n          function (e) {\n            callback();\n            throw e;\n          }\n        );\n      }\n    };\n  });\n\n  Promise$1.all = function(promises) {\n    return new Promise$1(function (fulfill, reject) {\n      var result = [];\n      var pending;\n      var i;\n\n      if (!promises.length) {\n        fulfill(result);\n        return;\n      }\n\n      var processPromise = function (promise, i) {\n        if (promise && isFunction(promise.then)) {\n          promise.then(function (value) {\n            result[i] = value;\n            --pending || fulfill(result);\n          }, reject);\n        } else {\n          result[i] = promise;\n          --pending || fulfill(result);\n        }\n      };\n\n      pending = i = promises.length;\n\n      while (i--) {\n        processPromise(promises[i], i);\n      }\n    });\n  };\n\n  Promise$1.race = function(promises) {\n    return new Promise$1(function (fulfill, reject) {\n      var pending = true;\n      function ok(v) {\n        if (!pending) { return; }\n        pending = false;\n        fulfill(v);\n      }\n      function fail(e) {\n        if (!pending) { return; }\n        pending = false;\n        reject(e);\n      }\n      for (var i = 0; i < promises.length; i++) {\n        if (promises[i] && isFunction(promises[i].then)) {\n          promises[i].then(ok, fail);\n        }\n      }\n    });\n  };\n\n  Promise$1.resolve = function(value) {\n    if (value && isFunction(value.then)) { return value; }\n    return new Promise$1(function (fulfill) {\n      fulfill(value);\n    });\n  };\n\n  Promise$1.reject = function(reason) {\n    if (reason && isFunction(reason.then)) { return reason; }\n    return new Promise$1(function (fulfill, reject) {\n      reject(reason);\n    });\n  };\n\n  // TODO use MutationObservers or something to simulate setImmediate\n  var wait = function(callback) {\n    setTimeout(callback, 0);\n  };\n\n  var makeDispatcher = function(handlers, result) {\n    return function() {\n      for (var handler = (void 0); (handler = handlers.shift()); ) {\n        handler(result);\n      }\n    };\n  };\n\n  var resolve$1 = function(promise, x, fulfil, reject) {\n    var then;\n    if (x === promise) {\n      throw new TypeError(\"A promise's fulfillment handler cannot return the same promise\");\n    }\n    if (x instanceof Promise$1) {\n      x.then(fulfil, reject);\n    } else if (x && (isObjectType(x) || isFunction(x))) {\n      try {\n        then = x.then;\n      } catch (e) {\n        reject(e);\n        return;\n      }\n      if (isFunction(then)) {\n        var called;\n\n        var resolvePromise = function(y) {\n          if (called) { return; }\n          called = true;\n          resolve$1(promise, y, fulfil, reject);\n        };\n        var rejectPromise = function(r) {\n          if (called) { return; }\n          called = true;\n          reject(r);\n        };\n\n        try {\n          then.call(x, resolvePromise, rejectPromise);\n        } catch (e) {\n          if (!called) {\n            reject(e);\n            called = true;\n            return;\n          }\n        }\n      } else {\n        fulfil(x);\n      }\n    } else {\n      fulfil(x);\n    }\n  };\n}\n\n/* istanbul ignore if */\nif (\n  typeof window !== 'undefined' &&\n  !(window.requestAnimationFrame && window.cancelAnimationFrame)\n) {\n  var lastTime = 0;\n  window.requestAnimationFrame = function(callback) {\n    var currentTime = Date.now();\n    var timeToNextCall = Math.max(0, 16 - (currentTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currentTime + timeToNextCall);\n    }, timeToNextCall);\n    lastTime = currentTime + timeToNextCall;\n    return id;\n  };\n  window.cancelAnimationFrame = function(id) {\n    clearTimeout(id);\n  };\n}\n\nvar defaults = {\n  // render placement:\n  el: void 0,\n  append: false,\n  delegate: true,\n  enhance: false,\n\n  // template:\n  template: null,\n\n  // parse:\n  allowExpressions: true,\n  delimiters: ['{{', '}}'],\n  tripleDelimiters: ['{{{', '}}}'],\n  staticDelimiters: ['[[', ']]'],\n  staticTripleDelimiters: ['[[[', ']]]'],\n  csp: true,\n  interpolate: false,\n  preserveWhitespace: false,\n  preserveStandaloneSections: false,\n  sanitize: false,\n  stripComments: true,\n  contextLines: 0,\n\n  // data & binding:\n  data: create(null),\n  helpers: create(null),\n  computed: create(null),\n  syncComputedChildren: false,\n  resolveInstanceMembers: false,\n  warnAboutAmbiguity: false,\n  adapt: [],\n  isolated: true,\n  twoway: true,\n  lazy: false,\n\n  // transitions:\n  noIntro: false,\n  noOutro: false,\n  transitionsEnabled: true,\n  complete: void 0,\n  nestedTransitions: true,\n\n  // css:\n  css: null,\n  noCSSTransform: false\n};\n\n// These are a subset of the easing equations found at\n// https://raw.github.com/danro/easing-js - license info\n// follows:\n\n// --------------------------------------------------\n// easing.js v0.5.4\n// Generic set of easing functions with AMD support\n// https://github.com/danro/easing-js\n// This code may be freely distributed under the MIT license\n// http://danro.mit-license.org/\n// --------------------------------------------------\n// All functions adapted from Thomas Fuchs & Jeremy Kahn\n// Easing Equations (c) 2003 Robert Penner, BSD license\n// https://raw.github.com/danro/easing-js/master/LICENSE\n// --------------------------------------------------\n\n// In that library, the functions named easeIn, easeOut, and\n// easeInOut below are named easeInCubic, easeOutCubic, and\n// (you guessed it) easeInOutCubic.\n//\n// You can add additional easing functions to this list, and they\n// will be globally available.\n\nvar easing = {\n  linear: function linear(pos) {\n    return pos;\n  },\n  easeIn: function easeIn(pos) {\n    /* istanbul ignore next */\n    return Math.pow(pos, 3);\n  },\n  easeOut: function easeOut(pos) {\n    return Math.pow(pos - 1, 3) + 1;\n  },\n  easeInOut: function easeInOut(pos) {\n    /* istanbul ignore next */\n    if ((pos /= 0.5) < 1) {\n      return 0.5 * Math.pow(pos, 3);\n    }\n    /* istanbul ignore next */\n    return 0.5 * (Math.pow(pos - 2, 3) + 2);\n  }\n};\n\nfunction noop() {}\n\n/* global console */\n/* eslint no-console:\"off\" */\n\nvar alreadyWarned = {};\nvar log;\nvar printWarning;\nvar welcome;\n\nif (hasConsole) {\n  var welcomeIntro = [\n    \"%cRactive.js %c1.4.4 %cin debug mode, %cmore...\",\n    'color: rgb(114, 157, 52); font-weight: normal;',\n    'color: rgb(85, 85, 85); font-weight: normal;',\n    'color: rgb(85, 85, 85); font-weight: normal;',\n    'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'\n  ];\n  var welcomeMessage = \"You're running Ractive 1.4.4 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://ractive.js.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\n  welcome = function () {\n    if (Ractive.WELCOME_MESSAGE === false) {\n      welcome = noop;\n      return;\n    }\n    var message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;\n    var hasGroup = !!console.groupCollapsed;\n    if (hasGroup) { console.groupCollapsed.apply(console, welcomeIntro); }\n    console.log(message);\n    if (hasGroup) {\n      console.groupEnd(welcomeIntro);\n    }\n\n    welcome = noop;\n  };\n\n  printWarning = function (message, args) {\n    welcome();\n\n    // extract information about the instance this message pertains to, if applicable\n    if (isObjectType(args[args.length - 1])) {\n      var options = args.pop();\n      var ractive = options ? options.ractive : null;\n\n      if (ractive) {\n        // if this is an instance of a component that we know the name of, add\n        // it to the message\n        var name;\n        if (ractive.component && (name = ractive.component.name)) {\n          message = \"<\" + name + \"> \" + message;\n        }\n\n        var node;\n        if (\n          (node =\n            options.node || (ractive.fragment && ractive.fragment.rendered && ractive.find('*')))\n        ) {\n          args.push(node);\n        }\n      }\n    }\n\n    console.warn.apply(\n      console,\n      ['%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);'].concat(\n        args\n      )\n    );\n  };\n\n  log = function() {\n    console.log.apply(console, arguments);\n  };\n} else {\n  printWarning = log = welcome = noop;\n}\n\nfunction format(message, args) {\n  return message.replace(/%s/g, function () { return args.shift(); });\n}\n\nfunction fatal(message) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  message = format(message, args);\n  throw new Error(message);\n}\n\nfunction logIfDebug() {\n  if (Ractive.DEBUG) {\n    log.apply(null, arguments);\n  }\n}\n\nfunction warn(message) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  message = format(message, args);\n  printWarning(message, args);\n}\n\nfunction warnOnce(message) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  message = format(message, args);\n\n  if (alreadyWarned[message]) {\n    return;\n  }\n\n  alreadyWarned[message] = true;\n  printWarning(message, args);\n}\n\nfunction warnIfDebug() {\n  if (Ractive.DEBUG) {\n    warn.apply(null, arguments);\n  }\n}\n\nfunction warnOnceIfDebug() {\n  if (Ractive.DEBUG) {\n    warnOnce.apply(null, arguments);\n  }\n}\n\n// Error messages that are used (or could be) in multiple places\nvar badArguments = 'Bad arguments';\nvar noRegistryFunctionReturn =\n  'A function was specified for \"%s\" %s, but no %s was returned';\nvar missingPlugin = function (name, type) { return (\"Missing \\\"\" + name + \"\\\" \" + type + \" plugin. You may need to download a plugin via http://ractive.js.org/integrations/#\" + type + \"s\"); };\n\nfunction findInViewHierarchy(registryName, ractive, name) {\n  var instance = findInstance(registryName, ractive, name);\n  return instance ? instance[registryName][name] : null;\n}\n\nfunction findInstance(registryName, ractive, name) {\n  while (ractive) {\n    if (name in ractive[registryName]) {\n      return ractive;\n    }\n\n    if (ractive.isolated) {\n      return null;\n    }\n\n    ractive = ractive.parent;\n  }\n}\n\nfunction interpolate(from, to, ractive, type) {\n  if (from === to) { return null; }\n\n  if (type) {\n    var interpol = findInViewHierarchy('interpolators', ractive, type);\n    if (interpol) { return interpol(from, to) || null; }\n\n    fatal(missingPlugin(type, 'interpolator'));\n  }\n\n  return (\n    interpolators.number(from, to) ||\n    interpolators.array(from, to) ||\n    interpolators.object(from, to) ||\n    null\n  );\n}\n\nvar interpolators = {\n  number: function number(from, to) {\n    if (!isNumeric(from) || !isNumeric(to)) {\n      return null;\n    }\n\n    from = +from;\n    to = +to;\n\n    var delta = to - from;\n\n    if (!delta) {\n      return function() {\n        return from;\n      };\n    }\n\n    return function(t) {\n      return from + t * delta;\n    };\n  },\n\n  array: function array(from, to) {\n    var len, i;\n\n    if (!isArray(from) || !isArray(to)) {\n      return null;\n    }\n\n    var intermediate = [];\n    var interpolators = [];\n\n    i = len = Math.min(from.length, to.length);\n    while (i--) {\n      interpolators[i] = interpolate(from[i], to[i]);\n    }\n\n    // surplus values - don't interpolate, but don't exclude them either\n    for (i = len; i < from.length; i += 1) {\n      intermediate[i] = from[i];\n    }\n\n    for (i = len; i < to.length; i += 1) {\n      intermediate[i] = to[i];\n    }\n\n    return function(t) {\n      var i = len;\n\n      while (i--) {\n        intermediate[i] = interpolators[i](t);\n      }\n\n      return intermediate;\n    };\n  },\n\n  object: function object(from, to) {\n    if (!isObject(from) || !isObject(to)) {\n      return null;\n    }\n\n    var properties = [];\n    var intermediate = {};\n    var interpolators = {};\n\n    var loop = function ( prop ) {\n      if (hasOwn(from, prop)) {\n        if (hasOwn(to, prop)) {\n          properties.push(prop);\n          interpolators[prop] = interpolate(from[prop], to[prop]) || (function () { return to[prop]; });\n        } else {\n          intermediate[prop] = from[prop];\n        }\n      }\n    };\n\n    for (var prop in from) loop( prop );\n\n    for (var prop$1 in to) {\n      if (hasOwn(to, prop$1) && !hasOwn(from, prop$1)) {\n        intermediate[prop$1] = to[prop$1];\n      }\n    }\n\n    var len = properties.length;\n\n    return function(t) {\n      var i = len;\n\n      while (i--) {\n        var prop = properties[i];\n\n        intermediate[prop] = interpolators[prop](t);\n      }\n\n      return intermediate;\n    };\n  }\n};\n\nvar refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\nvar splitPattern = /([^\\\\](?:\\\\\\\\)*)\\./;\nvar escapeKeyPattern = /\\\\|\\./g;\nvar unescapeKeyPattern = /((?:\\\\)+)\\1|\\\\(\\.)/g;\n\nfunction escapeKey(key) {\n  if (isString(key)) {\n    return key.replace(escapeKeyPattern, '\\\\$&');\n  }\n\n  return key;\n}\n\nfunction normalise(ref) {\n  return ref ? ref.replace(refPattern, '.$1') : '';\n}\n\nfunction splitKeypath(keypath) {\n  var result = [];\n  var match;\n\n  keypath = normalise(keypath);\n\n  while ((match = splitPattern.exec(keypath))) {\n    var index = match.index + match[1].length;\n    result.push(keypath.substr(0, index));\n    keypath = keypath.substr(index + 1);\n  }\n\n  result.push(keypath);\n\n  return result;\n}\n\nfunction unescapeKey(key) {\n  if (isString(key)) {\n    return key.replace(unescapeKeyPattern, '$1$2');\n  }\n\n  return key;\n}\n\nfunction addToArray(array, value) {\n  var index = array.indexOf(value);\n\n  if (index === -1) {\n    array.push(value);\n  }\n}\n\nfunction arrayContains(array, value) {\n  for (var i = 0, c = array.length; i < c; i++) {\n    if (array[i] == value) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction arrayContentsMatch(a, b) {\n  var i;\n\n  if (!isArray(a) || !isArray(b)) {\n    return false;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  i = a.length;\n  while (i--) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction ensureArray(x) {\n  if (isString(x)) {\n    return [x];\n  }\n\n  if (isUndefined(x)) {\n    return [];\n  }\n\n  return x;\n}\n\nfunction lastItem(array) {\n  return array[array.length - 1];\n}\n\nfunction removeFromArray(array, member) {\n  if (!array) {\n    return;\n  }\n\n  var index = array.indexOf(member);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nfunction combine() {\n  var arrays = [], len = arguments.length;\n  while ( len-- ) arrays[ len ] = arguments[ len ];\n\n  var res = arrays.concat.apply([], arrays);\n  var i = res.length;\n  while (i--) {\n    var idx = res.indexOf(res[i]);\n    if (~idx && idx < i) { res.splice(i, 1); }\n  }\n\n  return res;\n}\n\nfunction toArray(arrayLike) {\n  var array = [];\n  var i = arrayLike.length;\n  while (i--) {\n    array[i] = arrayLike[i];\n  }\n\n  return array;\n}\n\nfunction findMap(array, fn) {\n  var len = array.length;\n  for (var i = 0; i < len; i++) {\n    var result = fn(array[i]);\n    if (result) { return result; }\n  }\n}\n\nfunction buildNewIndices(one, two, comparator) {\n  var oldArray = one;\n  var newArray = two;\n  if (comparator) {\n    oldArray = oldArray.map(comparator);\n    newArray = newArray.map(comparator);\n  }\n\n  var oldLength = oldArray.length;\n\n  var usedIndices = {};\n  var firstUnusedIndex = 0;\n\n  var result = oldArray.map(function (item) {\n    var index;\n    var start = firstUnusedIndex;\n\n    do {\n      index = newArray.indexOf(item, start);\n\n      if (index === -1) {\n        return -1;\n      }\n\n      start = index + 1;\n    } while (usedIndices[index] === true && start < oldLength);\n\n    // keep track of the first unused index, so we don't search\n    // the whole of newArray for each item in oldArray unnecessarily\n    if (index === firstUnusedIndex) {\n      firstUnusedIndex += 1;\n    }\n    // allow next instance of next \"equal\" to be found item\n    usedIndices[index] = true;\n    return index;\n  });\n\n  var len = (result.oldLen = oldArray.length);\n  result.newLen = newArray.length;\n\n  if (len === result.newLen) {\n    var i = 0;\n    for (i; i < len; i++) {\n      if (result[i] !== i) { break; }\n    }\n\n    if (i === len) { result.same = true; }\n  }\n\n  return result;\n}\n\nvar fnBind = Function.prototype.bind;\n\nfunction bind(fn, context) {\n  if (!/this/.test(fn.toString())) { return fn; }\n\n  var bound = fnBind.call(fn, context);\n  for (var prop in fn) { bound[prop] = fn[prop]; }\n\n  return bound;\n}\n\nvar shuffleTasks = { early: [], mark: [] };\nvar registerQueue = { early: [], mark: [] };\nvar noVirtual = { virtual: false };\n\nvar ModelBase = function ModelBase(parent) {\n  this.deps = [];\n\n  this.children = [];\n  this.childByKey = {};\n  this.links = [];\n\n  this.bindings = [];\n\n  if (parent) {\n    this.parent = parent;\n    this.root = parent.root;\n  }\n};\nvar ModelBase__proto__ = ModelBase.prototype;\n\nModelBase__proto__.addShuffleTask = function addShuffleTask (task, stage) {\n    if ( stage === void 0 ) stage = 'early';\n\n  shuffleTasks[stage].push(task);\n};\nModelBase__proto__.addShuffleRegister = function addShuffleRegister (item, stage) {\n    if ( stage === void 0 ) stage = 'early';\n\n  registerQueue[stage].push({ model: this, item: item });\n};\n\nModelBase__proto__.downstreamChanged = function downstreamChanged () {};\n\nModelBase__proto__.findMatches = function findMatches (keys$$1) {\n  var len = keys$$1.length;\n\n  var existingMatches = [this];\n  var matches;\n  var i;\n\n  var loop = function (  ) {\n    var key = keys$$1[i];\n\n    if (key === '*') {\n      matches = [];\n      existingMatches.forEach(function (model) {\n        matches.push.apply(matches, model.getValueChildren(model.get()));\n      });\n    } else {\n      matches = existingMatches.map(function (model) { return model.joinKey(key); });\n    }\n\n    existingMatches = matches;\n  };\n\n    for (i = 0; i < len; i += 1) loop(  );\n\n  return matches;\n};\n\nModelBase__proto__.getKeypath = function getKeypath (ractive) {\n  if (ractive !== this.ractive && this._link) { return this._link.target.getKeypath(ractive); }\n\n  if (!this.keypath) {\n    var parent = this.parent && this.parent.getKeypath(ractive);\n    this.keypath = parent\n      ? ((this.parent.getKeypath(ractive)) + \".\" + (escapeKey(this.key)))\n      : escapeKey(this.key);\n  }\n\n  return this.keypath;\n};\n\nModelBase__proto__.getValueChildren = function getValueChildren (value) {\n    var this$1 = this;\n\n  var children;\n  if (isArray(value)) {\n    children = [];\n    if ('length' in this && this.length !== value.length) {\n      children.push(this.joinKey('length'));\n    }\n    value.forEach(function (m, i) {\n      children.push(this$1.joinKey(i));\n    });\n  } else if (isObject(value) || isFunction(value)) {\n    children = keys(value).map(function (key) { return this$1.joinKey(escapeKey(key)); });\n  } else if (value != null) {\n    children = [];\n  }\n\n  var computed = this.computed;\n  if (computed) {\n    children.push.apply(children, keys(computed).map(function (k) { return this$1.joinKey(k); }));\n  }\n\n  return children;\n};\n\nModelBase__proto__.getVirtual = function getVirtual (shouldCapture) {\n    var this$1 = this;\n\n  var value = this.get(shouldCapture, { virtual: false });\n  if (isObjectLike(value)) {\n    var result = isArray(value) ? [] : create(null);\n\n    var keys$$1 = keys(value);\n    var i = keys$$1.length;\n    while (i--) {\n      var child = this$1.childByKey[keys$$1[i]];\n      if (!child) { result[keys$$1[i]] = value[keys$$1[i]]; }\n      else if (child._link) { result[keys$$1[i]] = child._link.getVirtual(); }\n      else { result[keys$$1[i]] = child.getVirtual(); }\n    }\n\n    i = this.children.length;\n    while (i--) {\n      var child$1 = this$1.children[i];\n      if (!(child$1.key in result) && child$1._link) {\n        result[child$1.key] = child$1._link.getVirtual();\n      }\n    }\n\n    if (this.computed) {\n      keys$$1 = keys(this.computed);\n      i = keys$$1.length;\n      while (i--) {\n        result[keys$$1[i]] = this$1.computed[keys$$1[i]].get();\n      }\n    }\n\n    return result;\n  } else { return value; }\n};\n\nModelBase__proto__.has = function has (key) {\n    var this$1 = this;\n\n  if (this._link) { return this._link.has(key); }\n\n  var value = this.get(false, noVirtual);\n  if (!value) { return false; }\n\n  key = unescapeKey(key);\n  if ((isFunction(value) || isObject(value)) && key in value) { return true; }\n\n  var computed = this.computed;\n  if (computed && key in this.computed) { return true; }\n\n  computed = this.root.ractive && this.root.ractive.computed;\n  if (computed) {\n    keys(computed).forEach(function (k) {\n      if (computed[k].pattern && computed[k].pattern.test(this$1.getKeypath())) { return true; }\n    });\n  }\n\n  return false;\n};\n\nModelBase__proto__.joinAll = function joinAll (keys$$1, opts) {\n  var model = this;\n  for (var i = 0; i < keys$$1.length; i += 1) {\n    if (\n      opts &&\n      opts.lastLink === false &&\n      i + 1 === keys$$1.length &&\n      model.childByKey[keys$$1[i]] &&\n      model.childByKey[keys$$1[i]]._link\n    )\n      { return model.childByKey[keys$$1[i]]; }\n    model = model.joinKey(keys$$1[i], opts);\n  }\n\n  return model;\n};\n\nModelBase__proto__.notifyUpstream = function notifyUpstream (startPath) {\n    var this$1 = this;\n\n  var parent = this.parent;\n  var path = startPath || [this.key];\n  while (parent) {\n    if (parent.patterns) { parent.patterns.forEach(function (o) { return o.notify(path.slice()); }); }\n    path.unshift(parent.key);\n    parent.links.forEach(function (l) { return l.notifiedUpstream(path, this$1.root); });\n    parent.deps.forEach(function (d) { return d.handleChange(path); });\n    parent.downstreamChanged(startPath);\n    parent = parent.parent;\n  }\n};\n\nModelBase__proto__.rebind = function rebind (next, previous, safe) {\n    var this$1 = this;\n\n  if (this._link) {\n    this._link.rebind(next, previous, false);\n  }\n\n  if (next === this) { return; }\n\n  // tell the deps to move to the new target\n  var i = this.deps.length;\n  while (i--) {\n    if (this$1.deps[i].rebind) { this$1.deps[i].rebind(next, previous, safe); }\n  }\n\n  i = this.links.length;\n  while (i--) {\n    var link = this$1.links[i];\n    // only relink the root of the link tree\n    if (link.owner && link.owner._link) { link.relinking(next, safe); }\n  }\n\n  i = this.children.length;\n  while (i--) {\n    var child = this$1.children[i];\n    child.rebind(next ? next.joinKey(child.key) : undefined, child._link || child, safe);\n    if (this$1.dataModel) {\n      this$1.addShuffleTask(function () { return checkDataLink(this$1, this$1.retrieve()); }, 'early');\n    }\n  }\n\n  i = this.bindings.length;\n  while (i--) {\n    this$1.bindings[i].rebind(next, previous, safe);\n  }\n};\n\nModelBase__proto__.reference = function reference () {\n  'refs' in this ? this.refs++ : (this.refs = 1);\n};\n\nModelBase__proto__.register = function register (dep) {\n  this.deps.push(dep);\n};\n\nModelBase__proto__.registerLink = function registerLink (link) {\n  addToArray(this.links, link);\n};\n\nModelBase__proto__.registerPatternObserver = function registerPatternObserver (observer) {\n  (this.patterns || (this.patterns = [])).push(observer);\n  this.register(observer);\n};\n\nModelBase__proto__.registerTwowayBinding = function registerTwowayBinding (binding) {\n  this.bindings.push(binding);\n};\n\nModelBase__proto__.unreference = function unreference () {\n  if ('refs' in this) { this.refs--; }\n};\n\nModelBase__proto__.unregister = function unregister (dep) {\n  removeFromArray(this.deps, dep);\n};\n\nModelBase__proto__.unregisterLink = function unregisterLink (link) {\n  removeFromArray(this.links, link);\n};\n\nModelBase__proto__.unregisterPatternObserver = function unregisterPatternObserver (observer) {\n  removeFromArray(this.patterns, observer);\n  this.unregister(observer);\n};\n\nModelBase__proto__.unregisterTwowayBinding = function unregisterTwowayBinding (binding) {\n  removeFromArray(this.bindings, binding);\n};\n\nModelBase__proto__.updateFromBindings = function updateFromBindings$1 (cascade) {\n    var this$1 = this;\n\n  var i = this.bindings.length;\n  while (i--) {\n    var value = this$1.bindings[i].getValue();\n    if (value !== this$1.value) { this$1.set(value); }\n  }\n\n  // check for one-way bindings if there are no two-ways\n  if (!this.bindings.length) {\n    var oneway = findBoundValue(this.deps);\n    if (oneway && oneway.value !== this.value) { this.set(oneway.value); }\n  }\n\n  if (cascade) {\n    this.children.forEach(updateFromBindings);\n    this.links.forEach(updateFromBindings);\n    if (this._link) { this._link.updateFromBindings(cascade); }\n  }\n};\n\n// TODO: this may be better handled by overriding `get` on models with a parent that isRoot\nfunction maybeBind(model, value, shouldBind) {\n  if (shouldBind && isFunction(value) && model.parent && model.parent.isRoot) {\n    if (!model.boundValue) {\n      model.boundValue = bind(value._r_unbound || value, model.parent.ractive);\n    }\n\n    return model.boundValue;\n  }\n\n  return value;\n}\n\nfunction updateFromBindings(model) {\n  model.updateFromBindings(true);\n}\n\nfunction findBoundValue(list) {\n  var i = list.length;\n  while (i--) {\n    if (list[i].bound) {\n      var owner = list[i].owner;\n      if (owner) {\n        var value = owner.name === 'checked' ? owner.node.checked : owner.node.value;\n        return { value: value };\n      }\n    }\n  }\n}\n\nfunction fireShuffleTasks(stage) {\n  if (!stage) {\n    fireShuffleTasks('early');\n    fireShuffleTasks('mark');\n  } else {\n    var tasks = shuffleTasks[stage];\n    shuffleTasks[stage] = [];\n    var i = tasks.length;\n    while (i--) { tasks[i](); }\n\n    var register = registerQueue[stage];\n    registerQueue[stage] = [];\n    i = register.length;\n    while (i--) { register[i].model.register(register[i].item); }\n  }\n}\n\nfunction shuffle(model, newIndices, link, unsafe) {\n  model.shuffling = true;\n\n  var upstream = model.source().length !== model.source().value.length;\n  var i = newIndices.length;\n  while (i--) {\n    var idx = newIndices[i];\n    // nothing is actually changing, so move in the index and roll on\n    if (i === idx) {\n      continue;\n    }\n\n    upstream = true;\n\n    // rebind the children on i to idx\n    if (i in model.childByKey)\n      { model.childByKey[i].rebind(\n        !~idx ? undefined : model.joinKey(idx),\n        model.childByKey[i],\n        !unsafe\n      ); }\n  }\n\n  model.links.forEach(function (l) { return l.shuffle(newIndices); });\n  if (!link) { fireShuffleTasks('early'); }\n\n  i = model.deps.length;\n  while (i--) {\n    if (model.deps[i].shuffle) { model.deps[i].shuffle(newIndices); }\n  }\n\n  model[link ? 'marked' : 'mark']();\n  if (!link) { fireShuffleTasks('mark'); }\n\n  if (upstream) { model.notifyUpstream(); }\n\n  model.shuffling = false;\n}\n\nfunction checkDataLink(model, value) {\n  if (value !== model.dataModel) {\n    if (value && value.viewmodel && value.viewmodel.isRoot && model.childByKey.data) {\n      model.childByKey.data.link(value.viewmodel, 'data');\n      model.dataModel = value;\n    } else if (model.dataModel) {\n      model.childByKey.data.unlink();\n      model.dataModel = true;\n    }\n  }\n}\n\nvar stack = [];\nvar captureGroup;\n\nfunction startCapturing() {\n  stack.push((captureGroup = []));\n}\n\nfunction stopCapturing() {\n  var dependencies = stack.pop();\n  captureGroup = stack[stack.length - 1];\n  return dependencies;\n}\n\nfunction capture(model) {\n  if (captureGroup) {\n    addToArray(captureGroup, model);\n  }\n}\n\nfunction bind$1(x) {\n  x.bind();\n}\nfunction cancel(x) {\n  x.cancel();\n}\nfunction destroyed(x) {\n  x.destroyed();\n}\nfunction handleChange(x) {\n  x.handleChange();\n}\nfunction mark(x) {\n  x.mark();\n}\nfunction markForce(x) {\n  x.mark(true);\n}\nfunction marked(x) {\n  x.marked();\n}\nfunction markedAll(x) {\n  x.markedAll();\n}\nfunction render(x) {\n  x.render();\n}\nfunction shuffled(x) {\n  x.shuffled();\n}\nfunction teardown(x) {\n  x.teardown();\n}\nfunction unbind(x) {\n  x.unbind();\n}\nfunction unrender(x) {\n  x.unrender();\n}\n\nfunction update(x) {\n  x.update();\n}\nfunction toString$1(x) {\n  return x.toString();\n}\nfunction toEscapedString(x) {\n  return x.toString(true);\n}\n\n// this is the dry method of checking to see if a rebind applies to\n// a particular keypath because in some cases, a dep may be bound\n// directly to a particular keypath e.g. foo.bars.0.baz and need\n// to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted\nfunction rebindMatch(template, next, previous, fragment) {\n  var keypath = template.r || template;\n\n  // no valid keypath, go with next\n  if (!keypath || !isString(keypath)) { return next; }\n\n  // completely contextual ref, go with next\n  if (\n    keypath === '.' ||\n    keypath[0] === '@' ||\n    (next || previous).isKey ||\n    (next || previous).isKeypath\n  )\n    { return next; }\n\n  var parts = keypath.split('/');\n  var keys = splitKeypath(parts[parts.length - 1]);\n  var last = keys[keys.length - 1];\n\n  // check the keypath against the model keypath to see if it matches\n  var model = next || previous;\n\n  // check to see if this was an alias\n  if (model && keys.length === 1 && last !== model.key && fragment) {\n    keys = findAlias(last, fragment) || keys;\n  }\n\n  var i = keys.length;\n  var match = true;\n  var shuffling = false;\n\n  while (model && i--) {\n    if (model.shuffling) { shuffling = true; }\n    // non-strict comparison to account for indices in keypaths\n    if (keys[i] != model.key) { match = false; }\n    model = model.parent;\n  }\n\n  // next is undefined, but keypath is shuffling and previous matches\n  if (!next && match && shuffling) { return previous; }\n  else if (next && !match && shuffling)\n    // next is defined, but doesn't match the keypath\n    { return previous; }\n  else { return next; }\n}\n\nfunction findAlias(name, fragment) {\n  while (fragment) {\n    var z = fragment.aliases;\n    if (z && z[name]) {\n      var aliases = (fragment.owner.iterations ? fragment.owner : fragment).owner.template.z;\n      for (var i = 0; i < aliases.length; i++) {\n        if (aliases[i].n === name) {\n          var alias = aliases[i].x;\n          if (!alias.r) { return false; }\n          var parts = alias.r.split('/');\n          return splitKeypath(parts[parts.length - 1]);\n        }\n      }\n      return;\n    }\n\n    fragment = fragment.componentParent || fragment.parent;\n  }\n}\n\n// temporary placeholder target for detached implicit links\nvar Missing = {\n  key: '@missing',\n  animate: noop,\n  applyValue: noop,\n  get: noop,\n  getKeypath: function getKeypath() {\n    return this.key;\n  },\n  joinAll: function joinAll() {\n    return this;\n  },\n  joinKey: function joinKey() {\n    return this;\n  },\n  mark: noop,\n  registerLink: noop,\n  shufle: noop,\n  set: noop,\n  unregisterLink: noop\n};\nMissing.parent = Missing;\n\nvar LinkModel = (function (ModelBase) {\n  function LinkModel(parent, owner, target, key) {\n    ModelBase.call(this, parent);\n\n    this.owner = owner;\n    this.target = target;\n    this.key = isUndefined(key) ? owner.key : key;\n    if (owner && owner.isLink) { this.sourcePath = (owner.sourcePath) + \".\" + (this.key); }\n\n    if (target) { target.registerLink(this); }\n\n    if (parent) { this.isReadonly = parent.isReadonly; }\n\n    this.isLink = true;\n  }\n\n  if ( ModelBase ) LinkModel.__proto__ = ModelBase;\n  var LinkModel__proto__ = LinkModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n  LinkModel__proto__.constructor = LinkModel;\n\n  LinkModel__proto__.animate = function animate (from, to, options, interpolator) {\n    return this.target.animate(from, to, options, interpolator);\n  };\n\n  LinkModel__proto__.applyValue = function applyValue (value) {\n    if (this.boundValue) { this.boundValue = null; }\n    this.target.applyValue(value);\n  };\n\n  LinkModel__proto__.attach = function attach (fragment) {\n    var model = resolveReference(fragment, this.key);\n    if (model) {\n      this.relinking(model, false);\n    } else {\n      // if there is no link available, move everything here to real models\n      this.owner.unlink();\n    }\n  };\n\n  LinkModel__proto__.detach = function detach () {\n    this.relinking(Missing, false);\n  };\n\n  LinkModel__proto__.get = function get (shouldCapture, opts) {\n    if ( opts === void 0 ) opts = {};\n\n    if (shouldCapture) {\n      capture(this);\n\n      // may need to tell the target to unwrap\n      opts.unwrap = 'unwrap' in opts ? opts.unwrap : true;\n    }\n\n    var bind = 'shouldBind' in opts ? opts.shouldBind : true;\n    opts.shouldBind = this.mapping && this.target.parent && this.target.parent.isRoot;\n\n    return maybeBind(this, this.target.get(false, opts), bind);\n  };\n\n  LinkModel__proto__.getKeypath = function getKeypath (ractive) {\n    if (ractive && ractive !== this.root.ractive) { return this.target.getKeypath(ractive); }\n\n    return ModelBase.prototype.getKeypath.call(this, ractive);\n  };\n\n  LinkModel__proto__.handleChange = function handleChange$1 () {\n    this.deps.forEach(handleChange);\n    this.links.forEach(handleChange);\n    this.notifyUpstream();\n  };\n\n  LinkModel__proto__.isDetached = function isDetached () {\n    return this.virtual && this.target === Missing;\n  };\n\n  LinkModel__proto__.joinKey = function joinKey (key) {\n    // TODO: handle nested links\n    if (isUndefined(key) || key === '') { return this; }\n\n    if (!hasOwn(this.childByKey, key)) {\n      var child = new LinkModel(this, this, this.target.joinKey(key), key);\n      this.children.push(child);\n      this.childByKey[key] = child;\n    }\n\n    return this.childByKey[key];\n  };\n\n  LinkModel__proto__.mark = function mark (force) {\n    this.target.mark(force);\n  };\n\n  LinkModel__proto__.marked = function marked$1 () {\n    if (this.boundValue) { this.boundValue = null; }\n\n    this.links.forEach(marked);\n\n    this.deps.forEach(handleChange);\n  };\n\n  LinkModel__proto__.markedAll = function markedAll$1 () {\n    this.children.forEach(markedAll);\n    this.marked();\n  };\n\n  LinkModel__proto__.notifiedUpstream = function notifiedUpstream (startPath, root) {\n    var this$1 = this;\n\n    this.links.forEach(function (l) { return l.notifiedUpstream(startPath, this$1.root); });\n    this.deps.forEach(handleChange);\n    if (startPath && this.rootLink) {\n      var parent = this.parent;\n      if (this.root !== root) {\n        var path = startPath.slice(1);\n        path.unshift(this.key);\n        this.notifyUpstream(path);\n      } else if (parent && parent !== this.target) {\n        var path$1 = [parent.key, this.key];\n        parent.links.forEach(function (l) { return l.notifiedUpstream(path$1, parent.root); });\n        parent.deps.forEach(function (d) { return d.handleChange(path$1); });\n        parent.notifyUpstream(path$1);\n      }\n    }\n  };\n\n  LinkModel__proto__.relinked = function relinked () {\n    this.target.registerLink(this);\n    this.children.forEach(function (c) { return c.relinked(); });\n  };\n\n  LinkModel__proto__.relinking = function relinking (target, safe) {\n    var this$1 = this;\n\n    if (this.rootLink && this.sourcePath)\n      { target = rebindMatch(this.sourcePath, target, this.target); }\n    if (!target || this.target === target) { return; }\n\n    this.target && this.target.unregisterLink(this);\n\n    this.target = target;\n    this.children.forEach(function (c) {\n      c.relinking(target.joinKey(c.key), safe);\n    });\n\n    if (!safe) { this.keypath = undefined; }\n\n    if (this.rootLink)\n      { this.addShuffleTask(function () {\n        this$1.relinked();\n        if (!safe) {\n          this$1.markedAll();\n          this$1.notifyUpstream();\n        }\n      }); }\n  };\n\n  LinkModel__proto__.set = function set (value) {\n    if (this.boundValue) { this.boundValue = null; }\n    this.target.set(value);\n  };\n\n  LinkModel__proto__.shuffle = function shuffle$1 (newIndices) {\n    // watch for extra shuffles caused by a shuffle in a downstream link\n    if (this.shuffling) { return; }\n\n    // let the real model handle firing off shuffles\n    if (!this.target.shuffling) {\n      if (this.target.shuffle) {\n        this.target.shuffle(newIndices);\n      } else {\n        // the target is a computation, which can't shuffle\n        this.target.mark();\n      }\n    } else {\n      shuffle(this, newIndices, true);\n    }\n  };\n\n  LinkModel__proto__.source = function source () {\n    if (this.target.source) { return this.target.source(); }\n    else { return this.target; }\n  };\n\n  LinkModel__proto__.teardown = function teardown$3 () {\n    if (this._link) { this._link.teardown(); }\n    this.target.unregisterLink(this);\n    this.children.forEach(teardown);\n  };\n\n  return LinkModel;\n}(ModelBase));\n\nModelBase.prototype.link = function link(model, keypath, options) {\n  var lnk = this._link || new LinkModel(this.parent, this, model, this.key);\n  lnk.implicit = options && options.implicit;\n  lnk.mapping = options && options.mapping;\n  lnk.sourcePath = keypath;\n  lnk.rootLink = true;\n  if (this._link) { this._link.relinking(model, false); }\n  this._link = lnk;\n  this.rebind(lnk, this, false);\n  fireShuffleTasks();\n\n  lnk.markedAll();\n\n  this.notifyUpstream();\n  return lnk;\n};\n\nModelBase.prototype.unlink = function unlink() {\n  if (this._link) {\n    var ln = this._link;\n    this._link = undefined;\n    ln.rebind(this, ln, false);\n    fireShuffleTasks();\n    ln.teardown();\n    this.notifyUpstream();\n  }\n};\n\nfunction fromExpression(body, length) {\n  if ( length === void 0 ) length = 0;\n\n  var args = new Array(length);\n\n  while (length--) {\n    args[length] = \"_\" + length;\n  }\n\n  // Functions created directly with new Function() look like this:\n  //     function anonymous (_0 /**/) { return _0*2 }\n  //\n  // With this workaround, we get a little more compact:\n  //     function (_0){return _0*2}\n  return new Function([], (\"return function (\" + (args.join(',')) + \"){return(\" + body + \");};\"))();\n}\n\nvar functions = create(null);\n\nfunction getFunction(str, i) {\n  if (functions[str]) { return functions[str]; }\n  return (functions[str] = createFunction(str, i));\n}\n\nfunction addFunctions(template) {\n  if (!template) { return; }\n\n  var exp = template.e;\n\n  if (!exp) { return; }\n\n  keys(exp).forEach(function (str) {\n    if (functions[str]) { return; }\n    functions[str] = exp[str];\n  });\n}\n\nvar TEMPLATE_VERSION = 4;\n\nvar leadingWhitespace = /^\\s+/;\n\nvar ParseError = function(message) {\n  this.name = 'ParseError';\n  this.message = message;\n  try {\n    throw new Error(message);\n  } catch (e) {\n    this.stack = e.stack;\n  }\n};\n\nParseError.prototype = Error.prototype;\n\nvar Parser = function(str, options) {\n  var item;\n  var lineStart = 0;\n\n  this.str = str;\n  this.options = options || {};\n  this.pos = 0;\n\n  this.lines = this.str.split('\\n');\n  this.lineEnds = this.lines.map(function (line) {\n    var lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n    lineStart = lineEnd;\n    return lineEnd;\n  }, 0);\n\n  // Custom init logic\n  if (this.init) { this.init(str, options); }\n\n  var items = [];\n\n  while (this.pos < this.str.length && (item = this.read())) {\n    items.push(item);\n  }\n\n  this.leftover = this.remaining();\n  this.result = this.postProcess ? this.postProcess(items, options) : items;\n};\n\nParser.prototype = {\n  read: function read(converters) {\n    var this$1 = this;\n\n    var i, item;\n\n    if (!converters) { converters = this.converters; }\n\n    var pos = this.pos;\n\n    var len = converters.length;\n    for (i = 0; i < len; i += 1) {\n      this$1.pos = pos; // reset for each attempt\n\n      if ((item = converters[i](this$1))) {\n        return item;\n      }\n    }\n\n    return null;\n  },\n\n  getContextMessage: function getContextMessage(pos, message) {\n    var ref = this.getLinePos(pos);\n    var lineNum = ref[0];\n    var columnNum = ref[1];\n    if (this.options.contextLines === -1) {\n      return [lineNum, columnNum, (message + \" at line \" + lineNum + \" character \" + columnNum)];\n    }\n\n    var line = this.lines[lineNum - 1];\n\n    var contextUp = '';\n    var contextDown = '';\n    if (this.options.contextLines) {\n      var start =\n        lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;\n      contextUp = this.lines\n        .slice(start, lineNum - 1 - start)\n        .join('\\n')\n        .replace(/\\t/g, '  ');\n      contextDown = this.lines\n        .slice(lineNum, lineNum + this.options.contextLines)\n        .join('\\n')\n        .replace(/\\t/g, '  ');\n      if (contextUp) {\n        contextUp += '\\n';\n      }\n      if (contextDown) {\n        contextDown = '\\n' + contextDown;\n      }\n    }\n\n    var numTabs = 0;\n    var annotation =\n      contextUp +\n      line.replace(/\\t/g, function (match, char) {\n        if (char < columnNum) {\n          numTabs += 1;\n        }\n\n        return '  ';\n      }) +\n      '\\n' +\n      new Array(columnNum + numTabs).join(' ') +\n      '^----' +\n      contextDown;\n\n    return [\n      lineNum,\n      columnNum,\n      (message + \" at line \" + lineNum + \" character \" + columnNum + \":\\n\" + annotation)\n    ];\n  },\n\n  getLinePos: function getLinePos(char) {\n    var this$1 = this;\n\n    var lineNum = 0;\n    var lineStart = 0;\n\n    while (char >= this.lineEnds[lineNum]) {\n      lineStart = this$1.lineEnds[lineNum];\n      lineNum += 1;\n    }\n\n    var columnNum = char - lineStart;\n    return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!\n  },\n\n  error: function error(message) {\n    var ref = this.getContextMessage(this.pos, message);\n    var lineNum = ref[0];\n    var columnNum = ref[1];\n    var msg = ref[2];\n\n    var error = new ParseError(msg);\n\n    error.line = lineNum;\n    error.character = columnNum;\n    error.shortMessage = message;\n\n    throw error;\n  },\n\n  matchString: function matchString(string) {\n    if (this.str.substr(this.pos, string.length) === string) {\n      this.pos += string.length;\n      return string;\n    }\n  },\n\n  matchPattern: function matchPattern(pattern) {\n    var match;\n\n    if ((match = pattern.exec(this.remaining()))) {\n      this.pos += match[0].length;\n      return match[1] || match[0];\n    }\n  },\n\n  sp: function sp() {\n    this.matchPattern(leadingWhitespace);\n  },\n\n  remaining: function remaining() {\n    return this.str.substring(this.pos);\n  },\n\n  nextChar: function nextChar() {\n    return this.str.charAt(this.pos);\n  },\n\n  warn: function warn(message) {\n    var msg = this.getContextMessage(this.pos, message)[2];\n\n    warnIfDebug(msg);\n  }\n};\n\nParser.extend = function(proto) {\n  var Parent = this;\n  var Child = function(str, options) {\n    Parser.call(this, str, options);\n  };\n\n  Child.prototype = create(Parent.prototype);\n\n  for (var key in proto) {\n    if (hasOwn(proto, key)) {\n      Child.prototype[key] = proto[key];\n    }\n  }\n\n  Child.extend = Parser.extend;\n  return Child;\n};\n\nvar TEXT = 1;\nvar INTERPOLATOR = 2;\nvar TRIPLE = 3;\nvar SECTION = 4;\nvar INVERTED = 5;\nvar CLOSING = 6;\nvar ELEMENT = 7;\nvar PARTIAL = 8;\nvar COMMENT = 9;\nvar DELIMCHANGE = 10;\nvar ANCHOR = 11;\nvar ATTRIBUTE = 13;\nvar CLOSING_TAG = 14;\nvar COMPONENT = 15;\nvar YIELDER = 16;\nvar INLINE_PARTIAL = 17;\nvar DOCTYPE = 18;\nvar ALIAS = 19;\n\nvar AWAIT = 55;\n\nvar NUMBER_LITERAL = 20;\nvar STRING_LITERAL = 21;\nvar ARRAY_LITERAL = 22;\nvar OBJECT_LITERAL = 23;\nvar BOOLEAN_LITERAL = 24;\nvar REGEXP_LITERAL = 25;\n\nvar GLOBAL = 26;\nvar KEY_VALUE_PAIR = 27;\n\nvar REFERENCE = 30;\nvar REFINEMENT = 31;\nvar MEMBER = 32;\nvar PREFIX_OPERATOR = 33;\nvar BRACKETED = 34;\nvar CONDITIONAL = 35;\nvar INFIX_OPERATOR = 36;\n\nvar INVOCATION = 40;\n\nvar SECTION_IF = 50;\nvar SECTION_UNLESS = 51;\nvar SECTION_EACH = 52;\nvar SECTION_WITH = 53;\nvar SECTION_IF_WITH = 54;\n\nvar ELSE = 60;\nvar ELSEIF = 61;\nvar THEN = 62;\nvar CATCH = 63;\n\nvar EVENT = 70;\nvar DECORATOR = 71;\nvar TRANSITION = 72;\nvar BINDING_FLAG = 73;\nvar DELEGATE_FLAG = 74;\n\nvar delimiterChangePattern = /^[^\\s=]+/;\nvar whitespacePattern = /^\\s+/;\n\nfunction readDelimiterChange(parser) {\n  if (!parser.matchString('=')) {\n    return null;\n  }\n\n  var start = parser.pos;\n\n  // allow whitespace before new opening delimiter\n  parser.sp();\n\n  var opening = parser.matchPattern(delimiterChangePattern);\n  if (!opening) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace (in fact, it's necessary...)\n  if (!parser.matchPattern(whitespacePattern)) {\n    return null;\n  }\n\n  var closing = parser.matchPattern(delimiterChangePattern);\n  if (!closing) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace before closing '='\n  parser.sp();\n\n  if (!parser.matchString('=')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return [opening, closing];\n}\n\nvar regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n\nfunction readNumberLiteral(parser) {\n  var result;\n\n  if ((result = parser.matchPattern(regexpPattern))) {\n    return {\n      t: REGEXP_LITERAL,\n      v: result\n    };\n  }\n\n  return null;\n}\n\nvar pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\nfunction escapeRegExp(str) {\n  return str.replace(pattern, '\\\\$&');\n}\n\nvar regExpCache = {};\n\nfunction getLowestIndex(haystack, needles) {\n  return haystack.search(\n    regExpCache[needles.join()] ||\n      (regExpCache[needles.join()] = new RegExp(needles.map(escapeRegExp).join('|')))\n  );\n}\n\n// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n//export const booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\nvar booleanAttributes = {\n  allowfullscreen: 1,\n  async: 1,\n  autofocus: 1,\n  autoplay: 1,\n  checked: 1,\n  compact: 1,\n  controls: 1,\n  declare: 1,\n  default: 1,\n  defaultchecked: 1,\n  defaultmuted: 1,\n  defaultselected: 1,\n  defer: 1,\n  disabled: 1,\n  enabled: 1,\n  formnovalidate: 1,\n  hidden: 1,\n  indeterminate: 1,\n  inert: 1,\n  ismap: 1,\n  itemscope: 1,\n  loop: 1,\n  multiple: 1,\n  muted: 1,\n  nohref: 1,\n  noresize: 1,\n  noshade: 1,\n  novalidate: 1,\n  nowrap: 1,\n  open: 1,\n  pauseonexit: 1,\n  readonly: 1,\n  required: 1,\n  reversed: 1,\n  scoped: 1,\n  seamless: 1,\n  selected: 1,\n  sortable: 1,\n  translate: 1,\n  truespeed: 1,\n  typemustmatch: 1,\n  visible: 1\n};\nvar voidElements = {\n  area: 1,\n  base: 1,\n  br: 1,\n  col: 1,\n  command: 1,\n  doctype: 1,\n  embed: 1,\n  hr: 1,\n  img: 1,\n  input: 1,\n  keygen: 1,\n  link: 1,\n  meta: 1,\n  param: 1,\n  source: 1,\n  track: 1,\n  wbr: 1\n};\n\nvar htmlEntities = {\n  quot: 34,\n  amp: 38,\n  apos: 39,\n  lt: 60,\n  gt: 62,\n  nbsp: 160,\n  iexcl: 161,\n  cent: 162,\n  pound: 163,\n  curren: 164,\n  yen: 165,\n  brvbar: 166,\n  sect: 167,\n  uml: 168,\n  copy: 169,\n  ordf: 170,\n  laquo: 171,\n  not: 172,\n  shy: 173,\n  reg: 174,\n  macr: 175,\n  deg: 176,\n  plusmn: 177,\n  sup2: 178,\n  sup3: 179,\n  acute: 180,\n  micro: 181,\n  para: 182,\n  middot: 183,\n  cedil: 184,\n  sup1: 185,\n  ordm: 186,\n  raquo: 187,\n  frac14: 188,\n  frac12: 189,\n  frac34: 190,\n  iquest: 191,\n  Agrave: 192,\n  Aacute: 193,\n  Acirc: 194,\n  Atilde: 195,\n  Auml: 196,\n  Aring: 197,\n  AElig: 198,\n  Ccedil: 199,\n  Egrave: 200,\n  Eacute: 201,\n  Ecirc: 202,\n  Euml: 203,\n  Igrave: 204,\n  Iacute: 205,\n  Icirc: 206,\n  Iuml: 207,\n  ETH: 208,\n  Ntilde: 209,\n  Ograve: 210,\n  Oacute: 211,\n  Ocirc: 212,\n  Otilde: 213,\n  Ouml: 214,\n  times: 215,\n  Oslash: 216,\n  Ugrave: 217,\n  Uacute: 218,\n  Ucirc: 219,\n  Uuml: 220,\n  Yacute: 221,\n  THORN: 222,\n  szlig: 223,\n  agrave: 224,\n  aacute: 225,\n  acirc: 226,\n  atilde: 227,\n  auml: 228,\n  aring: 229,\n  aelig: 230,\n  ccedil: 231,\n  egrave: 232,\n  eacute: 233,\n  ecirc: 234,\n  euml: 235,\n  igrave: 236,\n  iacute: 237,\n  icirc: 238,\n  iuml: 239,\n  eth: 240,\n  ntilde: 241,\n  ograve: 242,\n  oacute: 243,\n  ocirc: 244,\n  otilde: 245,\n  ouml: 246,\n  divide: 247,\n  oslash: 248,\n  ugrave: 249,\n  uacute: 250,\n  ucirc: 251,\n  uuml: 252,\n  yacute: 253,\n  thorn: 254,\n  yuml: 255,\n  OElig: 338,\n  oelig: 339,\n  Scaron: 352,\n  scaron: 353,\n  Yuml: 376,\n  fnof: 402,\n  circ: 710,\n  tilde: 732,\n  Alpha: 913,\n  Beta: 914,\n  Gamma: 915,\n  Delta: 916,\n  Epsilon: 917,\n  Zeta: 918,\n  Eta: 919,\n  Theta: 920,\n  Iota: 921,\n  Kappa: 922,\n  Lambda: 923,\n  Mu: 924,\n  Nu: 925,\n  Xi: 926,\n  Omicron: 927,\n  Pi: 928,\n  Rho: 929,\n  Sigma: 931,\n  Tau: 932,\n  Upsilon: 933,\n  Phi: 934,\n  Chi: 935,\n  Psi: 936,\n  Omega: 937,\n  alpha: 945,\n  beta: 946,\n  gamma: 947,\n  delta: 948,\n  epsilon: 949,\n  zeta: 950,\n  eta: 951,\n  theta: 952,\n  iota: 953,\n  kappa: 954,\n  lambda: 955,\n  mu: 956,\n  nu: 957,\n  xi: 958,\n  omicron: 959,\n  pi: 960,\n  rho: 961,\n  sigmaf: 962,\n  sigma: 963,\n  tau: 964,\n  upsilon: 965,\n  phi: 966,\n  chi: 967,\n  psi: 968,\n  omega: 969,\n  thetasym: 977,\n  upsih: 978,\n  piv: 982,\n  ensp: 8194,\n  emsp: 8195,\n  thinsp: 8201,\n  zwnj: 8204,\n  zwj: 8205,\n  lrm: 8206,\n  rlm: 8207,\n  ndash: 8211,\n  mdash: 8212,\n  lsquo: 8216,\n  rsquo: 8217,\n  sbquo: 8218,\n  ldquo: 8220,\n  rdquo: 8221,\n  bdquo: 8222,\n  dagger: 8224,\n  Dagger: 8225,\n  bull: 8226,\n  hellip: 8230,\n  permil: 8240,\n  prime: 8242,\n  Prime: 8243,\n  lsaquo: 8249,\n  rsaquo: 8250,\n  oline: 8254,\n  frasl: 8260,\n  euro: 8364,\n  image: 8465,\n  weierp: 8472,\n  real: 8476,\n  trade: 8482,\n  alefsym: 8501,\n  larr: 8592,\n  uarr: 8593,\n  rarr: 8594,\n  darr: 8595,\n  harr: 8596,\n  crarr: 8629,\n  lArr: 8656,\n  uArr: 8657,\n  rArr: 8658,\n  dArr: 8659,\n  hArr: 8660,\n  forall: 8704,\n  part: 8706,\n  exist: 8707,\n  empty: 8709,\n  nabla: 8711,\n  isin: 8712,\n  notin: 8713,\n  ni: 8715,\n  prod: 8719,\n  sum: 8721,\n  minus: 8722,\n  lowast: 8727,\n  radic: 8730,\n  prop: 8733,\n  infin: 8734,\n  ang: 8736,\n  and: 8743,\n  or: 8744,\n  cap: 8745,\n  cup: 8746,\n  int: 8747,\n  there4: 8756,\n  sim: 8764,\n  cong: 8773,\n  asymp: 8776,\n  ne: 8800,\n  equiv: 8801,\n  le: 8804,\n  ge: 8805,\n  sub: 8834,\n  sup: 8835,\n  nsub: 8836,\n  sube: 8838,\n  supe: 8839,\n  oplus: 8853,\n  otimes: 8855,\n  perp: 8869,\n  sdot: 8901,\n  lceil: 8968,\n  rceil: 8969,\n  lfloor: 8970,\n  rfloor: 8971,\n  lang: 9001,\n  rang: 9002,\n  loz: 9674,\n  spades: 9824,\n  clubs: 9827,\n  hearts: 9829,\n  diams: 9830\n};\nvar controlCharacters = [\n  8364,\n  129,\n  8218,\n  402,\n  8222,\n  8230,\n  8224,\n  8225,\n  710,\n  8240,\n  352,\n  8249,\n  338,\n  141,\n  381,\n  143,\n  144,\n  8216,\n  8217,\n  8220,\n  8221,\n  8226,\n  8211,\n  8212,\n  732,\n  8482,\n  353,\n  8250,\n  339,\n  157,\n  382,\n  376\n];\nvar entityPattern = new RegExp(\n  '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + keys(htmlEntities).join('|') + '));?',\n  'g'\n);\nvar codePointSupport = isFunction(String.fromCodePoint);\nvar codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;\n\nfunction decodeCharacterReferences(html) {\n  return html.replace(entityPattern, function (match, entity) {\n    var code;\n\n    // Handle named entities\n    if (entity[0] !== '#') {\n      code = htmlEntities[entity];\n    } else if (entity[1] === 'x') {\n      code = parseInt(entity.substring(2), 16);\n    } else {\n      code = parseInt(entity.substring(1), 10);\n    }\n\n    if (!code) {\n      return match;\n    }\n\n    return codeToChar(validateCode(code));\n  });\n}\n\nvar lessThan = /</g;\nvar greaterThan = />/g;\nvar amp = /&/g;\nvar invalid = 65533;\n\nfunction escapeHtml(str) {\n  return str\n    .replace(amp, '&amp;')\n    .replace(lessThan, '&lt;')\n    .replace(greaterThan, '&gt;');\n}\n\n// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n// to replace them ourselves\n//\n// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n/* istanbul ignore next */\nfunction validateCode(code) {\n  if (!code) {\n    return invalid;\n  }\n\n  // line feed becomes generic whitespace\n  if (code === 10) {\n    return 32;\n  }\n\n  // ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n  if (code < 128) {\n    return code;\n  }\n\n  // code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n  // to correct the mistake or we'll end up with missing  signs and so on\n  if (code <= 159) {\n    return controlCharacters[code - 128];\n  }\n\n  // basic multilingual plane\n  if (code < 55296) {\n    return code;\n  }\n\n  // UTF-16 surrogate halves\n  if (code <= 57343) {\n    return invalid;\n  }\n\n  // rest of the basic multilingual plane\n  if (code <= 65535) {\n    return code;\n  } else if (!codePointSupport) {\n    return invalid;\n  }\n\n  // supplementary multilingual plane 0x10000 - 0x1ffff\n  if (code >= 65536 && code <= 131071) {\n    return code;\n  }\n\n  // supplementary ideographic plane 0x20000 - 0x2ffff\n  if (code >= 131072 && code <= 196607) {\n    return code;\n  }\n\n  return invalid;\n}\n\nvar expectedExpression = 'Expected a JavaScript expression';\nvar expectedParen = 'Expected closing paren';\n\n// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330\nvar numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\nfunction readNumberLiteral$1(parser) {\n  var result;\n\n  if ((result = parser.matchPattern(numberPattern))) {\n    return {\n      t: NUMBER_LITERAL,\n      v: result\n    };\n  }\n\n  return null;\n}\n\nfunction readBooleanLiteral(parser) {\n  var remaining = parser.remaining();\n\n  if (remaining.substr(0, 4) === 'true') {\n    parser.pos += 4;\n    return {\n      t: BOOLEAN_LITERAL,\n      v: 'true'\n    };\n  }\n\n  if (remaining.substr(0, 5) === 'false') {\n    parser.pos += 5;\n    return {\n      t: BOOLEAN_LITERAL,\n      v: 'false'\n    };\n  }\n\n  return null;\n}\n\n// Match one or more characters until: \", ', \\, or EOL/EOF.\n// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\nvar stringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\n// Match one escape sequence, including the backslash.\nvar escapeSequencePattern = /^\\\\(?:[`'\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n// Match one ES5 line continuation (backslash + line terminator).\nvar lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n// Helper for defining getDoubleQuotedString and getSingleQuotedString.\nfunction makeQuotedStringMatcher(okQuote) {\n  return function(parser) {\n    var literal = '\"';\n    var done = false;\n    var next;\n\n    while (!done) {\n      next =\n        parser.matchPattern(stringMiddlePattern) ||\n        parser.matchPattern(escapeSequencePattern) ||\n        parser.matchString(okQuote);\n      if (next) {\n        if (next === \"\\\"\") {\n          literal += \"\\\\\\\"\";\n        } else if (next === \"\\\\'\") {\n          literal += \"'\";\n        } else {\n          literal += next;\n        }\n      } else {\n        next = parser.matchPattern(lineContinuationPattern);\n        if (next) {\n          // convert \\(newline-like) into a \\u escape, which is allowed in JSON\n          literal += '\\\\u' + ('000' + next.charCodeAt(1).toString(16)).slice(-4);\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    literal += '\"';\n\n    // use JSON.parse to interpret escapes\n    return JSON.parse(literal);\n  };\n}\n\nvar singleMatcher = makeQuotedStringMatcher(\"\\\"\");\nvar doubleMatcher = makeQuotedStringMatcher(\"'\");\n\nfunction readStringLiteral(parser) {\n  var start = parser.pos;\n  var quote = parser.matchString(\"'\") || parser.matchString(\"\\\"\");\n\n  if (quote) {\n    var string = (quote === \"'\" ? singleMatcher : doubleMatcher)(parser);\n\n    if (!parser.matchString(quote)) {\n      parser.pos = start;\n      return null;\n    }\n\n    return {\n      t: STRING_LITERAL,\n      v: string\n    };\n  }\n\n  return null;\n}\n\n// Match one or more characters until: \", ', or \\\nvar stringMiddlePattern$1 = /^[^`\"\\\\\\$]+?(?:(?=[`\"\\\\\\$]))/;\n\nvar escapes = /[\\r\\n\\t\\b\\f]/g;\nfunction getString(literal) {\n  return JSON.parse((\"\\\"\" + (literal.replace(escapes, escapeChar)) + \"\\\"\"));\n}\n\nfunction escapeChar(c) {\n  switch (c) {\n    case '\\n':\n      return '\\\\n';\n    case '\\r':\n      return '\\\\r';\n    case '\\t':\n      return '\\\\t';\n    case '\\b':\n      return '\\\\b';\n    case '\\f':\n      return '\\\\f';\n  }\n}\n\nfunction readTemplateStringLiteral(parser) {\n  if (!parser.matchString('`')) { return null; }\n\n  var literal = '';\n  var done = false;\n  var next;\n  var parts = [];\n\n  while (!done) {\n    next =\n      parser.matchPattern(stringMiddlePattern$1) ||\n      parser.matchPattern(escapeSequencePattern) ||\n      parser.matchString('$') ||\n      parser.matchString('\"');\n    if (next) {\n      if (next === \"\\\"\") {\n        literal += \"\\\\\\\"\";\n      } else if (next === '\\\\`') {\n        literal += '`';\n      } else if (next === '$') {\n        if (parser.matchString('{')) {\n          parts.push({ t: STRING_LITERAL, v: getString(literal) });\n          literal = '';\n\n          parser.sp();\n          var expr = readExpression(parser);\n\n          if (!expr) { parser.error('Expected valid expression'); }\n\n          parts.push({ t: BRACKETED, x: expr });\n\n          parser.sp();\n          if (!parser.matchString('}'))\n            { parser.error(\"Expected closing '}' after interpolated expression\"); }\n        } else {\n          literal += '$';\n        }\n      } else {\n        literal += next;\n      }\n    } else {\n      next = parser.matchPattern(lineContinuationPattern);\n      if (next) {\n        // convert \\(newline-like) into a \\u escape, which is allowed in JSON\n        literal += '\\\\u' + ('000' + next.charCodeAt(1).toString(16)).slice(-4);\n      } else {\n        done = true;\n      }\n    }\n  }\n\n  if (literal.length) { parts.push({ t: STRING_LITERAL, v: getString(literal) }); }\n\n  if (!parser.matchString('`')) { parser.error(\"Expected closing '`'\"); }\n\n  if (!parts.length) {\n    // empty string literal\n    return { t: STRING_LITERAL, v: '' };\n  } else if (parts.length === 1) {\n    return parts[0];\n  } else {\n    var result = parts.pop();\n    var part;\n\n    while ((part = parts.pop())) {\n      result = {\n        t: INFIX_OPERATOR,\n        s: '+',\n        o: [part, result]\n      };\n    }\n\n    return {\n      t: BRACKETED,\n      x: result\n    };\n  }\n}\n\nvar name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\nvar spreadPattern = /^\\s*\\.{3}/;\nvar legalReference = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:\\.(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\nvar relaxedName = /^[a-zA-Z_$][-\\/a-zA-Z_$0-9]*(?:\\.(?:[a-zA-Z_$][-\\/a-zA-Z_$0-9]*))*/;\n\nvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\n// http://mathiasbynens.be/notes/javascript-properties\n// can be any name, string literal, or number literal\nfunction readKey(parser) {\n  var token;\n\n  if ((token = readStringLiteral(parser))) {\n    return identifier.test(token.v) ? token.v : '\"' + token.v.replace(/\"/g, '\\\\\"') + '\"';\n  }\n\n  if ((token = readNumberLiteral$1(parser))) {\n    return token.v;\n  }\n\n  if ((token = parser.matchPattern(name))) {\n    return token;\n  }\n\n  return null;\n}\n\nfunction readKeyValuePair(parser) {\n  var spread;\n  var start = parser.pos;\n\n  // allow whitespace between '{' and key\n  parser.sp();\n\n  var refKey = parser.nextChar() !== \"'\" && parser.nextChar() !== '\"';\n  if (refKey) { spread = parser.matchPattern(spreadPattern); }\n\n  var key = spread ? readExpression(parser) : readKey(parser);\n  if (key === null) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace between key and ':'\n  parser.sp();\n\n  // es2015 shorthand property\n  if (refKey && (parser.nextChar() === ',' || parser.nextChar() === '}')) {\n    if (!spread && !name.test(key)) {\n      parser.error((\"Expected a valid reference, but found '\" + key + \"' instead.\"));\n    }\n\n    var pair = {\n      t: KEY_VALUE_PAIR,\n      k: key,\n      v: {\n        t: REFERENCE,\n        n: key\n      }\n    };\n\n    if (spread) {\n      pair.p = true;\n    }\n\n    return pair;\n  }\n\n  // next character must be ':'\n  if (!parser.matchString(':')) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace between ':' and value\n  parser.sp();\n\n  // next expression must be a, well... expression\n  var value = readExpression(parser);\n  if (value === null) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: KEY_VALUE_PAIR,\n    k: key,\n    v: value\n  };\n}\n\nfunction readKeyValuePairs(parser) {\n  var start = parser.pos;\n\n  var pair = readKeyValuePair(parser);\n  if (pair === null) {\n    return null;\n  }\n\n  var pairs = [pair];\n\n  if (parser.matchString(',')) {\n    var keyValuePairs = readKeyValuePairs(parser);\n\n    if (!keyValuePairs) {\n      parser.pos = start;\n      return null;\n    }\n\n    return pairs.concat(keyValuePairs);\n  }\n\n  return pairs;\n}\n\nfunction readObjectLiteral(parser) {\n  var start = parser.pos;\n\n  // allow whitespace\n  parser.sp();\n\n  if (!parser.matchString('{')) {\n    parser.pos = start;\n    return null;\n  }\n\n  var keyValuePairs = readKeyValuePairs(parser);\n\n  // allow whitespace between final value and '}'\n  parser.sp();\n\n  if (!parser.matchString('}')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: OBJECT_LITERAL,\n    m: keyValuePairs\n  };\n}\n\nfunction readArrayLiteral(parser) {\n  var start = parser.pos;\n\n  // allow whitespace before '['\n  parser.sp();\n\n  if (!parser.matchString('[')) {\n    parser.pos = start;\n    return null;\n  }\n\n  var expressionList = readExpressionList(parser, true);\n\n  if (!parser.matchString(']')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: ARRAY_LITERAL,\n    m: expressionList\n  };\n}\n\nfunction readLiteral(parser) {\n  return (\n    readNumberLiteral$1(parser) ||\n    readBooleanLiteral(parser) ||\n    readStringLiteral(parser) ||\n    readTemplateStringLiteral(parser) ||\n    readObjectLiteral(parser) ||\n    readArrayLiteral(parser) ||\n    readNumberLiteral(parser)\n  );\n}\n\n// if a reference is a browser global, we don't deference it later, so it needs special treatment\nvar globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\\b/;\n\n// keywords are not valid references, with the exception of `this`\nvar keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\nvar prefixPattern = /^(?:\\@\\.|\\@|~\\/|(?:\\^\\^\\/(?:\\^\\^\\/)*(?:\\.\\.\\/)*)|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/;\nvar specials = /^(key|index|keypath|rootpath|this|global|shared|context|event|node|local|style|helpers|last|macro)/;\n\nfunction readReference(parser) {\n  var prefix, name$$1, global, reference, lastDotIndex;\n\n  var startPos = parser.pos;\n\n  prefix = parser.matchPattern(prefixPattern) || '';\n  name$$1 =\n    (!prefix && parser.relaxedNames && parser.matchPattern(relaxedName)) ||\n    parser.matchPattern(legalReference);\n  var actual = prefix.length + ((name$$1 && name$$1.length) || 0);\n\n  if (prefix === '@.') {\n    prefix = '@';\n    if (name$$1) { name$$1 = 'this.' + name$$1; }\n    else { name$$1 = 'this'; }\n  }\n\n  if (!name$$1 && prefix) {\n    name$$1 = prefix;\n    prefix = '';\n  }\n\n  if (!name$$1) {\n    return null;\n  }\n\n  if (prefix === '@') {\n    if (!specials.test(name$$1)) {\n      parser.error((\"Unrecognized special reference @\" + name$$1));\n    } else if ((!name$$1.indexOf('event') || !name$$1.indexOf('node')) && !parser.inEvent) {\n      parser.error(\"@event and @node are only valid references within an event directive\");\n    } else if (!name$$1.indexOf('context')) {\n      parser.pos = parser.pos - (name$$1.length - 7);\n      return {\n        t: BRACKETED,\n        x: {\n          t: REFERENCE,\n          n: '@context'\n        }\n      };\n    }\n  }\n\n  // bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n  if (!prefix && !parser.relaxedNames && keywords.test(name$$1)) {\n    parser.pos = startPos;\n    return null;\n  }\n\n  // if this is a browser global, stop here\n  if (!prefix && globals.test(name$$1)) {\n    global = globals.exec(name$$1)[0];\n    parser.pos = startPos + global.length;\n\n    return {\n      t: GLOBAL,\n      v: global\n    };\n  }\n\n  reference = (prefix || '') + normalise(name$$1);\n\n  if (parser.matchString('(')) {\n    // if this is a method invocation (as opposed to a function) we need\n    // to strip the method name from the reference combo, else the context\n    // will be wrong\n    // but only if the reference was actually a member and not a refinement\n    lastDotIndex = reference.lastIndexOf('.');\n    if (lastDotIndex !== -1 && name$$1[name$$1.length - 1] !== ']') {\n      if (lastDotIndex === 0) {\n        reference = '.';\n        parser.pos = startPos;\n      } else {\n        var refLength = reference.length;\n        reference = reference.substr(0, lastDotIndex);\n        parser.pos = startPos + (actual - (refLength - lastDotIndex));\n      }\n    } else {\n      parser.pos -= 1;\n    }\n  }\n\n  return {\n    t: REFERENCE,\n    n: reference.replace(/^this\\./, './').replace(/^this$/, '.')\n  };\n}\n\nfunction readBracketedExpression(parser) {\n  if (!parser.matchString('(')) { return null; }\n\n  parser.sp();\n\n  var expr = readExpression(parser);\n\n  if (!expr) { parser.error(expectedExpression); }\n\n  parser.sp();\n\n  if (!parser.matchString(')')) { parser.error(expectedParen); }\n\n  return {\n    t: BRACKETED,\n    x: expr\n  };\n}\n\nfunction readPrimary(parser) {\n  return readLiteral(parser) || readReference(parser) || readBracketedExpression(parser);\n}\n\nfunction readRefinement(parser) {\n  // some things call for strict refinement (partial names), meaning no space between reference and refinement\n  if (!parser.strictRefinement) {\n    parser.sp();\n  }\n\n  // \".\" name\n  if (parser.matchString('.')) {\n    parser.sp();\n\n    var name$$1 = parser.matchPattern(name);\n    if (name$$1) {\n      return {\n        t: REFINEMENT,\n        n: name$$1\n      };\n    }\n\n    parser.error('Expected a property name');\n  }\n\n  // \"[\" expression \"]\"\n  if (parser.matchString('[')) {\n    parser.sp();\n\n    var expr = readExpression(parser);\n    if (!expr) { parser.error(expectedExpression); }\n\n    parser.sp();\n\n    if (!parser.matchString(']')) { parser.error(\"Expected ']'\"); }\n\n    return {\n      t: REFINEMENT,\n      x: expr\n    };\n  }\n\n  return null;\n}\n\nfunction readMemberOrInvocation(parser) {\n  var expression = readPrimary(parser);\n\n  if (!expression) { return null; }\n\n  while (expression) {\n    var refinement = readRefinement(parser);\n    if (refinement) {\n      expression = {\n        t: MEMBER,\n        x: expression,\n        r: refinement\n      };\n    } else if (parser.matchString('(')) {\n      parser.sp();\n      var expressionList = readExpressionList(parser, true);\n\n      parser.sp();\n\n      if (!parser.matchString(')')) {\n        parser.error(expectedParen);\n      }\n\n      expression = {\n        t: INVOCATION,\n        x: expression\n      };\n\n      if (expressionList) { expression.o = expressionList; }\n    } else {\n      break;\n    }\n  }\n\n  return expression;\n}\n\nvar readTypeOf;\n\nvar makePrefixSequenceMatcher = function(symbol, fallthrough) {\n  return function(parser) {\n    var expression;\n\n    if ((expression = fallthrough(parser))) {\n      return expression;\n    }\n\n    if (!parser.matchString(symbol)) {\n      return null;\n    }\n\n    parser.sp();\n\n    expression = readExpression(parser);\n    if (!expression) {\n      parser.error(expectedExpression);\n    }\n\n    return {\n      s: symbol,\n      o: expression,\n      t: PREFIX_OPERATOR\n    };\n  };\n};\n\n// create all prefix sequence matchers, return readTypeOf\n(function() {\n  var i, len, matcher, fallthrough;\n\n  var prefixOperators = '! ~ + - typeof'.split(' ');\n\n  fallthrough = readMemberOrInvocation;\n  for (i = 0, len = prefixOperators.length; i < len; i += 1) {\n    matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);\n    fallthrough = matcher;\n  }\n\n  // typeof operator is higher precedence than multiplication, so provides the\n  // fallthrough for the multiplication sequence matcher we're about to create\n  // (we're skipping void and delete)\n  readTypeOf = fallthrough;\n})();\n\nvar readTypeof = readTypeOf;\n\nvar readLogicalOr;\n\nvar makeInfixSequenceMatcher = function(symbol, fallthrough) {\n  return function(parser) {\n    // > and / have to be quoted\n    if (parser.inUnquotedAttribute && (symbol === '>' || symbol === '/'))\n      { return fallthrough(parser); }\n\n    var start, left, right;\n\n    left = fallthrough(parser);\n    if (!left) {\n      return null;\n    }\n\n    // Loop to handle left-recursion in a case like `a * b * c` and produce\n    // left association, i.e. `(a * b) * c`.  The matcher can't call itself\n    // to parse `left` because that would be infinite regress.\n    while (true) {\n      start = parser.pos;\n\n      parser.sp();\n\n      if (!parser.matchString(symbol)) {\n        parser.pos = start;\n        return left;\n      }\n\n      // special case - in operator must not be followed by [a-zA-Z_$0-9]\n      if (symbol === 'in' && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {\n        parser.pos = start;\n        return left;\n      }\n\n      parser.sp();\n\n      // right operand must also consist of only higher-precedence operators\n      right = fallthrough(parser);\n      if (!right) {\n        parser.pos = start;\n        return left;\n      }\n\n      left = {\n        t: INFIX_OPERATOR,\n        s: symbol,\n        o: [left, right]\n      };\n\n      // Loop back around.  If we don't see another occurrence of the symbol,\n      // we'll return left.\n    }\n  };\n};\n\n// create all infix sequence matchers, and return readLogicalOr\n(function() {\n  var i, len, matcher, fallthrough;\n\n  // All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  // Each sequence matcher will initially fall through to its higher precedence\n  // neighbour, and only attempt to match if one of the higher precedence operators\n  // (or, ultimately, a literal, reference, or bracketed expression) already matched\n  var infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split(\n    ' '\n  );\n\n  // A typeof operator is higher precedence than multiplication\n  fallthrough = readTypeof;\n  for (i = 0, len = infixOperators.length; i < len; i += 1) {\n    matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);\n    fallthrough = matcher;\n  }\n\n  // Logical OR is the fallthrough for the conditional matcher\n  readLogicalOr = fallthrough;\n})();\n\nvar readLogicalOr$1 = readLogicalOr;\n\n// The conditional operator is the lowest precedence operator, so we start here\nfunction getConditional(parser) {\n  var expression = readLogicalOr$1(parser);\n  if (!expression) {\n    return null;\n  }\n\n  var start = parser.pos;\n\n  parser.sp();\n\n  if (!parser.matchString('?')) {\n    parser.pos = start;\n    return expression;\n  }\n\n  parser.sp();\n\n  var ifTrue = readExpression(parser);\n  if (!ifTrue) {\n    parser.error(expectedExpression);\n  }\n\n  parser.sp();\n\n  if (!parser.matchString(':')) {\n    parser.error('Expected \":\"');\n  }\n\n  parser.sp();\n\n  var ifFalse = readExpression(parser);\n  if (!ifFalse) {\n    parser.error(expectedExpression);\n  }\n\n  return {\n    t: CONDITIONAL,\n    o: [expression, ifTrue, ifFalse]\n  };\n}\n\nfunction readExpression(parser) {\n  // if eval is false, no expressions\n  if (parser.allowExpressions === false) {\n    var ref = readReference(parser);\n    parser.sp();\n    return ref;\n  }\n\n  // The conditional operator is the lowest precedence operator (except yield,\n  // assignment operators, and commas, none of which are supported), so we\n  // start there. If it doesn't match, it 'falls through' to progressively\n  // higher precedence operators, until it eventually matches (or fails to\n  // match) a 'primary' - a literal or a reference. This way, the abstract syntax\n  // tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  return getConditional(parser);\n}\n\nfunction readExpressionList(parser, spread) {\n  var isSpread;\n  var expressions = [];\n\n  var pos = parser.pos;\n\n  do {\n    parser.sp();\n\n    if (spread) {\n      isSpread = parser.matchPattern(spreadPattern);\n    }\n\n    var expr = readExpression(parser);\n\n    if (expr === null && expressions.length) {\n      parser.error(expectedExpression);\n    } else if (expr === null) {\n      parser.pos = pos;\n      return null;\n    }\n\n    if (isSpread) {\n      expr.p = true;\n    }\n\n    expressions.push(expr);\n\n    parser.sp();\n  } while (parser.matchString(','));\n\n  return expressions;\n}\n\nfunction readExpressionOrReference(parser, expectedFollowers) {\n  var start = parser.pos;\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    // valid reference but invalid expression e.g. `{{new}}`?\n    var ref = parser.matchPattern(/^(\\w+)/);\n    if (ref) {\n      return {\n        t: REFERENCE,\n        n: ref\n      };\n    }\n\n    return null;\n  }\n\n  for (var i = 0; i < expectedFollowers.length; i += 1) {\n    if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {\n      return expression;\n    }\n  }\n\n  parser.pos = start;\n  return readReference(parser);\n}\n\nfunction flattenExpression(expression) {\n  var refs;\n  var count = 0;\n\n  extractRefs(expression, (refs = []));\n  var stringified = stringify(expression);\n\n  return {\n    r: refs,\n    s: getVars(stringified)\n  };\n\n  function getVars(expr) {\n    var vars = [];\n    for (var i = count - 1; i >= 0; i--) {\n      vars.push((\"x$\" + i));\n    }\n    return vars.length ? (\"(function(){var \" + (vars.join(',')) + \";return(\" + expr + \");})()\") : expr;\n  }\n\n  function stringify(node) {\n    if (isString(node)) {\n      return node;\n    }\n\n    switch (node.t) {\n      case BOOLEAN_LITERAL:\n      case GLOBAL:\n      case NUMBER_LITERAL:\n      case REGEXP_LITERAL:\n        return node.v;\n\n      case STRING_LITERAL:\n        return JSON.stringify(String(node.v));\n\n      case ARRAY_LITERAL:\n        if (node.m && hasSpread(node.m)) {\n          return (\"[].concat(\" + (makeSpread(node.m, '[', ']', stringify)) + \")\");\n        } else {\n          return '[' + (node.m ? node.m.map(stringify).join(',') : '') + ']';\n        }\n\n      case OBJECT_LITERAL:\n        if (node.m && hasSpread(node.m)) {\n          return (\"Object.assign({},\" + (makeSpread(node.m, '{', '}', stringifyPair)) + \")\");\n        } else {\n          return '{' + (node.m ? node.m.map(function (n) { return ((n.k) + \":\" + (stringify(n.v))); }).join(',') : '') + '}';\n        }\n\n      case PREFIX_OPERATOR:\n        return (node.s === 'typeof' ? 'typeof ' : node.s) + stringify(node.o);\n\n      case INFIX_OPERATOR:\n        return (\n          stringify(node.o[0]) +\n          (node.s.substr(0, 2) === 'in' ? ' ' + node.s + ' ' : node.s) +\n          stringify(node.o[1])\n        );\n\n      case INVOCATION:\n        if (node.o && hasSpread(node.o)) {\n          var id = count++;\n          return (\"(x$\" + id + \"=\" + (stringify(node.x)) + \").apply(x$\" + id + \",\" + (stringify({\n            t: ARRAY_LITERAL,\n            m: node.o\n          })) + \")\");\n        } else {\n          return stringify(node.x) + '(' + (node.o ? node.o.map(stringify).join(',') : '') + ')';\n        }\n\n      case BRACKETED:\n        return '(' + stringify(node.x) + ')';\n\n      case MEMBER:\n        return stringify(node.x) + stringify(node.r);\n\n      case REFINEMENT:\n        return node.n ? '.' + node.n : '[' + stringify(node.x) + ']';\n\n      case CONDITIONAL:\n        return stringify(node.o[0]) + '?' + stringify(node.o[1]) + ':' + stringify(node.o[2]);\n\n      case REFERENCE:\n        return '_' + refs.indexOf(node.n);\n\n      default:\n        throw new Error('Expected legal JavaScript');\n    }\n  }\n\n  function stringifyPair(node) {\n    return node.p ? stringify(node.k) : ((node.k) + \":\" + (stringify(node.v)));\n  }\n\n  function makeSpread(list, open, close, fn) {\n    var out = list.reduce(\n      function (a, c) {\n        if (c.p) {\n          a.str += \"\" + (a.open ? close + ',' : a.str.length ? ',' : '') + (fn(c));\n        } else {\n          a.str += \"\" + (!a.str.length ? open : !a.open ? ',' + open : ',') + (fn(c));\n        }\n        a.open = !c.p;\n        return a;\n      },\n      { open: false, str: '' }\n    );\n    if (out.open) { out.str += close; }\n    return out.str;\n  }\n}\n\nfunction hasSpread(list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].p) { return true; }\n  }\n\n  return false;\n}\n\n// TODO maybe refactor this?\nfunction extractRefs(node, refs) {\n  if (node.t === REFERENCE && isString(node.n)) {\n    if (!~refs.indexOf(node.n)) {\n      refs.unshift(node.n);\n    }\n  }\n\n  var list = node.o || node.m;\n  if (list) {\n    if (isObject(list)) {\n      extractRefs(list, refs);\n    } else {\n      var i = list.length;\n      while (i--) {\n        extractRefs(list[i], refs);\n      }\n    }\n  }\n\n  if (node.k && node.t === KEY_VALUE_PAIR && !isString(node.k)) {\n    extractRefs(node.k, refs);\n  }\n\n  if (node.x) {\n    extractRefs(node.x, refs);\n  }\n\n  if (node.r) {\n    extractRefs(node.r, refs);\n  }\n\n  if (node.v) {\n    extractRefs(node.v, refs);\n  }\n}\n\nfunction refineExpression(expression, mustache) {\n  var referenceExpression;\n\n  if (expression) {\n    while (expression.t === BRACKETED && expression.x) {\n      expression = expression.x;\n    }\n\n    if (expression.t === REFERENCE) {\n      var n = expression.n;\n      if (!~n.indexOf('@context')) {\n        mustache.r = expression.n;\n      } else {\n        mustache.x = flattenExpression(expression);\n      }\n    } else {\n      if ((referenceExpression = getReferenceExpression(expression))) {\n        mustache.rx = referenceExpression;\n      } else {\n        mustache.x = flattenExpression(expression);\n      }\n    }\n\n    return mustache;\n  }\n}\n\n// TODO refactor this! it's bewildering\nfunction getReferenceExpression(expression) {\n  var members = [];\n  var refinement;\n\n  while (expression.t === MEMBER && expression.r.t === REFINEMENT) {\n    refinement = expression.r;\n\n    if (refinement.x) {\n      if (refinement.x.t === REFERENCE) {\n        members.unshift(refinement.x);\n      } else {\n        members.unshift(flattenExpression(refinement.x));\n      }\n    } else {\n      members.unshift(refinement.n);\n    }\n\n    expression = expression.x;\n  }\n\n  if (expression.t !== REFERENCE) {\n    return null;\n  }\n\n  return {\n    r: expression.n,\n    m: members\n  };\n}\n\nvar attributeNamePattern = /^[^\\s\"'>\\/=(]+/;\nvar onPattern = /^on/;\nvar eventPattern = /^on-([a-zA-Z\\*\\.$_]((?:[a-zA-Z\\*\\.$_0-9\\-]|\\\\-)+))$/;\nvar reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|complete|unrender|detach|insert|destruct|attachchild|detachchild)$/;\nvar decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;\nvar transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;\nvar boundPattern = /^((bind|class)-(([-a-zA-Z0-9_])+))$/;\nvar directives = {\n  lazy: { t: BINDING_FLAG, v: 'l' },\n  twoway: { t: BINDING_FLAG, v: 't' },\n  'no-delegation': { t: DELEGATE_FLAG }\n};\nvar unquotedAttributeValueTextPattern = /^[^\\s\"'=<>\\/`]+/;\nvar proxyEvent = /^[^\\s\"'=<>@\\[\\]()]*/;\nvar whitespace = /^\\s+/;\n\nvar slashes = /\\\\/g;\nfunction splitEvent(str) {\n  var result = [];\n  var s = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    if (str[i] === '-' && str[i - 1] !== '\\\\') {\n      result.push(str.substring(s, i).replace(slashes, ''));\n      s = i + 1;\n    }\n  }\n\n  result.push(str.substring(s).replace(slashes, ''));\n\n  return result;\n}\n\nfunction readAttribute(parser) {\n  var name, i, nearest, idx;\n\n  parser.sp();\n\n  name = parser.matchPattern(attributeNamePattern);\n  if (!name) {\n    return null;\n  }\n\n  // check for accidental delimiter consumption e.g. <tag bool{{>attrs}} />\n  nearest = name.length;\n  for (i = 0; i < parser.tags.length; i++) {\n    if (~(idx = name.indexOf(parser.tags[i].open))) {\n      if (idx < nearest) { nearest = idx; }\n    }\n  }\n  if (nearest < name.length) {\n    parser.pos -= name.length - nearest;\n    name = name.substr(0, nearest);\n    if (!name) { return null; }\n  }\n\n  return { n: name };\n}\n\nfunction readAttributeValue(parser) {\n  var start = parser.pos;\n\n  // next character must be `=`, `/`, `>` or whitespace\n  if (!/[=\\/>\\s]/.test(parser.nextChar())) {\n    parser.error('Expected `=`, `/`, `>` or whitespace');\n  }\n\n  parser.sp();\n\n  if (!parser.matchString('=')) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.sp();\n\n  var valueStart = parser.pos;\n  var startDepth = parser.sectionDepth;\n\n  var value =\n    readQuotedAttributeValue(parser, \"'\") ||\n    readQuotedAttributeValue(parser, \"\\\"\") ||\n    readUnquotedAttributeValue(parser);\n\n  if (value === null) {\n    parser.error('Expected valid attribute value');\n  }\n\n  if (parser.sectionDepth !== startDepth) {\n    parser.pos = valueStart;\n    parser.error(\n      'An attribute value must contain as many opening section tags as closing section tags'\n    );\n  }\n\n  if (!value.length) {\n    return '';\n  } else if (value.length === 1 && isString(value[0])) {\n    return value[0];\n  }\n\n  return value;\n}\n\nfunction readUnquotedAttributeValueToken(parser) {\n  var text, index;\n\n  var start = parser.pos;\n\n  text = parser.matchPattern(unquotedAttributeValueTextPattern);\n\n  if (!text) {\n    return null;\n  }\n\n  var haystack = text;\n  var needles = parser.tags.map(function (t) { return t.open; }); // TODO refactor... we do this in readText.js as well\n\n  if ((index = getLowestIndex(haystack, needles)) !== -1) {\n    text = text.substr(0, index);\n    parser.pos = start + text.length;\n  }\n\n  return decodeCharacterReferences(text);\n}\n\nfunction readUnquotedAttributeValue(parser) {\n  parser.inAttribute = true;\n\n  var tokens = [];\n\n  var token = readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  while (token) {\n    tokens.push(token);\n    token = readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  }\n\n  if (!tokens.length) {\n    return null;\n  }\n\n  parser.inAttribute = false;\n  return tokens;\n}\n\nfunction readQuotedAttributeValue(parser, quoteMark) {\n  var start = parser.pos;\n\n  if (!parser.matchString(quoteMark)) {\n    return null;\n  }\n\n  parser.inAttribute = quoteMark;\n\n  var tokens = [];\n\n  var token = readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  while (token !== null) {\n    tokens.push(token);\n    token = readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  }\n\n  if (!parser.matchString(quoteMark)) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.inAttribute = false;\n\n  return tokens;\n}\n\nfunction readQuotedStringToken(parser, quoteMark) {\n  var haystack = parser.remaining();\n\n  var needles = parser.tags.map(function (t) { return t.open; }); // TODO refactor... we do this in readText.js as well\n  needles.push(quoteMark);\n\n  var index = getLowestIndex(haystack, needles);\n\n  if (index === -1) {\n    parser.error('Quoted attribute value must have a closing quote');\n  }\n\n  if (!index) {\n    return null;\n  }\n\n  parser.pos += index;\n  return decodeCharacterReferences(haystack.substr(0, index));\n}\n\nfunction readAttributeOrDirective(parser) {\n  var match, directive;\n\n  var attribute = readAttribute(parser, false);\n\n  if (!attribute) { return null; }\n\n  // lazy, twoway\n  if ((directive = directives[attribute.n])) {\n    attribute.t = directive.t;\n    if (directive.v) { attribute.v = directive.v; }\n    delete attribute.n; // no name necessary\n    parser.sp();\n    if (parser.nextChar() === '=') { attribute.f = readAttributeValue(parser); }\n  } else if ((match = decoratorPattern.exec(attribute.n))) {\n    // decorators\n    attribute.n = match[1];\n    attribute.t = DECORATOR;\n    readArguments(parser, attribute);\n  } else if ((match = transitionPattern.exec(attribute.n))) {\n    // transitions\n    attribute.n = match[1];\n    attribute.t = TRANSITION;\n    readArguments(parser, attribute);\n    attribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';\n  } else if ((match = eventPattern.exec(attribute.n))) {\n    // on-click etc\n    attribute.n = splitEvent(match[1]);\n    attribute.t = EVENT;\n\n    if (parser.matchString('(')) {\n      attribute.a = flattenExpression({\n        t: ARRAY_LITERAL,\n        m: readExpressionList(parser)\n      });\n      if (!parser.matchString(')')) { parser.error(\"Expected closing ')'\"); }\n    }\n\n    parser.inEvent = true;\n\n    // check for a proxy event\n    if (!readProxyEvent(parser, attribute)) {\n      // otherwise, it's an expression\n      readArguments(parser, attribute, true);\n    } else if (reservedEventNames.test(attribute.f)) {\n      parser.pos -= attribute.f.length;\n      parser.error(\n        'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, complete, detach, insert, destruct, attachchild, detachchild)'\n      );\n    }\n\n    parser.inEvent = false;\n  } else if ((match = boundPattern.exec(attribute.n))) {\n    // bound directives\n    var bind = match[2] === 'bind';\n    attribute.n = bind ? match[3] : match[1];\n    attribute.t = ATTRIBUTE;\n    readArguments(parser, attribute, false, true);\n\n    if (!attribute.f && bind) {\n      attribute.f = [{ t: INTERPOLATOR, r: match[3] }];\n    }\n  } else {\n    parser.sp();\n    var value = parser.nextChar() === '=' ? readAttributeValue(parser) : null;\n    attribute.f = value != null ? value : attribute.f;\n\n    if (parser.sanitizeEventAttributes && onPattern.test(attribute.n)) {\n      return { exclude: true };\n    } else {\n      attribute.f = attribute.f || (attribute.f === '' ? '' : 0);\n      attribute.t = ATTRIBUTE;\n    }\n  }\n\n  return attribute;\n}\n\nfunction readProxyEvent(parser, attribute) {\n  var start = parser.pos;\n  if (!parser.matchString('=')) { parser.error(\"Missing required directive arguments\"); }\n\n  var quote = parser.matchString(\"'\") || parser.matchString(\"\\\"\");\n  parser.sp();\n  var proxy = parser.matchPattern(proxyEvent);\n\n  if (proxy !== undefined) {\n    if (quote) {\n      parser.sp();\n      if (!parser.matchString(quote)) { parser.pos = start; }\n      else { return (attribute.f = proxy) || true; }\n    } else if (!parser.matchPattern(whitespace)) {\n      parser.pos = start;\n    } else {\n      return (attribute.f = proxy) || true;\n    }\n  } else {\n    parser.pos = start;\n  }\n}\n\nfunction readArguments(parser, attribute, required, single) {\n  if ( required === void 0 ) required = false;\n  if ( single === void 0 ) single = false;\n\n  parser.sp();\n  if (!parser.matchString('=')) {\n    if (required) { parser.error(\"Missing required directive arguments\"); }\n    return;\n  }\n  parser.sp();\n\n  var quote = parser.matchString('\"') || parser.matchString(\"'\");\n  var spread = parser.spreadArgs;\n  parser.spreadArgs = true;\n  parser.inUnquotedAttribute = !quote;\n  var expr = single\n    ? readExpressionOrReference(parser, [quote || ' ', '/', '>'])\n    : { m: readExpressionList(parser), t: ARRAY_LITERAL };\n  parser.inUnquotedAttribute = false;\n  parser.spreadArgs = spread;\n\n  if (quote) {\n    parser.sp();\n    if (parser.matchString(quote) !== quote) { parser.error((\"Expected matching quote '\" + quote + \"'\")); }\n  }\n\n  if (single) {\n    var interpolator = { t: INTERPOLATOR };\n    refineExpression(expr, interpolator);\n    attribute.f = [interpolator];\n  } else {\n    attribute.f = flattenExpression(expr);\n  }\n}\n\nvar delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n\nfunction readMustache(parser) {\n  var mustache, i;\n\n  // If we're inside a <script> or <style> tag, and we're not\n  // interpolating, bug out\n  if (parser.interpolate[parser.inside] === false) {\n    return null;\n  }\n\n  for (i = 0; i < parser.tags.length; i += 1) {\n    if ((mustache = readMustacheOfType(parser, parser.tags[i]))) {\n      return mustache;\n    }\n  }\n\n  if (parser.inTag && !parser.inAttribute) {\n    mustache = readAttributeOrDirective(parser);\n    if (mustache) {\n      parser.sp();\n      return mustache;\n    }\n  }\n}\n\nfunction readMustacheOfType(parser, tag) {\n  var mustache, reader, i;\n\n  var start = parser.pos;\n\n  if (parser.matchString('\\\\' + tag.open)) {\n    if (start === 0 || parser.str[start - 1] !== '\\\\') {\n      return tag.open;\n    }\n  } else if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  // delimiter change?\n  if ((mustache = readDelimiterChange(parser))) {\n    // find closing delimiter or abort...\n    if (!parser.matchString(tag.close)) {\n      return null;\n    }\n\n    // ...then make the switch\n    tag.open = mustache[0];\n    tag.close = mustache[1];\n    parser.sortMustacheTags();\n\n    return delimiterChangeToken;\n  }\n\n  parser.sp();\n\n  // illegal section closer\n  if (parser.matchString('/')) {\n    parser.pos -= 1;\n    var rewind = parser.pos;\n    if (!readNumberLiteral(parser)) {\n      parser.pos = rewind - tag.close.length;\n      if (parser.inAttribute) {\n        parser.pos = start;\n        return null;\n      } else {\n        parser.error(\"Attempted to close a section that wasn't open\");\n      }\n    } else {\n      parser.pos = rewind;\n    }\n  }\n\n  for (i = 0; i < tag.readers.length; i += 1) {\n    reader = tag.readers[i];\n\n    if ((mustache = reader(parser, tag))) {\n      if (tag.isStatic) {\n        mustache.s = 1;\n      }\n\n      if (parser.includeLinePositions) {\n        mustache.q = parser.getLinePos(start);\n      }\n\n      return mustache;\n    }\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nfunction readTriple(parser, tag) {\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    return null;\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  var triple = { t: TRIPLE };\n  refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  return triple;\n}\n\nfunction readUnescaped(parser, tag) {\n  if (!parser.matchString('&')) {\n    return null;\n  }\n\n  parser.sp();\n\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    return null;\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  var triple = { t: TRIPLE };\n  refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  return triple;\n}\n\nvar legalAlias = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\nvar asRE = /^as/i;\n\nfunction readAliases(parser) {\n  var aliases = [];\n  var alias;\n  var start = parser.pos;\n\n  parser.sp();\n\n  alias = readAlias(parser);\n\n  if (alias) {\n    alias.x = refineExpression(alias.x, {});\n    aliases.push(alias);\n\n    parser.sp();\n\n    while (parser.matchString(',')) {\n      alias = readAlias(parser);\n\n      if (!alias) {\n        parser.error('Expected another alias.');\n      }\n\n      alias.x = refineExpression(alias.x, {});\n      aliases.push(alias);\n\n      parser.sp();\n    }\n\n    return aliases;\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nfunction readAlias(parser) {\n  var start = parser.pos;\n\n  parser.sp();\n\n  var expr = readExpression(parser, []);\n\n  if (!expr) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.sp();\n  parser.matchPattern(asRE);\n  parser.sp();\n\n  var alias = parser.matchPattern(legalAlias);\n\n  if (!alias) {\n    parser.pos = start;\n    return null;\n  }\n\n  return { n: alias, x: expr };\n}\n\nfunction readPartial(parser, tag) {\n  var type = parser.matchString('>') || parser.matchString('yield');\n  var partial = { t: type === '>' ? PARTIAL : YIELDER };\n  var aliases;\n\n  if (!type) { return null; }\n\n  parser.sp();\n\n  if (type === '>' || !(aliases = parser.matchString('with'))) {\n    // Partial names can include hyphens, so we can't use readExpression\n    // blindly. Instead, we use the `relaxedNames` flag to indicate that\n    // `foo-bar` should be read as a single name, rather than 'subtract\n    // bar from foo'\n    parser.relaxedNames = parser.strictRefinement = true;\n    var expression = readExpression(parser);\n    parser.relaxedNames = parser.strictRefinement = false;\n\n    if (!expression && type === '>') { return null; }\n\n    if (expression) {\n      refineExpression(expression, partial); // TODO...\n      parser.sp();\n      if (type !== '>') { aliases = parser.matchString('with'); }\n    }\n  }\n\n  parser.sp();\n\n  // check for alias context e.g. `{{>foo bar as bat, bip as bop}}`\n  if (aliases || type === '>') {\n    aliases = readAliases(parser);\n    if (aliases && aliases.length) {\n      partial.z = aliases;\n    } else {\n      // otherwise check for literal context e.g. `{{>foo bar}}` then\n      // turn it into `{{#with bar}}{{>foo}}{{/with}}`\n      var context = readExpression(parser);\n      if (context) {\n        partial.c = {};\n        refineExpression(context, partial.c);\n      }\n\n      // allow aliases after context\n      if (parser.matchString(',')) {\n        aliases = readAliases(parser);\n        if (aliases && aliases.length) {\n          partial.z = aliases;\n        }\n      }\n    }\n\n    if (type !== '>' && (!partial.c && !partial.z)) {\n      // {{yield with}} requires some aliases\n      parser.error(\"Expected a context or one or more aliases\");\n    }\n  }\n\n  parser.sp();\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  return partial;\n}\n\nfunction readComment(parser, tag) {\n  if (!parser.matchString('!')) {\n    return null;\n  }\n\n  var index = parser.remaining().indexOf(tag.close);\n\n  if (index !== -1) {\n    parser.pos += index + tag.close.length;\n    return { t: COMMENT };\n  }\n}\n\nfunction readInterpolator(parser, tag) {\n  var expression, err;\n\n  var start = parser.pos;\n\n  // TODO would be good for perf if we could do away with the try-catch\n  try {\n    expression = readExpressionOrReference(parser, [tag.close]);\n  } catch (e) {\n    err = e;\n  }\n\n  if (!expression) {\n    if (parser.str.charAt(start) === '!') {\n      // special case - comment\n      parser.pos = start;\n      return null;\n    }\n\n    if (err) {\n      throw err;\n    }\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"' after reference\"));\n\n    if (!expression) {\n      // special case - comment\n      if (parser.nextChar() === '!') {\n        return null;\n      }\n\n      parser.error(\"Expected expression or legal reference\");\n    }\n  }\n\n  var interpolator = { t: INTERPOLATOR };\n  refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious\n\n  return interpolator;\n}\n\nfunction readClosing(parser, tag) {\n  var start = parser.pos;\n\n  if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  parser.sp();\n\n  if (!parser.matchString('/')) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.sp();\n\n  var remaining = parser.remaining();\n  var index = remaining.indexOf(tag.close);\n\n  if (index !== -1) {\n    var closing = {\n      t: CLOSING,\n      r: remaining.substr(0, index).split(' ')[0]\n    };\n\n    parser.pos += index;\n\n    if (!parser.matchString(tag.close)) {\n      parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n    }\n\n    return closing;\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nvar patterns = {\n  else: /^\\s*else\\s*/,\n  elseif: /^\\s*elseif\\s+/,\n  then: /^\\s*then\\s*/,\n  catch: /^\\s*catch\\s*/\n};\n\nvar types = {\n  else: ELSE,\n  elseif: ELSEIF,\n  then: THEN,\n  catch: CATCH\n};\n\nfunction readInlineBlock(parser, tag, type) {\n  var start = parser.pos;\n\n  if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  if (!parser.matchPattern(patterns[type])) {\n    parser.pos = start;\n    return null;\n  }\n\n  var res = { t: types[type] };\n\n  if (type === 'elseif') {\n    res.x = readExpression(parser);\n  } else if (type === 'catch' || type === 'then') {\n    var nm = parser.matchPattern(name);\n    if (nm) { res.n = nm; }\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  return res;\n}\n\nvar handlebarsBlockCodes = {\n  each: SECTION_EACH,\n  if: SECTION_IF,\n  with: SECTION_IF_WITH,\n  unless: SECTION_UNLESS\n};\n\nvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\nvar keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\nvar handlebarsBlockPattern = new RegExp('^(' + keys(handlebarsBlockCodes).join('|') + ')\\\\b');\n\nfunction readSection(parser, tag) {\n  var expression,\n    section,\n    child,\n    children,\n    hasElse,\n    block,\n    unlessBlock,\n    closed,\n    i,\n    expectedClose,\n    hasThen,\n    hasCatch,\n    inlineThen;\n  var aliasOnly = false;\n\n  var start = parser.pos;\n\n  if (parser.matchString('^')) {\n    // watch out for parent context refs - {{^^/^^/foo}}\n    if (parser.matchString('^/')) {\n      parser.pos = start;\n      return null;\n    }\n    section = { t: SECTION, f: [], n: SECTION_UNLESS };\n  } else if (parser.matchString('#')) {\n    section = { t: SECTION, f: [] };\n\n    if (parser.matchString('partial')) {\n      parser.pos = start - parser.standardDelimiters[0].length;\n      parser.error(\n        'Partial definitions can only be at the top level of the template, or immediately inside components'\n      );\n    }\n\n    if ((block = parser.matchString('await'))) {\n      expectedClose = block;\n      section.t = AWAIT;\n    } else if ((block = parser.matchPattern(handlebarsBlockPattern))) {\n      expectedClose = block;\n      section.n = handlebarsBlockCodes[block];\n    }\n  } else {\n    return null;\n  }\n\n  parser.sp();\n\n  if (block === 'with') {\n    var aliases = readAliases(parser);\n    if (aliases) {\n      aliasOnly = true;\n      section.z = aliases;\n      section.t = ALIAS;\n    }\n  } else if (block === 'each') {\n    var alias = readAlias(parser);\n    if (alias) {\n      section.z = [{ n: alias.n, x: { r: '.' } }];\n      expression = alias.x;\n    }\n  }\n\n  if (!aliasOnly) {\n    if (!expression) { expression = readExpression(parser); }\n\n    if (!expression) {\n      parser.error('Expected expression');\n    }\n\n    // extra each aliases\n    if (block === 'each' && parser.matchString(',')) {\n      var aliases$1 = readAliases(parser);\n      if (aliases$1) {\n        if (section.z) { aliases$1.unshift(section.z[0]); }\n        section.z = aliases$1;\n      }\n    }\n\n    // optional index and key references\n    if ((block === 'each' || !block) && (i = parser.matchPattern(indexRefPattern))) {\n      var extra;\n\n      if ((extra = parser.matchPattern(keyIndexRefPattern))) {\n        section.i = i + ',' + extra;\n      } else {\n        section.i = i;\n      }\n    } else if (block === 'await' && parser.matchString('then')) {\n      parser.sp();\n      hasThen = true;\n      inlineThen = parser.matchPattern(name);\n      if (!inlineThen) { inlineThen = true; }\n    }\n\n    if (!block && expression.n) {\n      expectedClose = expression.n;\n    }\n  }\n\n  parser.sp();\n\n  if (parser.matchString('-')) { section.w = 1; }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  parser.sectionDepth += 1;\n  children = section.f;\n\n  var pos;\n  do {\n    pos = parser.pos;\n    if ((child = readClosing(parser, tag))) {\n      if (expectedClose && child.r !== expectedClose) {\n        if (!block) {\n          if (child.r)\n            { parser.warn(\n              (\"Expected \" + (tag.open) + \"/\" + expectedClose + (tag.close) + \" but found \" + (tag.open) + \"/\" + (child.r) + (tag.close))\n            ); }\n        } else {\n          parser.pos = pos;\n          parser.error((\"Expected \" + (tag.open) + \"/\" + expectedClose + (tag.close)));\n        }\n      }\n\n      parser.sectionDepth -= 1;\n      closed = true;\n    } else if (\n      !aliasOnly &&\n      ((child = readInlineBlock(parser, tag, 'elseif')) ||\n        (child = readInlineBlock(parser, tag, 'else')) ||\n        (block === 'await' &&\n          ((child = readInlineBlock(parser, tag, 'then')) ||\n            (child = readInlineBlock(parser, tag, 'catch')))))\n    ) {\n      if (section.n === SECTION_UNLESS) {\n        parser.error('{{else}} not allowed in {{#unless}}');\n      }\n\n      if (hasElse) {\n        if (child.t === ELSE) {\n          parser.error('there can only be one {{else}} block, at the end of a section');\n        } else if (child.t === ELSEIF) {\n          parser.error('illegal {{elseif...}} after {{else}}');\n        }\n      }\n\n      if (!unlessBlock && (inlineThen || !hasThen) && !hasCatch) {\n        if (block === 'await') {\n          var s = { f: children };\n          section.f = [s];\n          if (inlineThen) {\n            s.t = THEN;\n            inlineThen !== true && (s.n = inlineThen);\n          } else {\n            s.t = SECTION;\n          }\n        } else {\n          unlessBlock = [];\n        }\n      }\n\n      var mustache = {\n        t: SECTION,\n        f: (children = [])\n      };\n\n      if (child.t === ELSE) {\n        if (block === 'await') {\n          section.f.push(mustache);\n          mustache.t = ELSE;\n        } else {\n          mustache.n = SECTION_UNLESS;\n          unlessBlock.push(mustache);\n        }\n        hasElse = true;\n      } else if (child.t === ELSEIF) {\n        mustache.n = SECTION_IF;\n        refineExpression(child.x, mustache);\n        unlessBlock.push(mustache);\n      } else if (child.t === THEN) {\n        if (hasElse) { parser.error('{{then}} block must appear before any {{else}} block'); }\n        if (hasCatch) { parser.error('{{then}} block must appear before any {{catch}} block'); }\n        if (hasThen) { parser.error('there can only be one {{then}} block per {{#await}}'); }\n        mustache.t = THEN;\n        hasThen = true;\n        child.n && (mustache.n = child.n);\n        section.f.push(mustache);\n      } else if (child.t === CATCH) {\n        if (hasElse) { parser.error('{{catch}} block must appear before any {{else}} block'); }\n        if (hasCatch) { parser.error('there can only be one {{catch}} block per {{#await}}'); }\n        mustache.t = CATCH;\n        hasCatch = true;\n        mustache.n = child.n;\n        section.f.push(mustache);\n      }\n    } else {\n      child = parser.read(READERS);\n\n      if (!child) {\n        break;\n      }\n\n      children.push(child);\n    }\n  } while (!closed);\n\n  if (unlessBlock) {\n    section.l = unlessBlock;\n  }\n\n  if (!aliasOnly) {\n    refineExpression(expression, section);\n  }\n\n  if (block === 'await' && (inlineThen || !hasThen) && !hasCatch && !hasElse) {\n    var s$1 = { f: section.f };\n    section.f = [s$1];\n    if (inlineThen) {\n      s$1.t = THEN;\n      inlineThen !== true && (s$1.n = inlineThen);\n    } else {\n      s$1.t = SECTION;\n    }\n  }\n\n  // TODO if a section is empty it should be discarded. Don't do\n  // that here though - we need to clean everything up first, as\n  // it may contain removeable whitespace. As a temporary measure,\n  // to pass the existing tests, remove empty `f` arrays\n  if (!section.f.length) {\n    delete section.f;\n  }\n\n  return section;\n}\n\nvar OPEN_COMMENT = '<!--';\nvar CLOSE_COMMENT = '-->';\n\nfunction readHtmlComment(parser) {\n  var start = parser.pos;\n\n  if (parser.textOnlyMode || !parser.matchString(OPEN_COMMENT)) {\n    return null;\n  }\n\n  var remaining = parser.remaining();\n  var endIndex = remaining.indexOf(CLOSE_COMMENT);\n\n  if (endIndex === -1) {\n    parser.error(\"Illegal HTML - expected closing comment sequence ('-->')\");\n  }\n\n  var content = remaining.substr(0, endIndex);\n  parser.pos += endIndex + 3;\n\n  var comment = {\n    t: COMMENT,\n    c: content\n  };\n\n  if (parser.includeLinePositions) {\n    comment.q = parser.getLinePos(start);\n  }\n\n  return comment;\n}\n\nvar leadingLinebreak = /^[ \\t\\f\\r\\n]*\\r?\\n/;\nvar trailingLinebreak = /\\r?\\n[ \\t\\f\\r\\n]*$/;\n\nfunction stripStandalones(items, preserveStandaloneSections) {\n  var i, current, backOne, backTwo, lastSectionItem;\n\n  for (i = 1; i < items.length; i += 1) {\n    current = items[i];\n    backOne = items[i - 1];\n    backTwo = items[i - 2];\n\n    // if we're at the end of a [text][comment][text] sequence...\n    if (isString(current) && isComment(backOne) && isString(backTwo)) {\n      // ... and the comment is a standalone (i.e. line breaks either side)...\n      if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {\n        // ... then we want to remove the whitespace after the first line break\n        items[i - 2] = backTwo.replace(trailingLinebreak, '\\n');\n\n        // and the leading line break of the second text token\n        items[i] = current.replace(leadingLinebreak, '');\n      }\n    }\n\n    if (!preserveStandaloneSections) {\n      // if the current item is a section, and it is preceded by a linebreak, and\n      // its first item is a linebreak...\n      if (isSection(current) && isString(backOne)) {\n        if (\n          trailingLinebreak.test(backOne) &&\n          isString(current.f[0]) &&\n          leadingLinebreak.test(current.f[0])\n        ) {\n          items[i - 1] = backOne.replace(trailingLinebreak, '\\n');\n          current.f[0] = current.f[0].replace(leadingLinebreak, '');\n        }\n      }\n\n      // if the last item was a section, and it is followed by a linebreak, and\n      // its last item is a linebreak...\n      if (isString(current) && isSection(backOne)) {\n        lastSectionItem = lastItem(backOne.f);\n\n        if (\n          isString(lastSectionItem) &&\n          trailingLinebreak.test(lastSectionItem) &&\n          leadingLinebreak.test(current)\n        ) {\n          backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, '\\n');\n          items[i] = current.replace(leadingLinebreak, '');\n        }\n      }\n    }\n  }\n\n  return items;\n}\n\nfunction isComment(item) {\n  return item.t === COMMENT || item.t === DELIMCHANGE;\n}\n\nfunction isSection(item) {\n  return (item.t === SECTION || item.t === INVERTED) && item.f;\n}\n\nfunction trimWhitespace(items, leadingPattern, trailingPattern) {\n  var item;\n\n  if (leadingPattern) {\n    item = items[0];\n    if (isString(item)) {\n      item = item.replace(leadingPattern, '');\n\n      if (!item) {\n        items.shift();\n      } else {\n        items[0] = item;\n      }\n    }\n  }\n\n  if (trailingPattern) {\n    item = lastItem(items);\n    if (isString(item)) {\n      item = item.replace(trailingPattern, '');\n\n      if (!item) {\n        items.pop();\n      } else {\n        items[items.length - 1] = item;\n      }\n    }\n  }\n}\n\nvar contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\nvar leadingWhitespace$1 = /^[ \\t\\f\\r\\n]+/;\nvar trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\nvar leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\nvar trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\nvar trailingIndent = /(\\n)?[ \\t]*$/;\nvar leadingLine = /[ \\t]*\\n/;\n\nfunction cleanup(\n  items,\n  stripComments,\n  preserveWhitespace,\n  removeLeadingWhitespace,\n  removeTrailingWhitespace,\n  whiteSpaceElements,\n  preserveStandaloneSections\n) {\n  if (isString(items)) { return; }\n\n  var i,\n    item,\n    previousItem,\n    nextItem,\n    preserveWhitespaceInsideFragment,\n    removeLeadingWhitespaceInsideFragment,\n    removeTrailingWhitespaceInsideFragment;\n\n  // First pass - remove standalones and comments etc\n  stripStandalones(items, preserveStandaloneSections);\n\n  i = items.length;\n  while (i--) {\n    item = items[i];\n\n    // Remove delimiter changes, unsafe elements etc\n    if (item.exclude) {\n      items.splice(i, 1);\n    } else if (stripComments && item.t === COMMENT) {\n      // Remove comments, unless we want to keep them\n      items.splice(i, 1);\n    }\n  }\n\n  // If necessary, remove leading and trailing whitespace\n  trimWhitespace(\n    items,\n    removeLeadingWhitespace ? leadingWhitespace$1 : null,\n    removeTrailingWhitespace ? trailingWhitespace : null\n  );\n\n  i = items.length;\n  while (i--) {\n    item = items[i];\n    removeLeadingWhitespaceInsideFragment = removeTrailingWhitespaceInsideFragment = false;\n\n    if (item.w) {\n      var prev = items[i - 1];\n      var hitLast = true;\n      if (typeof prev === 'string') { items[i - 1] = prev.replace(trailingIndent, '$1'); }\n      if (item.f) {\n        if (typeof item.f[0] === 'string') { item.f[0] = item.f[0].replace(leadingLine, ''); }\n        var last = item.f.length - 1;\n        if (typeof item.f[last] === 'string') {\n          item.f[last] = item.f[last].replace(trailingIndent, function (_m, str) {\n            hitLast = str;\n            return str || '';\n          });\n        }\n      }\n      var next = items[i + 1];\n      if (hitLast && typeof next === 'string') { items[i + 1] = next.replace(leadingLine, ''); }\n    }\n\n    // Recurse\n    if (item.f) {\n      var isPreserveWhitespaceElement =\n        item.t === ELEMENT &&\n        (whiteSpaceElements[item.e.toLowerCase()] || whiteSpaceElements[item.e]);\n      preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n      if (!preserveWhitespace && isPreserveWhitespaceElement) {\n        trimWhitespace(item.f, leadingNewLine, trailingNewLine);\n      }\n\n      if (!preserveWhitespaceInsideFragment) {\n        previousItem = items[i - 1];\n        nextItem = items[i + 1];\n\n        // if the previous item was a text item with trailing whitespace,\n        // remove leading whitespace inside the fragment\n        if (!previousItem || (isString(previousItem) && trailingWhitespace.test(previousItem))) {\n          removeLeadingWhitespaceInsideFragment = true;\n        }\n\n        // and vice versa\n        if (!nextItem || (isString(nextItem) && leadingWhitespace$1.test(nextItem))) {\n          removeTrailingWhitespaceInsideFragment = true;\n        }\n      }\n\n      cleanup(\n        item.f,\n        stripComments,\n        preserveWhitespaceInsideFragment,\n        removeLeadingWhitespaceInsideFragment,\n        removeTrailingWhitespaceInsideFragment,\n        whiteSpaceElements\n      );\n    }\n\n    // Split if-else blocks into two (an if, and an unless)\n    if (item.l) {\n      if (item.w) { item.l.forEach(function (l) { return (l.w = 1); }); }\n      cleanup(\n        item.l,\n        stripComments,\n        preserveWhitespace,\n        removeLeadingWhitespaceInsideFragment,\n        removeTrailingWhitespaceInsideFragment,\n        whiteSpaceElements\n      );\n\n      item.l.forEach(function (s) { return (s.l = 1); });\n      item.l.unshift(i + 1, 0);\n      items.splice.apply(items, item.l);\n      delete item.l; // TODO would be nice if there was a way around this\n    }\n\n    // Clean up conditional attributes\n    if (item.m) {\n      cleanup(\n        item.m,\n        stripComments,\n        preserveWhitespace,\n        removeLeadingWhitespaceInsideFragment,\n        removeTrailingWhitespaceInsideFragment,\n        whiteSpaceElements\n      );\n      if (item.m.length < 1) { delete item.m; }\n    }\n\n    delete item.w;\n  }\n\n  // final pass - fuse text nodes together\n  i = items.length;\n  while (i--) {\n    if (isString(items[i])) {\n      if (isString(items[i + 1])) {\n        items[i] = items[i] + items[i + 1];\n        items.splice(i + 1, 1);\n      }\n\n      if (!preserveWhitespace) {\n        items[i] = items[i].replace(contiguousWhitespace, ' ');\n      }\n\n      if (items[i] === '') {\n        items.splice(i, 1);\n      }\n    }\n  }\n}\n\nvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\nfunction readClosingTag(parser) {\n  var tag;\n\n  var start = parser.pos;\n\n  // are we looking at a closing tag?\n  if (!parser.matchString('</')) {\n    return null;\n  }\n\n  if ((tag = parser.matchPattern(closingTagPattern))) {\n    if (parser.inside && tag !== parser.inside) {\n      parser.pos = start;\n      return null;\n    }\n\n    return {\n      t: CLOSING_TAG,\n      e: tag\n    };\n  }\n\n  // We have an illegal closing tag, report it\n  parser.pos -= 2;\n  parser.error('Illegal closing tag');\n}\n\nfunction hyphenateCamel(camelCaseStr) {\n  return camelCaseStr.replace(/([A-Z])/g, function (match, $1) {\n    return '-' + $1.toLowerCase();\n  });\n}\n\nvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/;\nvar anchorPattern = /^[a-zA-Z_$][-a-zA-Z0-9_$]*/;\nvar validTagNameFollower = /^[\\s\\n\\/>]/;\nvar semiEnd = /;\\s*$/;\nvar exclude = { exclude: true };\n\n// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\nvar disallowedContents = {\n  li: ['li'],\n  dt: ['dt', 'dd'],\n  dd: ['dt', 'dd'],\n  p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split(\n    ' '\n  ),\n  rt: ['rt', 'rp'],\n  rp: ['rt', 'rp'],\n  optgroup: ['optgroup'],\n  option: ['option', 'optgroup'],\n  thead: ['tbody', 'tfoot'],\n  tbody: ['tbody', 'tfoot'],\n  tfoot: ['tbody'],\n  tr: ['tr', 'tbody'],\n  td: ['td', 'th', 'tr'],\n  th: ['td', 'th', 'tr']\n};\n\nfunction readElement$1(parser) {\n  var attribute,\n    selfClosing,\n    children,\n    partials,\n    hasPartials,\n    child,\n    closed,\n    pos,\n    remaining,\n    closingTag,\n    anchor;\n\n  var start = parser.pos;\n\n  if (parser.inside || parser.inAttribute || parser.textOnlyMode) {\n    return null;\n  }\n\n  if (!parser.matchString('<')) {\n    return null;\n  }\n\n  // if this is a closing tag, abort straight away\n  if (parser.nextChar() === '/') {\n    return null;\n  }\n\n  var element = {};\n  if (parser.includeLinePositions) {\n    element.q = parser.getLinePos(start);\n  }\n\n  // check for doctype decl\n  if (parser.matchString('!')) {\n    element.t = DOCTYPE;\n    if (!parser.matchPattern(/^doctype/i)) {\n      parser.error('Expected DOCTYPE declaration');\n    }\n\n    element.a = parser.matchPattern(/^(.+?)>/);\n    return element;\n  } else if ((anchor = parser.matchString('#'))) {\n    // check for anchor\n    parser.sp();\n    element.t = ANCHOR;\n    element.n = parser.matchPattern(anchorPattern);\n  } else {\n    // otherwise, it's an element/component\n    element.t = ELEMENT;\n\n    // element name\n    element.e = parser.matchPattern(tagNamePattern);\n    if (!element.e) {\n      return null;\n    }\n  }\n\n  // next character must be whitespace, closing solidus or '>'\n  if (!validTagNameFollower.test(parser.nextChar())) {\n    parser.error('Illegal tag name');\n  }\n\n  parser.sp();\n\n  parser.inTag = true;\n\n  // directives and attributes\n  while ((attribute = readMustache(parser))) {\n    if (attribute !== false) {\n      if (!element.m) { element.m = []; }\n      element.m.push(attribute);\n    }\n\n    parser.sp();\n  }\n\n  parser.inTag = false;\n\n  // allow whitespace before closing solidus\n  parser.sp();\n\n  // self-closing solidus?\n  if (parser.matchString('/')) {\n    selfClosing = true;\n  }\n\n  // closing angle bracket\n  if (!parser.matchString('>')) {\n    return null;\n  }\n\n  var lowerCaseName = (element.e || element.n).toLowerCase();\n  var preserveWhitespace = parser.preserveWhitespace;\n\n  if (!selfClosing && (anchor || !voidElements[element.e.toLowerCase()])) {\n    if (!anchor) {\n      parser.elementStack.push(lowerCaseName);\n\n      // Special case - if we open a script element, further tags should\n      // be ignored unless they're a closing script element\n      if (lowerCaseName in parser.interpolate) {\n        parser.inside = lowerCaseName;\n      }\n    }\n\n    children = [];\n    partials = create(null);\n\n    do {\n      pos = parser.pos;\n      remaining = parser.remaining();\n\n      if (!remaining) {\n        // if this happens to be a script tag and there's no content left, it's because\n        // a closing script tag can't appear in a script\n        if (parser.inside === 'script') {\n          closed = true;\n          break;\n        }\n\n        parser.error(\n          (\"Missing end \" + (parser.elementStack.length > 1 ? 'tags' : 'tag') + \" (\" + (parser.elementStack\n            .reverse()\n            .map(function (x) { return (\"</\" + x + \">\"); })\n            .join('')) + \")\")\n        );\n      }\n\n      // if for example we're in an <li> element, and we see another\n      // <li> tag, close the first so they become siblings\n      if (!anchor && !canContain(lowerCaseName, remaining)) {\n        closed = true;\n      } else if (!anchor && (closingTag = readClosingTag(parser))) {\n        // closing tag\n        closed = true;\n\n        var closingTagName = closingTag.e.toLowerCase();\n\n        // if this *isn't* the closing tag for the current element...\n        if (closingTagName !== lowerCaseName) {\n          // rewind parser\n          parser.pos = pos;\n\n          // if it doesn't close a parent tag, error\n          if (!~parser.elementStack.indexOf(closingTagName)) {\n            var errorMessage = 'Unexpected closing tag';\n\n            // add additional help for void elements, since component names\n            // might clash with them\n            if (voidElements[closingTagName.toLowerCase()]) {\n              errorMessage += \" (<\" + closingTagName + \"> is a void element - it cannot contain children)\";\n            }\n\n            parser.error(errorMessage);\n          }\n        }\n      } else if (anchor && readAnchorClose(parser, element.n)) {\n        closed = true;\n      } else {\n        // implicit close by closing section tag. TODO clean this up\n        var tag = {\n          open: parser.standardDelimiters[0],\n          close: parser.standardDelimiters[1]\n        };\n        if (readClosing(parser, tag) || readInline(parser, tag)) {\n          closed = true;\n          parser.pos = pos;\n        } else if ((child = parser.read(PARTIAL_READERS))) {\n          if (partials[child.n]) {\n            parser.pos = pos;\n            parser.error('Duplicate partial definition');\n          }\n\n          cleanup(\n            child.f,\n            parser.stripComments,\n            preserveWhitespace,\n            !preserveWhitespace,\n            !preserveWhitespace,\n            parser.whiteSpaceElements\n          );\n\n          partials[child.n] = child.f;\n          hasPartials = true;\n        } else {\n          if ((child = parser.read(READERS))) {\n            children.push(child);\n          } else {\n            closed = true;\n          }\n        }\n      }\n    } while (!closed);\n\n    if (children.length) {\n      element.f = children;\n    }\n\n    if (hasPartials) {\n      element.p = partials;\n    }\n\n    parser.elementStack.pop();\n  }\n\n  parser.inside = null;\n\n  if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {\n    return exclude;\n  }\n\n  if (\n    element.m &&\n    lowerCaseName !== 'input' &&\n    lowerCaseName !== 'select' &&\n    lowerCaseName !== 'textarea' &&\n    lowerCaseName !== 'option'\n  ) {\n    var attrs = element.m;\n    var classes, styles, cls, style;\n    var i = 0;\n    var a;\n    while (i < attrs.length) {\n      a = attrs[i];\n\n      if (a.t !== ATTRIBUTE) {\n        i++;\n        continue;\n      }\n\n      if (a.n.indexOf('class-') === 0 && !a.f) {\n        // static class directives\n        (classes || (classes = [])).push(a.n.slice(6));\n        attrs.splice(i, 1);\n      } else if (a.n.indexOf('style-') === 0 && isString(a.f)) {\n        // static style directives\n        (styles || (styles = [])).push(((hyphenateCamel(a.n.slice(6))) + \": \" + (a.f) + \";\"));\n        attrs.splice(i, 1);\n      } else if (a.n === 'class' && isString(a.f)) {\n        // static class attrs\n        (classes || (classes = [])).push(a.f);\n        attrs.splice(i, 1);\n      } else if (a.n === 'style' && isString(a.f)) {\n        // static style attrs\n        (styles || (styles = [])).push(a.f + (semiEnd.test(a.f) ? '' : ';'));\n        attrs.splice(i, 1);\n      } else if (a.n === 'class') {\n        cls = a;\n        i++;\n      } else if (a.n === 'style') {\n        style = a;\n        i++;\n      } else if (\n        !~a.n.indexOf(':') &&\n        a.n !== 'value' &&\n        a.n !== 'contenteditable' &&\n        isString(a.f)\n      ) {\n        a.g = 1;\n        i++;\n      } else {\n        i++;\n      }\n    }\n\n    if (classes) {\n      if (!cls || !isString(cls.f))\n        { attrs.unshift({ t: ATTRIBUTE, n: 'class', f: classes.join(' '), g: 1 }); }\n      else { cls.f += ' ' + classes.join(' '); }\n    } else if (cls && isString(cls.f)) { cls.g = 1; }\n\n    if (styles) {\n      if (!style || !isString(style.f))\n        { attrs.unshift({ t: ATTRIBUTE, n: 'style', f: styles.join(' '), g: 1 }); }\n      else { style.f += '; ' + styles.join(' '); }\n    } else if (style && isString(style.f)) { style.g = 1; }\n  }\n\n  return element;\n}\n\nfunction canContain(name, remaining) {\n  var match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);\n  var disallowed = disallowedContents[name];\n\n  if (!match || !disallowed) {\n    return true;\n  }\n\n  return !~disallowed.indexOf(match[1].toLowerCase());\n}\n\nfunction readAnchorClose(parser, name) {\n  var pos = parser.pos;\n  if (!parser.matchString('</')) {\n    return null;\n  }\n\n  parser.matchString('#');\n  parser.sp();\n\n  if (!parser.matchString(name)) {\n    parser.pos = pos;\n    return null;\n  }\n\n  parser.sp();\n\n  if (!parser.matchString('>')) {\n    parser.pos = pos;\n    return null;\n  }\n\n  return true;\n}\n\nvar inlines = /^\\s*(elseif|else|then|catch)\\s*/;\nfunction readInline(parser, tag) {\n  var pos = parser.pos;\n  if (!parser.matchString(tag.open)) { return; }\n  if (parser.matchPattern(inlines)) {\n    return true;\n  } else {\n    parser.pos = pos;\n  }\n}\n\nfunction readText(parser) {\n  var index, disallowed, barrier;\n\n  var remaining = parser.remaining();\n\n  if (parser.textOnlyMode) {\n    disallowed = parser.tags.map(function (t) { return t.open; });\n    disallowed = disallowed.concat(parser.tags.map(function (t) { return '\\\\' + t.open; }));\n\n    index = getLowestIndex(remaining, disallowed);\n  } else {\n    barrier = parser.inside ? '</' + parser.inside : '<';\n\n    if (parser.inside && !parser.interpolate[parser.inside]) {\n      index = remaining.indexOf(barrier);\n    } else {\n      disallowed = parser.tags.map(function (t) { return t.open; });\n      disallowed = disallowed.concat(parser.tags.map(function (t) { return '\\\\' + t.open; }));\n\n      // http://developers.whatwg.org/syntax.html#syntax-attributes\n      if (parser.inAttribute === true) {\n        // we're inside an unquoted attribute value\n        disallowed.push(\"\\\"\", \"'\", \"=\", \"<\", \">\", '`');\n      } else if (parser.inAttribute) {\n        // quoted attribute value\n        disallowed.push(parser.inAttribute);\n      } else {\n        disallowed.push(barrier);\n      }\n\n      index = getLowestIndex(remaining, disallowed);\n    }\n  }\n\n  if (!index) {\n    return null;\n  }\n\n  if (index === -1) {\n    index = remaining.length;\n  }\n\n  parser.pos += index;\n\n  if ((parser.inside && parser.inside !== 'textarea') || parser.textOnlyMode) {\n    return remaining.substr(0, index);\n  } else {\n    return decodeCharacterReferences(remaining.substr(0, index));\n  }\n}\n\nvar partialDefinitionSectionPattern = /^\\s*#\\s*partial\\s+/;\n\nfunction readPartialDefinitionSection(parser) {\n  var child, closed;\n\n  var start = parser.pos;\n\n  var delimiters = parser.standardDelimiters;\n\n  if (!parser.matchString(delimiters[0])) {\n    return null;\n  }\n\n  if (!parser.matchPattern(partialDefinitionSectionPattern)) {\n    parser.pos = start;\n    return null;\n  }\n\n  var name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-\\/]*/);\n\n  if (!name) {\n    parser.error('expected legal partial name');\n  }\n\n  parser.sp();\n  if (!parser.matchString(delimiters[1])) {\n    parser.error((\"Expected closing delimiter '\" + (delimiters[1]) + \"'\"));\n  }\n\n  var content = [];\n\n  var open = delimiters[0];\n  var close = delimiters[1];\n\n  do {\n    if ((child = readClosing(parser, { open: open, close: close }))) {\n      if (child.r !== 'partial') {\n        parser.error((\"Expected \" + open + \"/partial\" + close));\n      }\n\n      closed = true;\n    } else {\n      child = parser.read(READERS);\n\n      if (!child) {\n        parser.error((\"Expected \" + open + \"/partial\" + close));\n      }\n\n      content.push(child);\n    }\n  } while (!closed);\n\n  return {\n    t: INLINE_PARTIAL,\n    n: name,\n    f: content\n  };\n}\n\nfunction readTemplate(parser) {\n  var fragment = [];\n  var partials = create(null);\n  var hasPartials = false;\n\n  var preserveWhitespace = parser.preserveWhitespace;\n\n  while (parser.pos < parser.str.length) {\n    var pos = parser.pos;\n    var item = (void 0), partial = (void 0);\n\n    if ((partial = parser.read(PARTIAL_READERS))) {\n      if (partials[partial.n]) {\n        parser.pos = pos;\n        parser.error('Duplicated partial definition');\n      }\n\n      cleanup(\n        partial.f,\n        parser.stripComments,\n        preserveWhitespace,\n        !preserveWhitespace,\n        !preserveWhitespace,\n        parser.whiteSpaceElements\n      );\n\n      partials[partial.n] = partial.f;\n      hasPartials = true;\n    } else if ((item = parser.read(READERS))) {\n      fragment.push(item);\n    } else {\n      parser.error('Unexpected template content');\n    }\n  }\n\n  var result = {\n    v: TEMPLATE_VERSION,\n    t: fragment\n  };\n\n  if (hasPartials) {\n    result.p = partials;\n  }\n\n  return result;\n}\n\nfunction insertExpressions(obj, expr) {\n  keys(obj).forEach(function (key) {\n    if (isExpression(key, obj)) { return addTo(obj, expr); }\n\n    var ref = obj[key];\n    if (hasChildren(ref)) { insertExpressions(ref, expr); }\n  });\n}\n\nfunction isExpression(key, obj) {\n  return key === 's' && isArray(obj.r);\n}\n\nfunction addTo(obj, expr) {\n  var s = obj.s;\n  var r = obj.r;\n  if (!expr[s]) { expr[s] = fromExpression(s, r.length); }\n}\n\nfunction hasChildren(ref) {\n  return isArray(ref) || isObject(ref);\n}\n\nvar shared = {};\n\n// See https://github.com/ractivejs/template-spec for information\n// about the Ractive template specification\n\nvar STANDARD_READERS = [\n  readPartial,\n  readUnescaped,\n  readSection,\n  readInterpolator,\n  readComment\n];\nvar TRIPLE_READERS = [readTriple];\n\nvar READERS = [readMustache, readHtmlComment, readElement$1, readText];\nvar PARTIAL_READERS = [readPartialDefinitionSection];\n\nvar preserveWhitespaceElements = { pre: 1, script: 1, style: 1, textarea: 1 };\n\nvar defaultInterpolate = { textarea: true, script: true, style: true, template: true };\n\nvar StandardParser = Parser.extend({\n  init: function init(str, options) {\n    var tripleDelimiters = options.tripleDelimiters || shared.defaults.tripleDelimiters;\n    var staticDelimiters = options.staticDelimiters || shared.defaults.staticDelimiters;\n    var staticTripleDelimiters =\n      options.staticTripleDelimiters || shared.defaults.staticTripleDelimiters;\n\n    this.standardDelimiters = options.delimiters || shared.defaults.delimiters;\n\n    this.tags = [\n      {\n        isStatic: false,\n        isTriple: false,\n        open: this.standardDelimiters[0],\n        close: this.standardDelimiters[1],\n        readers: STANDARD_READERS\n      },\n      {\n        isStatic: false,\n        isTriple: true,\n        open: tripleDelimiters[0],\n        close: tripleDelimiters[1],\n        readers: TRIPLE_READERS\n      },\n      {\n        isStatic: true,\n        isTriple: false,\n        open: staticDelimiters[0],\n        close: staticDelimiters[1],\n        readers: STANDARD_READERS\n      },\n      {\n        isStatic: true,\n        isTriple: true,\n        open: staticTripleDelimiters[0],\n        close: staticTripleDelimiters[1],\n        readers: TRIPLE_READERS\n      }\n    ];\n\n    this.contextLines = options.contextLines || shared.defaults.contextLines;\n\n    this.sortMustacheTags();\n\n    this.sectionDepth = 0;\n    this.elementStack = [];\n\n    this.interpolate = assign(\n      {},\n      defaultInterpolate,\n      shared.defaults.interpolate,\n      options.interpolate\n    );\n\n    if (options.sanitize === true) {\n      options.sanitize = {\n        // blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n        elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split(\n          ' '\n        ),\n        eventAttributes: true\n      };\n    }\n\n    this.stripComments = options.stripComments !== false;\n    this.preserveWhitespace = isObjectType(options.preserveWhitespace)\n      ? false\n      : options.preserveWhitespace;\n    this.sanitizeElements = options.sanitize && options.sanitize.elements;\n    this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n    this.includeLinePositions = options.includeLinePositions;\n    this.textOnlyMode = options.textOnlyMode;\n    this.csp = options.csp;\n    this.allowExpressions = options.allowExpressions;\n\n    this.preserveStandaloneSections = this.preserveWhitespace && options.preserveStandaloneSections;\n\n    if (options.expression) { this.converters = [readExpression]; }\n\n    if (options.attributes) { this.inTag = true; }\n\n    // special whitespace handling requested for certain elements\n    this.whiteSpaceElements = assign({}, options.preserveWhitespace, preserveWhitespaceElements);\n  },\n\n  postProcess: function postProcess(result, options) {\n    var parserResult = result[0];\n\n    if (options.expression) {\n      var expr = flattenExpression(parserResult);\n      expr.e = fromExpression(expr.s, expr.r.length);\n      return expr;\n    } else {\n      // special case - empty string\n      if (!result.length) {\n        return { t: [], v: TEMPLATE_VERSION };\n      }\n\n      if (this.sectionDepth > 0) {\n        this.error('A section was left open');\n      }\n\n      cleanup(\n        parserResult.t,\n        this.stripComments,\n        this.preserveWhitespace,\n        !this.preserveWhitespace,\n        !this.preserveWhitespace,\n        this.whiteSpaceElements,\n        this.preserveStandaloneSections\n      );\n\n      if (this.csp !== false) {\n        var expr$1 = {};\n\n        insertExpressions(parserResult.t, expr$1);\n        insertExpressions(parserResult.p || {}, expr$1);\n\n        if (keys(expr$1).length) { parserResult.e = expr$1; }\n      }\n\n      return parserResult;\n    }\n  },\n\n  converters: [readTemplate],\n\n  sortMustacheTags: function sortMustacheTags() {\n    // Sort in order of descending opening delimiter length (longer first),\n    // to protect against opening delimiters being substrings of each other\n    this.tags.sort(function (a, b) {\n      return b.open.length - a.open.length;\n    });\n  }\n});\n\nfunction parse(template, options) {\n  return new StandardParser(template, options || {}).result;\n}\n\nvar parseOptions = [\n  'delimiters',\n  'tripleDelimiters',\n  'staticDelimiters',\n  'staticTripleDelimiters',\n  'csp',\n  'interpolate',\n  'preserveWhitespace',\n  'preserveStandaloneSections',\n  'sanitize',\n  'stripComments',\n  'contextLines',\n  'allowExpressions',\n  'attributes'\n];\n\nvar TEMPLATE_INSTRUCTIONS = \"Either preparse or use a ractive runtime source that includes the parser. \";\n\nvar COMPUTATION_INSTRUCTIONS = \"Either include a version of Ractive that can parse or convert your computation strings to functions.\";\n\nfunction throwNoParse(method, error, instructions) {\n  if (!method) {\n    fatal((\"Missing Ractive.parse - cannot parse \" + error + \". \" + instructions));\n  }\n}\n\nfunction createFunction(body, length) {\n  throwNoParse(fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS);\n  return fromExpression(body, length);\n}\n\nfunction createFunctionFromString(str, bindTo) {\n  throwNoParse(parse, 'compution string \"${str}\"', COMPUTATION_INSTRUCTIONS);\n  var tpl = parse(str, { expression: true });\n  return function() {\n    return tpl.e.apply(bindTo, tpl.r.map(function (r) { return bindTo.get(r); }));\n  };\n}\n\nvar parser = {\n  fromId: function fromId(id, options) {\n    if (!doc) {\n      if (options && options.noThrow) {\n        return;\n      }\n      throw new Error((\"Cannot retrieve template #\" + id + \" as Ractive is not running in a browser.\"));\n    }\n\n    if (id) { id = id.replace(/^#/, ''); }\n\n    var template;\n\n    if (!(template = doc.getElementById(id))) {\n      if (options && options.noThrow) {\n        return;\n      }\n      throw new Error((\"Could not find template element with id #\" + id));\n    }\n\n    if (template.tagName.toUpperCase() !== 'SCRIPT') {\n      if (options && options.noThrow) {\n        return;\n      }\n      throw new Error((\"Template element with id #\" + id + \", must be a <script> element\"));\n    }\n\n    return 'textContent' in template ? template.textContent : template.innerHTML;\n  },\n\n  isParsed: function isParsed(template) {\n    return !isString(template);\n  },\n\n  getParseOptions: function getParseOptions(ractive) {\n    // Could be Ractive or a Component\n    if (ractive.defaults) {\n      ractive = ractive.defaults;\n    }\n\n    return parseOptions.reduce(function (val, key) {\n      val[key] = ractive[key];\n      return val;\n    }, {});\n  },\n\n  parse: function parse$1(template, options) {\n    throwNoParse(parse, 'template', TEMPLATE_INSTRUCTIONS);\n    var parsed = parse(template, options);\n    addFunctions(parsed);\n    return parsed;\n  },\n\n  parseFor: function parseFor(template, ractive) {\n    return this.parse(template, this.getParseOptions(ractive));\n  }\n};\n\nfunction getComputationSignature(ractive, key, signature) {\n  var getter;\n  var setter;\n\n  // useful for debugging\n  var getterString;\n  var getterUseStack;\n  var setterString;\n\n  if (isFunction(signature)) {\n    getter = bind(signature, ractive);\n    getterString = signature.toString();\n    getterUseStack = true;\n  }\n\n  if (isString(signature)) {\n    getter = createFunctionFromString(signature, ractive);\n    getterString = signature;\n  }\n\n  if (isObjectType(signature)) {\n    if (isString(signature.get)) {\n      getter = createFunctionFromString(signature.get, ractive);\n      getterString = signature.get;\n    } else if (isFunction(signature.get)) {\n      getter = bind(signature.get, ractive);\n      getterString = signature.get.toString();\n      getterUseStack = true;\n    } else {\n      fatal('`%s` computation must have a `get()` method', key);\n    }\n\n    if (isFunction(signature.set)) {\n      setter = bind(signature.set, ractive);\n      setterString = signature.set.toString();\n    }\n  }\n\n  return {\n    getter: getter,\n    setter: setter,\n    getterString: getterString,\n    setterString: setterString,\n    getterUseStack: getterUseStack\n  };\n}\n\nvar id = 0;\n\nvar TransitionManager = function TransitionManager(callback, parent) {\n  this.callback = callback;\n  this.parent = parent;\n\n  this.intros = [];\n  this.outros = [];\n\n  this.children = [];\n  this.totalChildren = this.outroChildren = 0;\n\n  this.detachQueue = [];\n  this.outrosComplete = false;\n\n  this.id = id++;\n\n  if (parent) {\n    parent.addChild(this);\n  }\n};\nvar TransitionManager__proto__ = TransitionManager.prototype;\n\nTransitionManager__proto__.add = function add (transition) {\n  var list = transition.isIntro ? this.intros : this.outros;\n  transition.starting = true;\n  list.push(transition);\n};\n\nTransitionManager__proto__.addChild = function addChild (child) {\n  this.children.push(child);\n\n  this.totalChildren += 1;\n  this.outroChildren += 1;\n};\n\nTransitionManager__proto__.checkStart = function checkStart () {\n  if (this.parent && this.parent.started) { this.start(); }\n};\n\nTransitionManager__proto__.decrementOutros = function decrementOutros () {\n  this.outroChildren -= 1;\n  check(this);\n};\n\nTransitionManager__proto__.decrementTotal = function decrementTotal () {\n  this.totalChildren -= 1;\n  check(this);\n};\n\nTransitionManager__proto__.detachNodes = function detachNodes () {\n    var this$1 = this;\n\n  var len = this.detachQueue.length;\n  for (var i = 0; i < len; i++) { this$1.detachQueue[i].detach(); }\n  len = this.children.length;\n  for (var i$1 = 0; i$1 < len; i$1++) { this$1.children[i$1].detachNodes(); }\n  this.detachQueue = [];\n};\n\nTransitionManager__proto__.ready = function ready () {\n  if (this.detachQueue.length) { detachImmediate(this); }\n};\n\nTransitionManager__proto__.remove = function remove (transition) {\n  var list = transition.isIntro ? this.intros : this.outros;\n  removeFromArray(list, transition);\n  check(this);\n};\n\nTransitionManager__proto__.start = function start () {\n  this.started = true;\n  this.children.forEach(function (c) { return c.start(); });\n  this.intros.concat(this.outros).forEach(function (t) { return t.start(); });\n  check(this);\n};\n\nfunction check(tm) {\n  if (!tm.started || tm.outros.length || tm.outroChildren) { return; }\n\n  // If all outros are complete, and we haven't already done this,\n  // we notify the parent if there is one, otherwise\n  // start detaching nodes\n  if (!tm.outrosComplete) {\n    tm.outrosComplete = true;\n\n    if (tm.parent) { tm.parent.decrementOutros(tm); }\n\n    if (allOutrosComplete(tm)) {\n      tm.detachNodes();\n    }\n  }\n\n  // Once everything is done, we can notify parent transition\n  // manager and call the callback\n  if (!tm.intros.length && !tm.totalChildren) {\n    if (isFunction(tm.callback)) {\n      tm.callback();\n    }\n\n    if (tm.parent && !tm.notifiedTotal) {\n      tm.notifiedTotal = true;\n      tm.parent.decrementTotal();\n    }\n  }\n}\n\nfunction allOutrosComplete(manager) {\n  return !manager || (manager.outrosComplete && allOutrosComplete(manager.parent));\n}\n\n// check through the detach queue to see if a node is up or downstream from a\n// transition and if not, go ahead and detach it\nfunction detachImmediate(manager) {\n  var queue = manager.detachQueue;\n  var outros = collectAllOutros(manager);\n\n  if (!outros.length) {\n    manager.detachNodes();\n  } else {\n    var i = queue.length;\n    var j = 0;\n    var node, trans;\n    var nqueue = (manager.detachQueue = []);\n\n    start: while (i--) {\n      node = queue[i].node;\n      j = outros.length;\n      while (j--) {\n        trans = outros[j].element.node;\n        // check to see if the node is, contains, or is contained by the transitioning node\n        if (trans === node || trans.contains(node) || node.contains(trans)) {\n          nqueue.push(queue[i]);\n          continue start;\n        }\n      }\n\n      // no match, we can drop it\n      queue[i].detach();\n    }\n  }\n}\n\nfunction collectAllOutros(manager, _list) {\n  var list = _list;\n\n  // if there's no list, we're starting at the root to build one\n  if (!list) {\n    list = [];\n    var parent = manager;\n    while (parent.parent) { parent = parent.parent; }\n    return collectAllOutros(parent, list);\n  } else {\n    // grab all outros from child managers\n    var i = manager.children.length;\n    while (i--) {\n      list = collectAllOutros(manager.children[i], list);\n    }\n\n    // grab any from this manager if there are any\n    if (manager.outros.length) { list = list.concat(manager.outros); }\n\n    return list;\n  }\n}\n\nvar batch;\n\nvar runloop = {\n  active: function active() {\n    return !!batch;\n  },\n\n  start: function start() {\n    var fulfilPromise;\n    var promise = new Promise(function (f) { return (fulfilPromise = f); });\n\n    batch = {\n      previousBatch: batch,\n      transitionManager: new TransitionManager(fulfilPromise, batch && batch.transitionManager),\n      fragments: [],\n      tasks: [],\n      immediateObservers: [],\n      deferredObservers: [],\n      promise: promise\n    };\n\n    return promise;\n  },\n\n  end: function end() {\n    flushChanges();\n\n    if (!batch.previousBatch) { batch.transitionManager.start(); }\n    else { batch.transitionManager.checkStart(); }\n\n    batch = batch.previousBatch;\n  },\n\n  addFragment: function addFragment(fragment) {\n    addToArray(batch.fragments, fragment);\n  },\n\n  // TODO: come up with a better way to handle fragments that trigger their own update\n  addFragmentToRoot: function addFragmentToRoot(fragment) {\n    if (!batch) { return; }\n\n    var b = batch;\n    while (b.previousBatch) {\n      b = b.previousBatch;\n    }\n\n    addToArray(b.fragments, fragment);\n  },\n\n  addObserver: function addObserver(observer, defer) {\n    if (!batch) {\n      observer.dispatch();\n    } else {\n      addToArray(defer ? batch.deferredObservers : batch.immediateObservers, observer);\n    }\n  },\n\n  registerTransition: function registerTransition(transition) {\n    transition._manager = batch.transitionManager;\n    batch.transitionManager.add(transition);\n  },\n\n  // synchronise node detachments with transition ends\n  detachWhenReady: function detachWhenReady(thing) {\n    batch.transitionManager.detachQueue.push(thing);\n  },\n\n  scheduleTask: function scheduleTask(task, postRender) {\n    var _batch;\n\n    if (!batch) {\n      task();\n    } else {\n      _batch = batch;\n      while (postRender && _batch.previousBatch) {\n        // this can't happen until the DOM has been fully updated\n        // otherwise in some situations (with components inside elements)\n        // transitions and decorators will initialise prematurely\n        _batch = _batch.previousBatch;\n      }\n\n      _batch.tasks.push(task);\n    }\n  },\n\n  promise: function promise() {\n    if (!batch) { return Promise.resolve(); }\n\n    var target = batch;\n    while (target.previousBatch) {\n      target = target.previousBatch;\n    }\n\n    return target.promise || Promise.resolve();\n  }\n};\n\nfunction dispatch(observer) {\n  observer.dispatch();\n}\n\nfunction flushChanges() {\n  var which = batch.immediateObservers;\n  batch.immediateObservers = [];\n  which.forEach(dispatch);\n\n  // Now that changes have been fully propagated, we can update the DOM\n  // and complete other tasks\n  var i = batch.fragments.length;\n  var fragment;\n\n  which = batch.fragments;\n  batch.fragments = [];\n\n  while (i--) {\n    fragment = which[i];\n    fragment.update();\n  }\n\n  batch.transitionManager.ready();\n\n  which = batch.deferredObservers;\n  batch.deferredObservers = [];\n  which.forEach(dispatch);\n\n  var tasks = batch.tasks;\n  batch.tasks = [];\n\n  for (i = 0; i < tasks.length; i += 1) {\n    tasks[i]();\n  }\n\n  // If updating the view caused some model blowback - e.g. a triple\n  // containing <option> elements caused the binding on the <select>\n  // to update - then we start over\n  if (\n    batch.fragments.length ||\n    batch.immediateObservers.length ||\n    batch.deferredObservers.length ||\n    batch.tasks.length\n  )\n    { return flushChanges(); }\n}\n\n// TODO what happens if a transition is aborted?\n\nvar tickers = [];\nvar running = false;\n\nfunction tick() {\n  runloop.start();\n\n  var now = performance.now();\n\n  var i;\n  var ticker;\n\n  for (i = 0; i < tickers.length; i += 1) {\n    ticker = tickers[i];\n\n    if (!ticker.tick(now)) {\n      // ticker is complete, remove it from the stack, and decrement i so we don't miss one\n      tickers.splice(i--, 1);\n    }\n  }\n\n  runloop.end();\n\n  if (tickers.length) {\n    requestAnimationFrame(tick);\n  } else {\n    running = false;\n  }\n}\n\nvar Ticker = function Ticker(options) {\n  this.duration = options.duration;\n  this.step = options.step;\n  this.complete = options.complete;\n  this.easing = options.easing;\n\n  this.start = performance.now();\n  this.end = this.start + this.duration;\n\n  this.running = true;\n\n  tickers.push(this);\n  if (!running) { requestAnimationFrame(tick); }\n};\nvar Ticker__proto__ = Ticker.prototype;\n\nTicker__proto__.tick = function tick (now) {\n  if (!this.running) { return false; }\n\n  if (now > this.end) {\n    if (this.step) { this.step(1); }\n    if (this.complete) { this.complete(1); }\n\n    return false;\n  }\n\n  var elapsed = now - this.start;\n  var eased = this.easing(elapsed / this.duration);\n\n  if (this.step) { this.step(eased); }\n\n  return true;\n};\n\nTicker__proto__.stop = function stop () {\n  if (this.abort) { this.abort(); }\n  this.running = false;\n};\n\nvar prefixers = {};\n\n// TODO this is legacy. sooner we can replace the old adaptor API the better\n/* istanbul ignore next */\nfunction prefixKeypath(obj, prefix) {\n  var prefixed = {};\n\n  if (!prefix) {\n    return obj;\n  }\n\n  prefix += '.';\n\n  for (var key in obj) {\n    if (hasOwn(obj, key)) {\n      prefixed[prefix + key] = obj[key];\n    }\n  }\n\n  return prefixed;\n}\n\nfunction getPrefixer(rootKeypath) {\n  var rootDot;\n\n  if (!prefixers[rootKeypath]) {\n    rootDot = rootKeypath ? rootKeypath + '.' : '';\n\n    /* istanbul ignore next */\n    prefixers[rootKeypath] = function(relativeKeypath, value) {\n      var obj;\n\n      if (isString(relativeKeypath)) {\n        obj = {};\n        obj[rootDot + relativeKeypath] = value;\n        return obj;\n      }\n\n      if (isObjectType(relativeKeypath)) {\n        // 'relativeKeypath' is in fact a hash, not a keypath\n        return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;\n      }\n    };\n  }\n\n  return prefixers[rootKeypath];\n}\n\nvar shared$1 = {};\n\nvar Model = (function (ModelBase) {\n  function Model(parent, key) {\n    ModelBase.call(this, parent);\n\n    this.ticker = null;\n\n    if (parent) {\n      this.key = unescapeKey(key);\n      this.isReadonly = parent.isReadonly;\n\n      if (parent.value) {\n        this.value = parent.value[this.key];\n        if (isArray(this.value)) { this.length = this.value.length; }\n        this.adapt();\n      }\n    }\n  }\n\n  if ( ModelBase ) Model.__proto__ = ModelBase;\n  var Model__proto__ = Model.prototype = Object.create( ModelBase && ModelBase.prototype );\n  Model__proto__.constructor = Model;\n\n  Model__proto__.adapt = function adapt () {\n    var this$1 = this;\n\n    var adaptors = this.root.adaptors;\n    var len = adaptors.length;\n\n    this.rewrap = false;\n\n    // Exit early if no adaptors\n    if (len === 0) { return; }\n\n    var value = this.wrapper\n      ? 'newWrapperValue' in this\n        ? this.newWrapperValue\n        : this.wrapperValue\n      : this.value;\n\n    // TODO remove this legacy nonsense\n    var ractive = this.root.ractive;\n    var keypath = this.getKeypath();\n\n    // tear previous adaptor down if present\n    if (this.wrapper) {\n      var shouldTeardown =\n        this.wrapperValue === value\n          ? false\n          : !this.wrapper.reset || this.wrapper.reset(value) === false;\n\n      if (shouldTeardown) {\n        this.wrapper.teardown();\n        delete this.wrapper;\n        delete this.wrapperValue;\n        delete this.newWrapperValue;\n\n        // don't branch for undefined values\n        if (this.value !== undefined) {\n          var parentValue = this.parent.value || this.parent.createBranch(this.key);\n          if (parentValue[this.key] !== value) { parentValue[this.key] = value; }\n          this.value = value;\n        }\n      } else {\n        delete this.newWrapperValue;\n        this.value = this.wrapper.get();\n        return;\n      }\n    }\n\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      var adaptor = adaptors[i];\n      if (adaptor.filter(value, keypath, ractive)) {\n        this$1.wrapper = adaptor.wrap(ractive, value, keypath, getPrefixer(keypath));\n        this$1.wrapperValue = value;\n        this$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor\n\n        this$1.value = this$1.wrapper.get();\n\n        break;\n      }\n    }\n  };\n\n  Model__proto__.animate = function animate (from, to, options, interpolator) {\n    var this$1 = this;\n\n    if (this.ticker) { this.ticker.stop(); }\n\n    var fulfilPromise;\n    var promise = new Promise(function (fulfil) { return (fulfilPromise = fulfil); });\n\n    this.ticker = new Ticker({\n      duration: options.duration,\n      easing: options.easing,\n      step: function (t) {\n        var value = interpolator(t);\n        this$1.applyValue(value);\n        if (options.step) { options.step(t, value); }\n      },\n      complete: function () {\n        this$1.applyValue(to);\n        if (options.complete) { options.complete(to); }\n\n        this$1.ticker = null;\n        fulfilPromise(to);\n      }\n    });\n\n    promise.stop = this.ticker.stop;\n    return promise;\n  };\n\n  Model__proto__.applyValue = function applyValue (value, notify) {\n    if ( notify === void 0 ) notify = true;\n\n    if (isEqual(value, this.value)) { return; }\n    if (this.boundValue) { this.boundValue = null; }\n\n    if (this.parent.wrapper && this.parent.wrapper.set) {\n      this.parent.wrapper.set(this.key, value);\n      this.parent.value = this.parent.wrapper.get();\n\n      this.value = this.parent.value[this.key];\n      if (this.wrapper) { this.newWrapperValue = this.value; }\n      this.adapt();\n    } else if (this.wrapper) {\n      this.newWrapperValue = value;\n      this.adapt();\n    } else {\n      var parentValue = this.parent.value || this.parent.createBranch(this.key);\n      if (isObjectLike(parentValue)) {\n        parentValue[this.key] = value;\n      } else {\n        warnIfDebug((\"Attempted to set a property of a non-object '\" + (this.getKeypath()) + \"'\"));\n        return;\n      }\n\n      this.value = value;\n      this.adapt();\n    }\n\n    if (this.dataModel || (value && value.viewmodel && value.viewmodel.isRoot)) {\n      checkDataLink(this, value);\n    }\n\n    // keep track of array stuff\n    if (isArray(value)) {\n      this.length = value.length;\n      this.isArray = true;\n    } else {\n      this.isArray = false;\n    }\n\n    // notify dependants\n    this.links.forEach(handleChange);\n    this.children.forEach(mark);\n    this.deps.forEach(handleChange);\n\n    if (notify) { this.notifyUpstream(); }\n\n    if (this.parent.isArray) {\n      if (this.key === 'length') { this.parent.length = value; }\n      else { this.parent.joinKey('length').mark(); }\n    }\n  };\n\n  Model__proto__.compute = function compute (key, computed) {\n    var registry = this.computed || (this.computed = {});\n\n    if (registry[key]) {\n      registry[key].signature = getComputationSignature(this.root.ractive, key, computed);\n      registry[key].mark();\n    } else {\n      registry[key] = new shared$1.Computation(\n        this,\n        getComputationSignature(this.root.ractive, key, computed),\n        key\n      );\n    }\n\n    return registry[key];\n  };\n\n  Model__proto__.createBranch = function createBranch (key) {\n    var branch = isNumeric(key) ? [] : {};\n    this.applyValue(branch, false);\n\n    return branch;\n  };\n\n  Model__proto__.get = function get (shouldCapture, opts) {\n    if (this._link) { return this._link.get(shouldCapture, opts); }\n    if (shouldCapture) { capture(this); }\n    // if capturing, this value needs to be unwrapped because it's for external use\n    if (opts && opts.virtual) { return this.getVirtual(false); }\n    return maybeBind(\n      this,\n      (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture) && this.wrapper\n        ? this.wrapperValue\n        : this.value,\n      !opts || opts.shouldBind !== false\n    );\n  };\n\n  Model__proto__.joinKey = function joinKey (key, opts) {\n    var this$1 = this;\n\n    if (this._link) {\n      if (opts && opts.lastLink !== false && (isUndefined(key) || key === '')) { return this; }\n      return this._link.joinKey(key);\n    }\n\n    if (isUndefined(key) || key === '') { return this; }\n\n    var child;\n    if (hasOwn(this.childByKey, key)) { child = this.childByKey[key]; }\n    else { child = this.computed && this.computed[key]; }\n\n    if (!child) {\n      var computed;\n      if (this.isRoot && this.ractive && (computed = this.ractive.computed[key])) {\n        child = this.compute(key, computed);\n      } else if (!this.isRoot && this.root.ractive) {\n        var registry = this.root.ractive.computed;\n        for (var k in registry) {\n          computed = registry[k];\n          if (computed.pattern && computed.pattern.test(this$1.getKeypath() + '.' + key)) {\n            child = this$1.compute(key, computed);\n          }\n        }\n      }\n    }\n\n    if (!child) {\n      child = new Model(this, key);\n      this.children.push(child);\n      this.childByKey[key] = child;\n\n      if (key === 'data') {\n        var val = this.retrieve();\n        if (val && val.viewmodel && val.viewmodel.isRoot) {\n          // this needs to happen in a runloop, as it can cause bubbling\n          var batch$$1 = runloop.active();\n          if (!batch$$1) { runloop.start(); }\n\n          child.link(val.viewmodel, 'data');\n          this.dataModel = val;\n\n          if (!batch$$1) { runloop.end(); }\n        }\n      }\n    }\n\n    if (child._link && (!opts || opts.lastLink !== false)) { return child._link; }\n\n    return child;\n  };\n\n  Model__proto__.mark = function mark$1 (force) {\n    if (this._link) { return this._link.mark(force); }\n\n    var old = this.value;\n    var value = this.retrieve();\n\n    if (this.dataModel || (value && value.viewmodel && value.viewmodel.isRoot)) {\n      checkDataLink(this, value);\n    }\n\n    if (force || !isEqual(value, old)) {\n      this.value = value;\n      if (this.boundValue) { this.boundValue = null; }\n\n      // make sure the wrapper stays in sync\n      if (old !== value || this.rewrap) {\n        if (this.wrapper) { this.newWrapperValue = value; }\n        this.adapt();\n      }\n\n      // keep track of array stuff\n      if (isArray(value)) {\n        this.length = value.length;\n        this.isArray = true;\n      } else {\n        this.isArray = false;\n      }\n\n      this.children.forEach(force ? markForce : mark);\n      this.links.forEach(marked);\n\n      this.deps.forEach(handleChange);\n    }\n  };\n\n  Model__proto__.merge = function merge (array, comparator) {\n    var newIndices = buildNewIndices(\n      this.value === array ? recreateArray(this) : this.value,\n      array,\n      comparator\n    );\n    this.parent.value[this.key] = array;\n    this.shuffle(newIndices, true);\n  };\n\n  Model__proto__.retrieve = function retrieve () {\n    return this.parent.value ? this.parent.value[this.key] : undefined;\n  };\n\n  Model__proto__.set = function set (value) {\n    if (this.ticker) { this.ticker.stop(); }\n    this.applyValue(value);\n  };\n\n  Model__proto__.shuffle = function shuffle$2 (newIndices, unsafe) {\n    shuffle(this, newIndices, false, unsafe);\n  };\n\n  Model__proto__.source = function source () {\n    return this;\n  };\n\n  Model__proto__.teardown = function teardown$4 () {\n    var this$1 = this;\n\n    if (this._link) {\n      this._link.teardown();\n      this._link = null;\n    }\n    this.children.forEach(teardown);\n    if (this.wrapper) { this.wrapper.teardown(); }\n    if (this.computed) { keys(this.computed).forEach(function (k) { return this$1.computed[k].teardown(); }); }\n  };\n\n  return Model;\n}(ModelBase));\n\nfunction recreateArray(model) {\n  var array = [];\n\n  for (var i = 0; i < model.length; i++) {\n    array[i] = (model.childByKey[i] || {}).value;\n  }\n\n  return array;\n}\n\n/* global global */\nvar data = {};\n\nvar SharedModel = (function (Model) {\n  function SharedModel(value, name, ractive) {\n    Model.call(this, null, (\"@\" + name));\n    this.key = \"@\" + name;\n    this.value = value;\n    this.isRoot = true;\n    this.root = this;\n    this.adaptors = [];\n    this.ractive = ractive;\n  }\n\n  if ( Model ) SharedModel.__proto__ = Model;\n  var SharedModel__proto__ = SharedModel.prototype = Object.create( Model && Model.prototype );\n  SharedModel__proto__.constructor = SharedModel;\n\n  SharedModel__proto__.getKeypath = function getKeypath () {\n    return this.key;\n  };\n\n  SharedModel__proto__.retrieve = function retrieve () {\n    return this.value;\n  };\n\n  return SharedModel;\n}(Model));\n\nvar SharedModel$1 = new SharedModel(data, 'shared');\n\nvar GlobalModel = new SharedModel(base, 'global');\n\nfunction findContext(fragment) {\n  var frag = fragment;\n  while (frag && !frag.context && !frag.aliases) { frag = frag.parent; }\n  return frag;\n}\n\nfunction resolveReference(fragment, ref) {\n  var initialFragment = fragment;\n  // current context ref\n  if (ref === '.') { return fragment.findContext(); }\n\n  // ancestor references\n  if (ref[0] === '~') { return fragment.ractive.viewmodel.joinAll(splitKeypath(ref.slice(2))); }\n\n  // scoped references\n  if (ref[0] === '.' || ref[0] === '^') {\n    var frag = fragment;\n    var parts = ref.split('/');\n    var explicitContext = parts[0] === '^^';\n\n    // find nearest context node\n    while (frag && !frag.context) {\n      frag = up(frag);\n    }\n    var context$1 = frag && frag.context;\n\n    // walk up the context chain\n    while (frag && parts[0] === '^^') {\n      parts.shift();\n\n      // the current fragment should always be a context,\n      // and if it happens to be an iteration, jump above the each block\n      if (frag.isIteration) {\n        frag = frag.parent.parent;\n      } else {\n        // otherwise jump above the current fragment\n        frag = up(frag);\n      }\n\n      // walk to the next contexted fragment\n      while (frag && !frag.context) {\n        frag = up(frag);\n      }\n      context$1 = frag && frag.context;\n    }\n\n    if (!context$1 && explicitContext) {\n      throw new Error(\n        (\"Invalid context parent reference ('\" + ref + \"'). There is not context at that level.\")\n      );\n    }\n\n    // walk up the context path\n    while (parts[0] === '.' || parts[0] === '..') {\n      var part = parts.shift();\n\n      if (part === '..') {\n        // treat reference expressions as their model\n        if (!context$1.parent && context$1.proxy && context$1.target) { context$1 = context$1.target.parent; }\n        else { context$1 = context$1.parent; }\n      }\n    }\n\n    ref = parts.join('/');\n\n    // special case - `{{.foo}}` means the same as `{{./foo}}`\n    if (ref[0] === '.') { ref = ref.slice(1); }\n    return context$1.joinAll(splitKeypath(ref));\n  }\n\n  var keys$$1 = splitKeypath(ref);\n  if (!keys$$1.length) { return; }\n  var base = keys$$1.shift();\n\n  // special refs\n  if (base[0] === '@') {\n    // shorthand from outside the template\n    // @this referring to local ractive instance\n    if (base === '@this' || base === '@') {\n      return fragment.ractive.viewmodel.getRactiveModel().joinAll(keys$$1);\n    } else if (base === '@index' || base === '@key') {\n      // @index or @key referring to the nearest repeating index or key\n      if (keys$$1.length) { badReference(base); }\n      var repeater = findIter(fragment);\n      return repeater && repeater[(\"get\" + (base[1] === 'i' ? 'Index' : 'Key'))]();\n    } else if (base === '@last') {\n      var repeater$1 = findIter(fragment);\n      return repeater$1 && repeater$1.parent.getLast();\n    } else if (base === '@global') {\n      // @global referring to window or global\n      return GlobalModel.joinAll(keys$$1);\n    } else if (base === '@shared') {\n      // @global referring to window or global\n      return SharedModel$1.joinAll(keys$$1);\n    } else if (base === '@keypath' || base === '@rootpath') {\n      // @keypath or @rootpath, the current keypath string\n      var root = ref[1] === 'r' ? fragment.ractive.root : null;\n      var f = fragment;\n\n      while (\n        f &&\n        (!f.context || (f.isRoot && f.ractive.component && (root || !f.ractive.isolated)))\n      ) {\n        f = f.isRoot ? f.componentParent : f.parent;\n      }\n\n      return f.getKeypath(root);\n    } else if (base === '@context') {\n      return new SharedModel(fragment.getContext(), 'context').joinAll(keys$$1);\n    } else if (base === '@local') {\n      // @context-local data\n      return fragment.getContext()._data.joinAll(keys$$1);\n    } else if (base === '@style') {\n      // @style shared model\n      return fragment.ractive.constructor._cssModel.joinAll(keys$$1);\n    } else if (base === '@helpers') {\n      // @helpers instance model\n      return fragment.ractive.viewmodel.getHelpers().joinAll(keys$$1);\n    } else if (base === '@macro') {\n      var handle = findMacro(fragment);\n      if (handle) { return new SharedModel(handle, 'macro').joinAll(keys$$1); }\n      else { return; }\n    } else {\n      // nope\n      throw new Error((\"Invalid special reference '\" + base + \"'\"));\n    }\n  }\n\n  // helpers\n  if (base && !keys$$1.length) {\n    var helpers = fragment.ractive.viewmodel.getHelpers();\n    if (helpers.has(base)) { return helpers.joinKey(base); }\n  }\n\n  var context = findContext(fragment);\n\n  // check immediate context for a match\n  if (context) {\n    if (context.context) {\n      context = context.context;\n    } else {\n      // alias block, so get next full context for later\n      context = fragment.findContext();\n    }\n  } else {\n    context = fragment.findContext();\n  }\n\n  // walk up the fragment hierarchy looking for a matching ref, alias, or key in a context\n  var createMapping = false;\n  var shouldWarn = fragment.ractive.warnAboutAmbiguity;\n  var crossed = 0;\n  var model;\n\n  while (fragment) {\n    // repeated fragments\n    if (fragment.isIteration) {\n      if (base === fragment.parent.keyRef) {\n        model = fragment.getKey();\n      } else if (base === fragment.parent.indexRef) {\n        model = fragment.getIndex();\n      }\n\n      if (model && keys$$1.length) { badReference(base); }\n    }\n\n    // alias node or iteration\n    if (!model && fragment.aliases && hasOwn(fragment.aliases, base)) {\n      model = fragment.aliases[base];\n    }\n\n    // check fragment context to see if it has the key we need\n    if (!model && fragment.context && fragment.context.has(base)) {\n      model = fragment.context.joinKey(base);\n\n      // this is an implicit mapping\n      if (createMapping) {\n        if (shouldWarn)\n          { warnIfDebug(\n            (\"'\" + ref + \"' resolved but is ambiguous and will create a mapping to a parent component.\")\n          ); }\n      } else if (shouldWarn && crossed) { warnIfDebug((\"'\" + ref + \"' resolved but is ambiguous.\")); }\n    }\n\n    if (model) {\n      if (createMapping) {\n        model = initialFragment.ractive.viewmodel.createLink(base, model, base, { implicit: true });\n      }\n\n      if (keys$$1.length > 0 && isFunction(model.joinAll)) {\n        model = model.joinAll(keys$$1);\n      }\n\n      return model;\n    }\n\n    // don't consider alias blocks when checking for ambiguity\n    if (fragment.context && !fragment.aliases) { crossed = 1; }\n\n    if (\n      !fragment.ractive.isolated &&\n      !(fragment.owner && fragment.owner.containerFragment) &&\n      (fragment.componentParent || (!fragment.parent && fragment.ractive.component))\n    ) {\n      // ascend through component boundary\n      fragment = fragment.componentParent || fragment.ractive.component.up;\n      createMapping = true;\n    } else {\n      fragment = fragment.parent;\n    }\n  }\n\n  // if enabled, check the instance for a match\n  var instance = initialFragment.ractive;\n  if (instance.resolveInstanceMembers && base !== 'data' && base in instance) {\n    return instance.viewmodel\n      .getRactiveModel()\n      .joinKey(base)\n      .joinAll(keys$$1);\n  }\n\n  if (shouldWarn) {\n    warnIfDebug((\"'\" + ref + \"' is ambiguous and did not resolve.\"));\n  }\n\n  // didn't find anything, so go ahead and create the key on the local model\n  return context.joinKey(base).joinAll(keys$$1);\n}\n\nfunction up(fragment) {\n  return (\n    fragment &&\n    ((!fragment.ractive.isolated &&\n      !(fragment.owner && fragment.owner.containerFragment) &&\n      (fragment.componentParent || (!fragment.parent && fragment.ractive.component))) ||\n      fragment.parent)\n  );\n}\n\nfunction findIter(start) {\n  var fragment = start;\n  var next;\n  while (!fragment.isIteration && (next = up(fragment))) {\n    fragment = next;\n  }\n\n  return fragment.isIteration && fragment;\n}\n\nfunction findMacro(start) {\n  var fragment = start;\n  while (fragment) {\n    if (fragment.owner.handle) { return fragment.owner.handle; }\n    fragment = up(fragment);\n  }\n}\n\nfunction badReference(key) {\n  throw new Error((\"An index or key reference (\" + key + \") cannot have child properties\"));\n}\n\nvar extern = {};\n\nfunction getRactiveContext(ractive) {\n  var assigns = [], len = arguments.length - 1;\n  while ( len-- > 0 ) assigns[ len ] = arguments[ len + 1 ];\n\n  var fragment =\n    ractive.fragment ||\n    ractive._fakeFragment ||\n    (ractive._fakeFragment = new FakeFragment(ractive));\n  return fragment.getContext.apply(fragment, assigns);\n}\n\nfunction getContext() {\n  var assigns = [], len = arguments.length;\n  while ( len-- ) assigns[ len ] = arguments[ len ];\n\n  if (!this.ctx) { this.ctx = new extern.Context(this); }\n  assigns.unshift(create(this.ctx));\n  return assign.apply(null, assigns);\n}\n\nvar FakeFragment = function FakeFragment(ractive) {\n  this.ractive = ractive;\n};\n\nFakeFragment.prototype.findContext = function findContext () {\n  return this.ractive.viewmodel;\n};\nvar proto = FakeFragment.prototype;\nproto.getContext = getContext;\nproto.find = proto.findComponent = proto.findAll = proto.findAllComponents = noop;\n\nfunction findParentWithContext(fragment) {\n  var frag = fragment;\n  while (frag && !frag.context) { frag = frag.parent; }\n  if (!frag) { return fragment && fragment.ractive.fragment; }\n  else { return frag; }\n}\n\nvar keep = false;\n\nfunction set(pairs, options) {\n  var k = keep;\n\n  var deep = options && options.deep;\n  var shuffle = options && options.shuffle;\n  var promise = runloop.start();\n  if (options && 'keep' in options) { keep = options.keep; }\n\n  var i = pairs.length;\n  while (i--) {\n    var model = pairs[i][0];\n    var value = pairs[i][1];\n    var keypath = pairs[i][2];\n\n    if (!model) {\n      runloop.end();\n      throw new Error((\"Failed to set invalid keypath '\" + keypath + \"'\"));\n    }\n\n    if (deep) { deepSet(model, value); }\n    else if (shuffle) {\n      var array = value;\n      var target = model.get();\n      // shuffle target array with itself\n      if (!array) { array = target; }\n\n      // if there's not an array there yet, go ahead and set\n      if (isUndefined(target)) {\n        model.set(array);\n      } else {\n        if (!isArray(target) || !isArray(array)) {\n          runloop.end();\n          throw new Error('You cannot merge an array with a non-array');\n        }\n\n        var comparator = getComparator(shuffle);\n        model.merge(array, comparator);\n      }\n    } else { model.set(value); }\n  }\n\n  runloop.end();\n\n  keep = k;\n\n  if (pairs.length === 1) { return promise.then(function () { return pairs[0][1]; }); }\n  else { return promise; }\n}\n\nvar star = /\\*/;\nfunction gather(ractive, keypath, base, isolated) {\n  if (!base && (keypath[0] === '.' || keypath[1] === '^')) {\n    warnIfDebug(\n      \"Attempted to set a relative keypath from a non-relative context. You can use a context object to set relative keypaths.\"\n    );\n    return [];\n  }\n\n  var keys$$1 = splitKeypath(keypath);\n  var model = base || ractive.viewmodel;\n\n  if (star.test(keypath)) {\n    return model.findMatches(keys$$1);\n  } else {\n    if (model === ractive.viewmodel) {\n      // allow implicit mappings\n      if (\n        ractive.component &&\n        !ractive.isolated &&\n        !model.has(keys$$1[0]) &&\n        keypath[0] !== '@' &&\n        keypath[0] &&\n        !isolated\n      ) {\n        return [resolveReference(ractive.fragment || new FakeFragment(ractive), keypath)];\n      } else {\n        return [model.joinAll(keys$$1)];\n      }\n    } else {\n      return [model.joinAll(keys$$1)];\n    }\n  }\n}\n\nfunction build(ractive, keypath, value, isolated) {\n  var sets = [];\n\n  // set multiple keypaths in one go\n  if (isObject(keypath)) {\n    var loop = function ( k ) {\n      if (hasOwn(keypath, k)) {\n        sets.push.apply(sets, gather(ractive, k, null, isolated).map(function (m) { return [m, keypath[k], k]; }));\n      }\n    };\n\n    for (var k in keypath) loop( k );\n  } else {\n    // set a single keypath\n    sets.push.apply(sets, gather(ractive, keypath, null, isolated).map(function (m) { return [m, value, keypath]; }));\n  }\n\n  return sets;\n}\n\nvar deepOpts = { virtual: false };\nfunction deepSet(model, value) {\n  var dest = model.get(false, deepOpts);\n\n  // if dest doesn't exist, just set it\n  if (dest == null || !isObjectType(value) || isDate(value)) { return model.set(value); }\n  if (!isObjectType(dest)) { return model.set(value); }\n\n  for (var k in value) {\n    if (hasOwn(value, k)) {\n      deepSet(model.joinKey(k), value[k]);\n    }\n  }\n}\n\nvar comparators = {};\nfunction getComparator(option) {\n  if (option === true) { return null; } // use existing arrays\n  if (isFunction(option)) { return option; }\n\n  if (isString(option)) {\n    return comparators[option] || (comparators[option] = function (thing) { return thing[option]; });\n  }\n\n  throw new Error('If supplied, options.compare must be a string, function, or true'); // TODO link to docs\n}\n\nvar errorMessage = 'Cannot add to a non-numeric value';\n\nfunction add(ractive, keypath, d, options) {\n  if (!isString(keypath) || !isNumeric(d)) {\n    throw new Error('Bad arguments');\n  }\n\n  var sets = build(ractive, keypath, d, options && options.isolated);\n\n  return set(\n    sets.map(function (pair) {\n      var model = pair[0];\n      var add = pair[1];\n      var value = model.get();\n      if (!isNumeric(add) || !isNumeric(value)) { throw new Error(errorMessage); }\n      return [model, value + add];\n    })\n  );\n}\n\nfunction Ractive$add(keypath, d, options) {\n  var num = isNumber(d) ? d : 1;\n  var opts = isObjectType(d) ? d : options;\n  return add(this, keypath, num, opts);\n}\n\nfunction immediate(value) {\n  var result = Promise.resolve(value);\n  defineProperty(result, 'stop', { value: noop });\n  return result;\n}\n\nvar linear = easing.linear;\n\nfunction getOptions(options, instance) {\n  options = options || {};\n\n  var easing$$1;\n  if (options.easing) {\n    easing$$1 = isFunction(options.easing) ? options.easing : instance.easing[options.easing];\n  }\n\n  return {\n    easing: easing$$1 || linear,\n    duration: 'duration' in options ? options.duration : 400,\n    complete: options.complete || noop,\n    step: options.step || noop,\n    interpolator: options.interpolator\n  };\n}\n\nfunction animate(ractive, model, to, options) {\n  options = getOptions(options, ractive);\n  var from = model.get();\n\n  // don't bother animating values that stay the same\n  if (isEqual(from, to)) {\n    options.complete(options.to);\n    return immediate(to);\n  }\n\n  var interpolator = interpolate(from, to, ractive, options.interpolator);\n\n  // if we can't interpolate the value, set it immediately\n  if (!interpolator) {\n    runloop.start();\n    model.set(to);\n    runloop.end();\n\n    return immediate(to);\n  }\n\n  return model.animate(from, to, options, interpolator);\n}\n\nfunction Ractive$animate(keypath, to, options) {\n  if (isObjectType(keypath)) {\n    var keys$$1 = keys(keypath);\n\n    throw new Error((\"ractive.animate(...) no longer supports objects. Instead of ractive.animate({\\n  \" + (keys$$1.map(function (key) { return (\"'\" + key + \"': \" + (keypath[key])); }).join('\\n  ')) + \"\\n}, {...}), do\\n\\n\" + (keys$$1.map(function (key) { return (\"ractive.animate('\" + key + \"', \" + (keypath[key]) + \", {...});\"); }).join('\\n')) + \"\\n\"));\n  }\n\n  return animate(this, this.viewmodel.joinAll(splitKeypath(keypath)), to, options);\n}\n\nfunction enqueue(ractive, event) {\n  if (ractive.event) {\n    ractive._eventQueue.push(ractive.event);\n  }\n\n  ractive.event = event;\n}\n\nfunction dequeue(ractive) {\n  if (ractive._eventQueue.length) {\n    ractive.event = ractive._eventQueue.pop();\n  } else {\n    ractive.event = null;\n  }\n}\n\nvar initStars = {};\nvar bubbleStars = {};\n\n// cartesian product of name parts and stars\n// adjusted appropriately for special cases\nfunction variants(name, initial) {\n  var map = initial ? initStars : bubbleStars;\n  if (map[name]) { return map[name]; }\n\n  var parts = name.split('.');\n  var result = [];\n  var base = false;\n\n  // initial events the implicit namespace of 'this'\n  if (initial) {\n    parts.unshift('this');\n    base = true;\n  }\n\n  // use max - 1 bits as a bitmap to pick a part or a *\n  // need to skip the full star case if the namespace is synthetic\n  var max = Math.pow(2, parts.length) - (initial ? 1 : 0);\n  for (var i = 0; i < max; i++) {\n    var join = [];\n    for (var j = 0; j < parts.length; j++) {\n      join.push(1 & (i >> j) ? '*' : parts[j]);\n    }\n    result.unshift(join.join('.'));\n  }\n\n  if (base) {\n    // include non-this-namespaced versions\n    if (parts.length > 2) {\n      result.push.apply(result, variants(name, false));\n    } else {\n      result.push('*');\n      result.push(name);\n    }\n  }\n\n  map[name] = result;\n  return result;\n}\n\nfunction fireEvent(ractive, eventName, context, args) {\n  if ( args === void 0 ) args = [];\n\n  if (!eventName) {\n    return;\n  }\n\n  context.name = eventName;\n  args.unshift(context);\n\n  var eventNames = ractive._nsSubs ? variants(eventName, true) : ['*', eventName];\n\n  return fireEventAs(ractive, eventNames, context, args, true);\n}\n\nfunction fireEventAs(ractive, eventNames, context, args, initialFire) {\n  if ( initialFire === void 0 ) initialFire = false;\n\n  var bubble = true;\n\n  if (initialFire || ractive._nsSubs) {\n    enqueue(ractive, context);\n\n    var i = eventNames.length;\n    while (i--) {\n      if (eventNames[i] in ractive._subs) {\n        bubble = notifySubscribers(ractive, ractive._subs[eventNames[i]], context, args) && bubble;\n      }\n    }\n\n    dequeue(ractive);\n  }\n\n  if (ractive.parent && bubble) {\n    if (initialFire && ractive.component) {\n      var fullName = ractive.component.name + '.' + eventNames[eventNames.length - 1];\n      eventNames = variants(fullName, false);\n\n      if (context && !context.component) {\n        context.component = ractive;\n      }\n    }\n\n    bubble = fireEventAs(ractive.parent, eventNames, context, args);\n  }\n\n  return bubble;\n}\n\nfunction notifySubscribers(ractive, subscribers, context, args) {\n  var originalEvent = null;\n  var stopEvent = false;\n\n  // subscribers can be modified inflight, e.g. \"once\" functionality\n  // so we need to copy to make sure everyone gets called\n  subscribers = subscribers.slice();\n\n  for (var i = 0, len = subscribers.length; i < len; i += 1) {\n    if (!subscribers[i].off && subscribers[i].handler.apply(ractive, args) === false) {\n      stopEvent = true;\n    }\n  }\n\n  if (context && stopEvent && (originalEvent = context.event)) {\n    originalEvent.preventDefault && originalEvent.preventDefault();\n    originalEvent.stopPropagation && originalEvent.stopPropagation();\n  }\n\n  return !stopEvent;\n}\n\nvar Hook = function Hook(event) {\n  this.event = event;\n  this.method = 'on' + event;\n};\n\nHook.prototype.fire = function fire (ractive, arg) {\n  var context = getRactiveContext(ractive);\n  var method = this.method;\n\n  if (ractive[method]) {\n    arg ? ractive[method](context, arg) : ractive[method](context);\n  }\n\n  fireEvent(ractive, this.event, context, arg ? [arg, ractive] : [ractive]);\n};\n\nfunction getChildQueue(queue, ractive) {\n  return queue[ractive._guid] || (queue[ractive._guid] = []);\n}\n\nfunction fire(hookQueue, ractive) {\n  var childQueue = getChildQueue(hookQueue.queue, ractive);\n\n  hookQueue.hook.fire(ractive);\n\n  // queue is \"live\" because components can end up being\n  // added while hooks fire on parents that modify data values.\n  while (childQueue.length) {\n    fire(hookQueue, childQueue.shift());\n  }\n\n  delete hookQueue.queue[ractive._guid];\n}\n\nvar HookQueue = function HookQueue(event) {\n  this.hook = new Hook(event);\n  this.inProcess = {};\n  this.queue = {};\n};\nvar HookQueue__proto__ = HookQueue.prototype;\n\nHookQueue__proto__.begin = function begin (ractive) {\n  this.inProcess[ractive._guid] = true;\n};\n\nHookQueue__proto__.end = function end (ractive) {\n  var parent = ractive.parent;\n\n  // If this is *isn't* a child of a component that's in process,\n  // it should call methods or fire at this point\n  if (!parent || !this.inProcess[parent._guid]) {\n    fire(this, ractive);\n  } else {\n    // elsewise, handoff to parent to fire when ready\n    getChildQueue(this.queue, parent).push(ractive);\n  }\n\n  delete this.inProcess[ractive._guid];\n};\n\nvar hooks = {};\n[\n  'construct',\n  'config',\n  'attachchild',\n  'detach',\n  'detachchild',\n  'insert',\n  'complete',\n  'reset',\n  'render',\n  'unrendering',\n  'unrender',\n  'teardown',\n  'destruct',\n  'update'\n].forEach(function (hook) {\n  hooks[hook] = new Hook(hook);\n});\nhooks.init = new HookQueue('init');\n\nfunction findAnchors(fragment, name) {\n  if ( name === void 0 ) name = null;\n\n  var res = [];\n\n  findAnchorsIn(fragment, name, res, fragment.ractive);\n\n  return res;\n}\n\nfunction findAnchorsIn(item, name, result, instance) {\n  if (item.isAnchor) {\n    if (!name || item.name === name) {\n      result.push(item);\n    }\n  } else if (item.items) {\n    item.items.forEach(function (i) { return findAnchorsIn(i, name, result, instance); });\n  } else if (item.iterations) {\n    item.iterations.forEach(function (i) { return findAnchorsIn(i, name, result, instance); });\n  } else if (item.fragment && (!item.component || item.fragment.ractive === instance)) {\n    findAnchorsIn(item.fragment, name, result, instance);\n  } else if (item.instance && item.instance.fragment) {\n    var anchors = [];\n    findAnchorsIn(item.instance.fragment, name, anchors, instance);\n    anchors.forEach(function (a) { return a.ractive === instance && result.push(a); });\n  }\n}\n\nfunction updateAnchors(instance, name) {\n  if ( name === void 0 ) name = null;\n\n  var anchors = findAnchors(instance.fragment, name);\n  var idxs = {};\n  var children = instance._children.byName;\n\n  anchors.forEach(function (a) {\n    var name = a.name;\n    if (!(name in idxs)) { idxs[name] = 0; }\n    var idx = idxs[name];\n    var child = (children[name] || [])[idx];\n\n    if (child && child.lastBound !== a) {\n      if (child.lastBound) { child.lastBound.removeChild(child); }\n      a.addChild(child);\n    }\n\n    idxs[name]++;\n  });\n}\n\nfunction unrenderChild(meta) {\n  if (meta.instance.fragment.rendered) {\n    meta.shouldDestroy = true;\n    meta.instance.unrender();\n  }\n  meta.instance.el = null;\n}\n\nfunction attachChild(child, options) {\n  if ( options === void 0 ) options = {};\n\n  var children = this._children;\n  var idx;\n\n  if (child.parent && child.parent !== this)\n    { throw new Error(\n      (\"Instance \" + (child._guid) + \" is already attached to a different instance \" + (child.parent._guid) + \". Please detach it from the other instance using detachChild first.\")\n    ); }\n  else if (child.parent)\n    { throw new Error((\"Instance \" + (child._guid) + \" is already attached to this instance.\")); }\n\n  var meta = {\n    instance: child,\n    ractive: this,\n    name: options.name || child.constructor.name || 'Ractive',\n    target: options.target || false,\n    bubble: bubble,\n    findNextNode: findNextNode\n  };\n  meta.nameOption = options.name;\n\n  // child is managing itself\n  if (!meta.target) {\n    meta.up = this.fragment;\n    meta.external = true;\n  } else {\n    var list;\n    if (!(list = children.byName[meta.target])) {\n      list = [];\n      this.set((\"@this.children.byName.\" + (meta.target)), list);\n    }\n    idx = options.prepend ? 0 : options.insertAt !== undefined ? options.insertAt : list.length;\n  }\n\n  child.parent = this;\n  child.root = this.root;\n  child.component = meta;\n  children.push(meta);\n\n  var promise = runloop.start();\n\n  var rm = child.viewmodel.getRactiveModel();\n  rm.joinKey('parent', { lastLink: false }).link(this.viewmodel.getRactiveModel());\n  rm.joinKey('root', { lastLink: false }).link(this.root.viewmodel.getRactiveModel());\n\n  hooks.attachchild.fire(child);\n\n  if (meta.target) {\n    unrenderChild(meta);\n    this.splice((\"@this.children.byName.\" + (meta.target)), idx, 0, meta);\n    updateAnchors(this, meta.target);\n  } else {\n    if (!child.isolated) { child.viewmodel.attached(this.fragment); }\n  }\n\n  runloop.end();\n\n  promise.ractive = child;\n  return promise.then(function () { return child; });\n}\n\nfunction bubble() {\n  runloop.addFragment(this.instance.fragment);\n}\n\nfunction findNextNode() {\n  if (this.anchor) { return this.anchor.findNextNode(); }\n}\n\nfunction compute(path, computed) {\n  this.computed[path] = computed;\n  if (isString(computed) || isFunction(computed))\n    { computed = this.computed[path] = { get: computed }; }\n\n  var keys = splitKeypath(path);\n  if (!~path.indexOf('*')) {\n    var last = keys.pop();\n    return this.viewmodel.joinAll(keys).compute(last, computed);\n  } else {\n    computed.pattern = new RegExp(\n      '^' +\n        keys\n          .map(function (k) { return k.replace(/\\*\\*/g, '(.+)').replace(/\\*/g, '((?:\\\\\\\\.|[^\\\\.])+)'); })\n          .join('\\\\.') +\n        '$'\n    );\n  }\n}\n\nfunction Ractive$compute(path, computed) {\n  var promise = runloop.start();\n  var comp = compute.call(this, path, computed);\n\n  if (comp) {\n    var keys = splitKeypath(path);\n    if (keys.length === 1 && !comp.isReadonly) {\n      comp.set(this.viewmodel.value[keys[0]]);\n    }\n\n    var first = keys.reduce(function (a, c) { return a && a.childByKey[c]; }, this.viewmodel);\n    if (first) {\n      first.rebind(comp, first, false);\n      if (first.parent) { delete first.parent.childByKey[first.key]; }\n      fireShuffleTasks();\n    }\n  }\n\n  runloop.end();\n\n  return promise;\n}\n\nfunction Ractive$detach() {\n  if (this.isDetached) {\n    return this.el;\n  }\n\n  if (this.el) {\n    removeFromArray(this.el.__ractive_instances__, this);\n  }\n\n  this.el = this.fragment.detach();\n  this.isDetached = true;\n\n  hooks.detach.fire(this);\n  return this.el;\n}\n\nfunction detachChild(child) {\n  var children = this._children;\n  var meta, index;\n\n  var i = children.length;\n  while (i--) {\n    if (children[i].instance === child) {\n      index = i;\n      meta = children[i];\n      break;\n    }\n  }\n\n  if (!meta || child.parent !== this)\n    { throw new Error((\"Instance \" + (child._guid) + \" is not attached to this instance.\")); }\n\n  var promise = runloop.start();\n\n  if (meta.anchor) { meta.anchor.removeChild(meta); }\n  if (!child.isolated) { child.viewmodel.detached(); }\n\n  children.splice(index, 1);\n  if (meta.target) {\n    this.splice(\n      (\"@this.children.byName.\" + (meta.target)),\n      children.byName[meta.target].indexOf(meta),\n      1\n    );\n    updateAnchors(this, meta.target);\n  }\n  var rm = child.viewmodel.getRactiveModel();\n  rm.joinKey('parent', { lastLink: false }).unlink();\n  rm.joinKey('root', { lastLink: false }).link(rm);\n  child.root = child;\n  child.parent = null;\n  child.component = null;\n\n  hooks.detachchild.fire(child);\n\n  runloop.end();\n\n  promise.ractive = child;\n  return promise.then(function () { return child; });\n}\n\nfunction Ractive$find(selector, options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  if (!this.rendered)\n    { throw new Error(\n      (\"Cannot call ractive.find('\" + selector + \"') unless instance is rendered to the DOM\")\n    ); }\n\n  var node = this.fragment.find(selector, options);\n  if (node) { return node; }\n\n  if (options.remote) {\n    for (var i = 0; i < this._children.length; i++) {\n      if (!this$1._children[i].instance.fragment.rendered) { continue; }\n      node = this$1._children[i].instance.find(selector, options);\n      if (node) { return node; }\n    }\n  }\n}\n\nfunction Ractive$findAll(selector, options) {\n  if ( options === void 0 ) options = {};\n\n  if (!this.rendered)\n    { throw new Error(\n      (\"Cannot call ractive.findAll('\" + selector + \"', ...) unless instance is rendered to the DOM\")\n    ); }\n\n  if (!isArray(options.result)) { options.result = []; }\n\n  this.fragment.findAll(selector, options);\n\n  if (options.remote) {\n    // seach non-fragment children\n    this._children.forEach(function (c) {\n      if (!c.target && c.instance.fragment && c.instance.fragment.rendered) {\n        c.instance.findAll(selector, options);\n      }\n    });\n  }\n\n  return options.result;\n}\n\nfunction Ractive$findAllComponents(selector, options) {\n  if (!options && isObjectType(selector)) {\n    options = selector;\n    selector = '';\n  }\n\n  options = options || {};\n\n  if (!isArray(options.result)) { options.result = []; }\n\n  this.fragment.findAllComponents(selector, options);\n\n  if (options.remote) {\n    // search non-fragment children\n    this._children.forEach(function (c) {\n      if (!c.target && c.instance.fragment && c.instance.fragment.rendered) {\n        if (!selector || c.name === selector) {\n          options.result.push(c.instance);\n        }\n\n        c.instance.findAllComponents(selector, options);\n      }\n    });\n  }\n\n  return options.result;\n}\n\nfunction Ractive$findComponent(selector, options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  if (isObjectType(selector)) {\n    options = selector;\n    selector = '';\n  }\n\n  var child = this.fragment.findComponent(selector, options);\n  if (child) { return child; }\n\n  if (options.remote) {\n    if (!selector && this._children.length) { return this._children[0].instance; }\n    for (var i = 0; i < this._children.length; i++) {\n      // skip children that are or should be in an anchor\n      if (this$1._children[i].target) { continue; }\n      if (this$1._children[i].name === selector) { return this$1._children[i].instance; }\n      child = this$1._children[i].instance.findComponent(selector, options);\n      if (child) { return child; }\n    }\n  }\n}\n\nfunction Ractive$findContainer(selector) {\n  if (this.container) {\n    if (this.container.component && this.container.component.name === selector) {\n      return this.container;\n    } else {\n      return this.container.findContainer(selector);\n    }\n  }\n\n  return null;\n}\n\nfunction Ractive$findParent(selector) {\n  if (this.parent) {\n    if (this.parent.component && this.parent.component.name === selector) {\n      return this.parent;\n    } else {\n      return this.parent.findParent(selector);\n    }\n  }\n\n  return null;\n}\n\nfunction findElement(start, orComponent, name) {\n  if ( orComponent === void 0 ) orComponent = true;\n\n  while (\n    start &&\n    (start.type !== ELEMENT || (name && start.name !== name)) &&\n    (!orComponent || (start.type !== COMPONENT && start.type !== ANCHOR))\n  ) {\n    // start is a fragment - look at the owner\n    if (start.owner) { start = start.owner; }\n    else if (start.component || start.yield)\n      // start is a component or yielder - look at the container\n      { start = start.containerFragment || start.component.up; }\n    else if (start.parent)\n      // start is an item - look at the parent\n      { start = start.parent; }\n    else if (start.up)\n      // start is an item without a parent - look at the parent fragment\n      { start = start.up; }\n    else { start = undefined; }\n  }\n\n  return start;\n}\n\n// This function takes an array, the name of a mutator method, and the\n// arguments to call that mutator method with, and returns an array that\n// maps the old indices to their new indices.\n\n// So if you had something like this...\n//\n//     array = [ 'a', 'b', 'c', 'd' ];\n//     array.push( 'e' );\n//\n// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n// have changed. If you then did this...\n//\n//     array.unshift( 'z' );\n//\n// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n// one higher to make room for the 'z'. If you removed an item, the new index\n// would be -1...\n//\n//     array.splice( 2, 2 );\n//\n// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n//\n// This information is used to enable fast, non-destructive shuffling of list\n// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\nfunction getNewIndices(length, methodName, args) {\n  var newIndices = [];\n\n  var spliceArguments = getSpliceEquivalent(length, methodName, args);\n\n  if (!spliceArguments) {\n    return null; // TODO support reverse and sort?\n  }\n\n  var balance = spliceArguments.length - 2 - spliceArguments[1];\n\n  var removeStart = Math.min(length, spliceArguments[0]);\n  var removeEnd = removeStart + spliceArguments[1];\n  newIndices.startIndex = removeStart;\n\n  var i;\n  for (i = 0; i < removeStart; i += 1) {\n    newIndices.push(i);\n  }\n\n  for (; i < removeEnd; i += 1) {\n    newIndices.push(-1);\n  }\n\n  for (; i < length; i += 1) {\n    newIndices.push(i + balance);\n  }\n\n  // there is a net shift for the rest of the array starting with index + balance\n  if (balance !== 0) {\n    newIndices.touchedFrom = spliceArguments[0];\n  } else {\n    newIndices.touchedFrom = length;\n  }\n\n  return newIndices;\n}\n\n// The pop, push, shift an unshift methods can all be represented\n// as an equivalent splice\nfunction getSpliceEquivalent(length, methodName, args) {\n  switch (methodName) {\n    case 'splice':\n      if (args[0] !== undefined && args[0] < 0) {\n        args[0] = length + Math.max(args[0], -length);\n      }\n\n      if (isUndefined(args[0])) { args[0] = 0; }\n\n      while (args.length < 2) {\n        args.push(length - args[0]);\n      }\n\n      if (!isNumber(args[1])) {\n        args[1] = length - args[0];\n      }\n\n      // ensure we only remove elements that exist\n      args[1] = Math.min(args[1], length - args[0]);\n\n      return args;\n\n    case 'sort':\n    case 'reverse':\n      return null;\n\n    case 'pop':\n      if (length) {\n        return [length - 1, 1];\n      }\n      return [0, 0];\n\n    case 'push':\n      return [length, 0].concat(args);\n\n    case 'shift':\n      return [0, length ? 1 : 0];\n\n    case 'unshift':\n      return [0, 0].concat(args);\n  }\n}\n\nvar arrayProto = Array.prototype;\n\nfunction makeArrayMethod(methodName) {\n  function path(keypath) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    return model(this.viewmodel.joinAll(splitKeypath(keypath)), args);\n  }\n\n  function model(mdl, args) {\n    var array = mdl.get();\n\n    if (!isArray(array)) {\n      if (isUndefined(array)) {\n        array = [];\n        var result$1 = arrayProto[methodName].apply(array, args);\n        var promise$1 = runloop.start().then(function () { return result$1; });\n        mdl.set(array);\n        runloop.end();\n        return promise$1;\n      } else {\n        throw new Error(\n          (\"shuffle array method \" + methodName + \" called on non-array at \" + (mdl.getKeypath()))\n        );\n      }\n    }\n\n    var newIndices = getNewIndices(array.length, methodName, args);\n    var result = arrayProto[methodName].apply(array, args);\n\n    var promise = runloop.start().then(function () { return result; });\n    promise.result = result;\n\n    if (newIndices) {\n      if (mdl.shuffle) {\n        mdl.shuffle(newIndices);\n      } else {\n        // it's a computation, which don't have a shuffle, so just invalidate\n        mdl.mark();\n      }\n    } else {\n      mdl.set(result);\n    }\n\n    runloop.end();\n\n    return promise;\n  }\n\n  return { path: path, model: model };\n}\n\nfunction update$1(ractive, model, options) {\n  // if the parent is wrapped, the adaptor will need to be updated before\n  // updating on this keypath\n  if (model.parent && model.parent.wrapper) {\n    model.parent.adapt();\n  }\n\n  var promise = runloop.start();\n\n  model.mark(options && options.force);\n\n  // notify upstream of changes\n  model.notifyUpstream();\n\n  runloop.end();\n\n  hooks.update.fire(ractive, model);\n\n  return promise;\n}\n\nfunction Ractive$update(keypath, options) {\n  var opts, path;\n\n  if (isString(keypath)) {\n    path = splitKeypath(keypath);\n    opts = options;\n  } else {\n    opts = keypath;\n  }\n\n  return update$1(this, path ? this.viewmodel.joinAll(path) : this.viewmodel, opts);\n}\n\nvar modelPush = makeArrayMethod('push').model;\nvar modelPop = makeArrayMethod('pop').model;\nvar modelShift = makeArrayMethod('shift').model;\nvar modelUnshift = makeArrayMethod('unshift').model;\nvar modelSort = makeArrayMethod('sort').model;\nvar modelSplice = makeArrayMethod('splice').model;\nvar modelReverse = makeArrayMethod('reverse').model;\n\nvar localFragment = {};\n\nvar ContextData = (function (Model) {\n  function ContextData(options) {\n    Model.call(this, null, null);\n\n    this.isRoot = true;\n    this.root = this;\n    this.value = {};\n    this.ractive = options.ractive;\n    this.adaptors = [];\n    this.context = options.context;\n  }\n\n  if ( Model ) ContextData.__proto__ = Model;\n  var ContextData__proto__ = ContextData.prototype = Object.create( Model && Model.prototype );\n  ContextData__proto__.constructor = ContextData;\n\n  ContextData__proto__.getKeypath = function getKeypath () {\n    return '@context.data';\n  };\n\n  ContextData__proto__.rebound = function rebound () {};\n\n  return ContextData;\n}(Model));\n\nvar Context = function Context(fragment, element) {\n  this.fragment = fragment;\n  this.element = element || findElement(fragment);\n  this.node = this.element && this.element.node;\n  this.ractive = fragment.ractive;\n  this.root = this;\n};\nvar Context__proto__ = Context.prototype;\n\nvar prototypeAccessors = { decorators: {},_data: {} };\n\nprototypeAccessors.decorators.get = function () {\n  var items = {};\n  if (!this.element) { return items; }\n  this.element.decorators.forEach(function (d) { return (items[d.name] = d.handle); });\n  return items;\n};\n\nprototypeAccessors._data.get = function () {\n  return (\n    this.model ||\n    (this.root.model = new ContextData({\n      ractive: this.ractive,\n      context: this.root\n    }))\n  );\n};\n\n// the usual mutation suspects\nContext__proto__.add = function add (keypath, d, options) {\n  var num = isNumber(d) ? +d : 1;\n  var opts = isObjectType(d) ? d : options;\n  return set(\n    build$1(this, keypath, num).map(function (pair) {\n      var model = pair[0];\n        var val = pair[1];\n      var value = model.get();\n      if (!isNumeric(val) || !isNumeric(value)) { throw new Error('Cannot add non-numeric value'); }\n      return [model, value + val];\n    }),\n    opts\n  );\n};\n\nContext__proto__.animate = function animate$1 (keypath, value, options) {\n  var model = findModel(this, keypath).model;\n  return animate(this.ractive, model, value, options);\n};\n\nContext__proto__.find = function find (selector, opts) {\n  return this.fragment.find(selector, opts);\n};\n\nContext__proto__.findAll = function findAll (selector, opts) {\n  var result = [];\n  opts = opts || {};\n  opts.result = result;\n  this.fragment.findAll(selector, opts);\n  return result;\n};\n\nContext__proto__.findAllComponents = function findAllComponents (selector, opts) {\n  var result = [];\n  opts = opts || {};\n  opts.result = result;\n  this.fragment.findAllComponents(selector, opts);\n  return result;\n};\n\nContext__proto__.findComponent = function findComponent (selector, opts) {\n  return this.fragment.findComponent(selector, opts);\n};\n\n// get relative keypaths and values\nContext__proto__.get = function get (keypath) {\n  if (!keypath) { return this.fragment.findContext().get(true); }\n\n  var ref = findModel(this, keypath);\n    var model = ref.model;\n\n  return model ? model.get(true) : undefined;\n};\n\nContext__proto__.getParent = function getParent (component) {\n  var fragment = this.fragment;\n\n  if (!fragment.parent && component) { fragment = fragment.componentParent; }\n  else {\n    if (fragment.context) { fragment = findParentWithContext(fragment.parent); }\n    else {\n      fragment = findParentWithContext(fragment.parent);\n      if (fragment) {\n        if (!fragment.parent && component) { fragment = fragment.componentParent; }\n        else { fragment = findParentWithContext(fragment.parent); }\n      }\n    }\n  }\n\n  if (!fragment || fragment === this.fragment) { return; }\n  else { return fragment.getContext(); }\n};\n\nContext__proto__.hasListener = function hasListener (name, bubble) {\n  // if the owner is a component, start there because the nearest element\n  // may exist outside of the immediate context (yield)\n  var el = this.fragment.owner.component\n    ? this.fragment.owner\n    : this.element || this.fragment.owner;\n  var base;\n\n  do {\n    base = el.component || el;\n    if (base.template.t === ELEMENT) {\n      if (findEvent(base, name)) { return true; }\n    }\n    el = el.up && el.up.owner;\n    if (el && el.component) { el = el.component; }\n  } while (el && bubble);\n};\n\nContext__proto__.link = function link (source, dest) {\n  var there = findModel(this, source).model;\n  var here = findModel(this, dest).model;\n  var promise = runloop.start();\n  here.link(there, source);\n  runloop.end();\n  return promise;\n};\n\nContext__proto__.listen = function listen (event, handler) {\n  var el = this.element;\n  el.on(event, handler);\n  return {\n    cancel: function cancel() {\n      el.off(event, handler);\n    }\n  };\n};\n\nContext__proto__.observe = function observe (keypath, callback, options) {\n    if ( options === void 0 ) options = {};\n\n  if (isObject(keypath)) { options = callback || {}; }\n  options.fragment = this.fragment;\n  return this.ractive.observe(keypath, callback, options);\n};\n\nContext__proto__.observeOnce = function observeOnce (keypath, callback, options) {\n    if ( options === void 0 ) options = {};\n\n  if (isObject(keypath)) { options = callback || {}; }\n  options.fragment = this.fragment;\n  return this.ractive.observeOnce(keypath, callback, options);\n};\n\nContext__proto__.pop = function pop (keypath) {\n  return modelPop(findModel(this, keypath).model, []);\n};\n\nContext__proto__.push = function push (keypath) {\n    var values = [], len = arguments.length - 1;\n    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n  return modelPush(findModel(this, keypath).model, values);\n};\n\nContext__proto__.raise = function raise (name, event) {\n    var args = [], len = arguments.length - 2;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];\n\n  var el = this.element;\n  var ev;\n\n  while (el) {\n    if (el.component) { el = el.component; }\n    ev = findEvent(el, name);\n    if (ev) {\n      return ev.fire(\n        ev.element.getContext(\n          event || {},\n          event && !('original' in event) ? { original: {} } : {}\n        ),\n        args\n      );\n    }\n\n    el = el.up && el.up.owner;\n  }\n};\n\nContext__proto__.readLink = function readLink (keypath, options) {\n  return this.ractive.readLink(this.resolve(keypath), options);\n};\n\nContext__proto__.resolve = function resolve (path, ractive) {\n  var ref = findModel(this, path);\n    var model = ref.model;\n    var instance = ref.instance;\n  return model ? model.getKeypath(ractive || instance) : path;\n};\n\nContext__proto__.reverse = function reverse (keypath) {\n  return modelReverse(findModel(this, keypath).model, []);\n};\n\nContext__proto__.set = function set$2 (keypath, value, options) {\n  return set(build$1(this, keypath, value), options);\n};\n\nContext__proto__.shift = function shift (keypath) {\n  return modelShift(findModel(this, keypath).model, []);\n};\n\nContext__proto__.splice = function splice (keypath, index, drop) {\n    var add = [], len = arguments.length - 3;\n    while ( len-- > 0 ) add[ len ] = arguments[ len + 3 ];\n\n  add.unshift(index, drop);\n  return modelSplice(findModel(this, keypath).model, add);\n};\n\nContext__proto__.sort = function sort (keypath) {\n  return modelSort(findModel(this, keypath).model, []);\n};\n\nContext__proto__.subtract = function subtract (keypath, d, options) {\n  var num = isNumber(d) ? d : 1;\n  var opts = isObjectType(d) ? d : options;\n  return set(\n    build$1(this, keypath, num).map(function (pair) {\n      var model = pair[0];\n        var val = pair[1];\n      var value = model.get();\n      if (!isNumeric(val) || !isNumeric(value)) { throw new Error('Cannot add non-numeric value'); }\n      return [model, value - val];\n    }),\n    opts\n  );\n};\n\nContext__proto__.toggle = function toggle (keypath, options) {\n  var ref = findModel(this, keypath);\n    var model = ref.model;\n  return set([[model, !model.get()]], options);\n};\n\nContext__proto__.unlink = function unlink (dest) {\n  var here = findModel(this, dest).model;\n  var promise = runloop.start();\n  if (here.owner && here.owner._link) { here.owner.unlink(); }\n  runloop.end();\n  return promise;\n};\n\nContext__proto__.unlisten = function unlisten (event, handler) {\n  this.element.off(event, handler);\n};\n\nContext__proto__.unshift = function unshift (keypath) {\n    var add = [], len = arguments.length - 1;\n    while ( len-- > 0 ) add[ len ] = arguments[ len + 1 ];\n\n  return modelUnshift(findModel(this, keypath).model, add);\n};\n\nContext__proto__.update = function update (keypath, options) {\n  return update$1(this.ractive, findModel(this, keypath).model, options);\n};\n\nContext__proto__.updateModel = function updateModel (keypath, cascade) {\n  var ref = findModel(this, keypath);\n    var model = ref.model;\n  var promise = runloop.start();\n  model.updateFromBindings(cascade);\n  runloop.end();\n  return promise;\n};\n\n// two-way binding related helpers\nContext__proto__.isBound = function isBound () {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n  return !!model;\n};\n\nContext__proto__.getBindingPath = function getBindingPath (ractive) {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n    var instance = ref.instance;\n  if (model) { return model.getKeypath(ractive || instance); }\n};\n\nContext__proto__.getBinding = function getBinding () {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n  if (model) { return model.get(true); }\n};\n\nContext__proto__.getBindingModel = function getBindingModel (ctx) {\n  var el = ctx.element;\n  return { model: el.binding && el.binding.model, instance: el.up.ractive };\n};\n\nContext__proto__.setBinding = function setBinding (value) {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n  return set([[model, value]]);\n};\n\nObject.defineProperties( Context__proto__, prototypeAccessors );\n\nContext.forRactive = getRactiveContext;\n// circular deps are fun\nextern.Context = Context;\n\n// TODO: at some point perhaps this could support relative * keypaths?\nfunction build$1(ctx, keypath, value) {\n  var sets = [];\n\n  // set multiple keypaths in one go\n  if (isObject(keypath)) {\n    for (var k in keypath) {\n      if (hasOwn(keypath, k)) {\n        sets.push([findModel(ctx, k).model, keypath[k]]);\n      }\n    }\n  } else {\n    // set a single keypath\n    sets.push([findModel(ctx, keypath).model, value]);\n  }\n\n  return sets;\n}\n\nfunction findModel(ctx, path) {\n  var frag = ctx.fragment;\n\n  if (!isString(path)) {\n    return { model: frag.findContext(), instance: path };\n  }\n\n  return { model: resolveReference(frag, path), instance: frag.ractive };\n}\n\nfunction findEvent(el, name) {\n  return el.events && el.events.find && el.events.find(function (e) { return ~e.template.n.indexOf(name); });\n}\n\nfunction Ractive$fire(eventName) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  var ctx;\n\n  // watch for reproxy\n  if (args[0] instanceof Context) {\n    var proto = args.shift();\n    ctx = create(proto);\n    assign(ctx, proto);\n  } else if (isObjectType(args[0]) && (args[0] === null || args[0].constructor === Object)) {\n    ctx = Context.forRactive(this, args.shift());\n  } else {\n    ctx = Context.forRactive(this);\n  }\n\n  return fireEvent(this, eventName, ctx, args);\n}\n\nfunction Ractive$get(keypath, opts) {\n  if (!isString(keypath)) { return this.viewmodel.get(true, keypath); }\n\n  var keys = splitKeypath(keypath);\n  var key = keys[0];\n\n  var model;\n\n  if (!this.viewmodel.has(key)) {\n    // if this is an inline component, we may need to create\n    // an implicit mapping\n    if (this.component && !this.isolated) {\n      model = resolveReference(this.fragment || new FakeFragment(this), key);\n    }\n  }\n\n  model = this.viewmodel.joinAll(keys);\n  return model.get(true, opts);\n}\n\nfunction getLocalContext() {\n  if (localFragment.f) { return localFragment.f.getContext(); }\n}\n\nvar query = doc && doc.querySelector;\n\nfunction getContext$1(node) {\n  if (isString(node) && query) {\n    node = query.call(document, node);\n  }\n\n  var instances;\n  if (node) {\n    if (node._ractive) {\n      return node._ractive.proxy.getContext();\n    } else if ((instances = node.__ractive_instances__)) {\n      if (instances.length === 1) { return getRactiveContext(instances[0]); }\n    } else { return getContext$1(node.parentNode); }\n  }\n}\n\nfunction getContext$2(node, options) {\n  if (!node) { return getRactiveContext(this); }\n\n  if (isString(node)) {\n    node = this.find(node, options);\n  }\n\n  return getContext$1(node);\n}\n\nvar html = 'http://www.w3.org/1999/xhtml';\nvar mathml = 'http://www.w3.org/1998/Math/MathML';\nvar svg$1 = 'http://www.w3.org/2000/svg';\nvar xlink = 'http://www.w3.org/1999/xlink';\nvar xml = 'http://www.w3.org/XML/1998/namespace';\nvar xmlns = 'http://www.w3.org/2000/xmlns';\n\nvar namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };\n\nvar createElement;\nvar matches;\nvar div;\nvar methodNames;\nvar unprefixed;\nvar prefixed;\nvar i;\nvar j;\nvar makeFunction;\n\nvar customStr = isClient && 'registerElement' in doc;\nfunction wrap(is) {\n  return customStr ? is : { is: is };\n}\n\n// Test for SVG support\nif (!svg) {\n  /* istanbul ignore next */\n  createElement = function (type, ns, is) {\n    if (ns && ns !== html) {\n      throw \"This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://ractive.js.org/support/#svgs for more information\";\n    }\n\n    return is ? doc.createElement(type, wrap(is)) : doc.createElement(type);\n  };\n} else {\n  createElement = function (type, ns, is) {\n    if (!ns || ns === html) {\n      return is ? doc.createElement(type, wrap(is)) : doc.createElement(type);\n    }\n\n    return is ? doc.createElementNS(ns, type, wrap(is)) : doc.createElementNS(ns, type);\n  };\n}\n\nfunction createDocumentFragment() {\n  return doc.createDocumentFragment();\n}\n\nfunction getElement(input) {\n  var output;\n\n  if (!input || typeof input === 'boolean') {\n    return;\n  }\n\n  /* istanbul ignore next */\n  if (!win || !doc || !input) {\n    return null;\n  }\n\n  // We already have a DOM node - no work to do. (Duck typing alert!)\n  if (input.nodeType) {\n    return input;\n  }\n\n  // Get node from string\n  if (isString(input)) {\n    // try ID first\n    output = doc.getElementById(input);\n\n    // then as selector, if possible\n    if (!output && doc.querySelector) {\n      try {\n        output = doc.querySelector(input);\n      } catch (e) {\n        /* this space intentionally left blank */\n      }\n    }\n\n    // did it work?\n    if (output && output.nodeType) {\n      return output;\n    }\n  }\n\n  // If we've been given a collection (jQuery, Zepto etc), extract the first item\n  if (input[0] && input[0].nodeType) {\n    return input[0];\n  }\n\n  return null;\n}\n\nif (!isClient) {\n  matches = null;\n} else {\n  div = createElement('div');\n  methodNames = ['matches', 'matchesSelector'];\n\n  makeFunction = function(methodName) {\n    return function(node, selector) {\n      return node[methodName](selector);\n    };\n  };\n\n  i = methodNames.length;\n\n  while (i-- && !matches) {\n    unprefixed = methodNames[i];\n\n    if (div[unprefixed]) {\n      matches = makeFunction(unprefixed);\n    } else {\n      j = vendors.length;\n      while (j--) {\n        prefixed = vendors[i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);\n\n        if (div[prefixed]) {\n          matches = makeFunction(prefixed);\n          break;\n        }\n      }\n    }\n  }\n\n  // IE8... and apparently phantom some?\n  /* istanbul ignore next */\n  if (!matches) {\n    matches = function(node, selector) {\n      var parentNode, i;\n\n      parentNode = node.parentNode;\n\n      if (!parentNode) {\n        // empty dummy <div>\n        div.innerHTML = '';\n\n        parentNode = div;\n        node = node.cloneNode();\n\n        div.appendChild(node);\n      }\n\n      var nodes = parentNode.querySelectorAll(selector);\n\n      i = nodes.length;\n      while (i--) {\n        if (nodes[i] === node) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  }\n}\n\nfunction detachNode(node) {\n  // stupid ie\n  // eslint-disable-next-line valid-typeof\n  if (node && typeof node.parentNode !== 'unknown' && node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n\n  return node;\n}\n\nfunction safeToStringValue(value) {\n  return value == null || (isNumber(value) && isNaN(value)) || !value.toString ? '' : '' + value;\n}\n\nfunction safeAttributeString(string) {\n  return safeToStringValue(string)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction Ractive$insert(target, anchor) {\n  if (!this.fragment.rendered) {\n    // TODO create, and link to, documentation explaining this\n    throw new Error(\n      'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.'\n    );\n  }\n\n  target = getElement(target);\n  anchor = getElement(anchor) || null;\n\n  if (!target) {\n    throw new Error('You must specify a valid target to insert into');\n  }\n\n  target.insertBefore(this.detach(), anchor);\n  this.el = target;\n\n  (target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);\n  this.isDetached = false;\n\n  fireInsertHook(this);\n}\n\nfunction fireInsertHook(ractive) {\n  hooks.insert.fire(ractive);\n\n  ractive.findAllComponents('*').forEach(function (child) {\n    fireInsertHook(child.instance);\n  });\n}\n\nfunction link(there, here, options) {\n  var model;\n  var target = (options && (options.ractive || options.instance)) || this;\n\n  // may need to allow a mapping to resolve implicitly\n  var sourcePath = splitKeypath(there);\n  if (!target.viewmodel.has(sourcePath[0]) && target.component) {\n    model = resolveReference(target.component.up, sourcePath[0]);\n    model = model.joinAll(sourcePath.slice(1));\n  }\n\n  var src = model || target.viewmodel.joinAll(sourcePath);\n  var dest = this.viewmodel.joinAll(splitKeypath(here), { lastLink: false });\n\n  if (isUpstream(src, dest) || isUpstream(dest, src)) {\n    throw new Error('A keypath cannot be linked to itself.');\n  }\n\n  var promise = runloop.start();\n\n  dest.link(src, (options && options.keypath) || there);\n\n  runloop.end();\n\n  return promise;\n}\n\nfunction isUpstream(check, start) {\n  var model = start;\n  while (model) {\n    if (model === check || model.owner === check) { return true; }\n    model = model.target || model.parent;\n  }\n}\n\nvar Observer = function Observer(ractive, model, callback, options) {\n  this.context = options.context || ractive;\n  this.callback = callback;\n  this.ractive = ractive;\n  this.keypath = options.keypath;\n  this.options = options;\n\n  if (model) { this.resolved(model); }\n\n  if (isFunction(options.old)) {\n    this.oldContext = create(ractive);\n    this.oldFn = options.old;\n  }\n\n  if (options.init !== false) {\n    this.dirty = true;\n    this.dispatch();\n  } else {\n    updateOld(this);\n  }\n\n  this.dirty = false;\n};\nvar Observer__proto__ = Observer.prototype;\n\nObserver__proto__.cancel = function cancel () {\n  this.cancelled = true;\n  if (this.model) {\n    this.model.unregister(this);\n  } else {\n    this.resolver.unbind();\n  }\n  removeFromArray(this.ractive._observers, this);\n};\n\nObserver__proto__.dispatch = function dispatch () {\n  if (!this.cancelled) {\n    try {\n      this.callback.call(this.context, this.newValue, this.oldValue, this.keypath);\n    } catch (err) {\n      warnIfDebug(\n        (\"Failed to execute observer callback for '\" + (this.keypath) + \"': \" + (err.message || err))\n      );\n    }\n    updateOld(this, true);\n    this.dirty = false;\n  }\n};\n\nObserver__proto__.handleChange = function handleChange () {\n    var this$1 = this;\n\n  if (!this.dirty) {\n    var newValue = this.model.get();\n    if (isEqual(newValue, this.oldValue)) { return; }\n\n    this.newValue = newValue;\n\n    if (this.options.strict && this.newValue === this.oldValue) { return; }\n\n    runloop.addObserver(this, this.options.defer);\n    this.dirty = true;\n\n    if (this.options.once) { runloop.scheduleTask(function () { return this$1.cancel(); }); }\n  } else {\n    // make sure the newValue stays updated in case this observer gets touched multiple times in one loop\n    this.newValue = this.model.get();\n  }\n};\n\nObserver__proto__.rebind = function rebind (next, previous) {\n    var this$1 = this;\n\n  next = rebindMatch(this.keypath, next, previous);\n  if (next === this.model) { return false; }\n\n  if (this.model) { this.model.unregister(this); }\n  if (next) { next.addShuffleTask(function () { return this$1.resolved(next); }); }\n};\n\nObserver__proto__.resolved = function resolved (model) {\n  this.model = model;\n\n  this.oldValue = undefined;\n  this.newValue = model.get();\n\n  model.register(this);\n};\n\nfunction updateOld(observer, fresh) {\n  var next = fresh\n    ? observer.model\n      ? observer.model.get()\n      : observer.newValue\n    : observer.newValue;\n  try {\n    observer.oldValue = observer.oldFn\n      ? observer.oldFn.call(observer.oldContext, undefined, next, observer.keypath)\n      : next;\n  } catch (err) {\n    warnIfDebug(\n      (\"Failed to execute observer oldValue callback for '\" + (this.keypath) + \"': \" + (err.message || err))\n    );\n    observer.oldValue = next;\n  }\n}\n\nfunction joinKeys() {\n  var keys = [], len = arguments.length;\n  while ( len-- ) keys[ len ] = arguments[ len ];\n\n  return keys.map(escapeKey).join('.');\n}\n\nfunction splitKeypath$1(keypath) {\n  return splitKeypath(keypath).map(unescapeKey);\n}\n\nvar star$1 = /\\*+/g;\n\nvar PatternObserver = function PatternObserver(ractive, baseModel, keys$$1, callback, options) {\n  var this$1 = this;\n\n  this.context = options.context || ractive;\n  this.ractive = ractive;\n  this.baseModel = baseModel;\n  this.keys = keys$$1;\n  this.callback = callback;\n\n  var pattern = keys$$1.join('\\\\.').replace(star$1, '(.+)');\n  var baseKeypath = (this.baseKeypath = baseModel.getKeypath(ractive));\n  this.pattern = new RegExp((\"^\" + (baseKeypath ? baseKeypath + '\\\\.' : '') + pattern + \"$\"));\n  this.recursive = keys$$1.length === 1 && keys$$1[0] === '**';\n  if (this.recursive) { this.keys = ['*']; }\n  if (options.old) {\n    this.oldContext = create(ractive);\n    this.oldFn = options.old;\n  }\n\n  this.oldValues = {};\n  this.newValues = {};\n\n  this.defer = options.defer;\n  this.once = options.once;\n  this.strict = options.strict;\n\n  this.dirty = false;\n  this.changed = [];\n  this.cache = [];\n  this.partial = false;\n  this.links = options.links;\n\n  var models = baseModel.findMatches(this.keys);\n\n  models.forEach(function (model) {\n    this$1.newValues[model.getKeypath(this$1.ractive)] = model.get();\n  });\n\n  if (options.init !== false) {\n    this.dispatch();\n  } else {\n    updateOld$1(this, this.newValues);\n  }\n\n  baseModel.registerPatternObserver(this);\n};\nvar PatternObserver__proto__ = PatternObserver.prototype;\n\nPatternObserver__proto__.cancel = function cancel () {\n  this.baseModel.unregisterPatternObserver(this);\n  removeFromArray(this.ractive._observers, this);\n};\n\nPatternObserver__proto__.dispatch = function dispatch () {\n    var this$1 = this;\n\n  var newValues = this.newValues;\n  this.newValues = {};\n  keys(newValues).forEach(function (keypath) {\n    var newValue = newValues[keypath];\n    var oldValue = this$1.oldValues[keypath];\n\n    if (this$1.strict && newValue === oldValue) { return; }\n    if (isEqual(newValue, oldValue)) { return; }\n\n    var args = [newValue, oldValue, keypath];\n    if (keypath) {\n      var wildcards = this$1.pattern.exec(keypath);\n      if (wildcards) {\n        args = args.concat(wildcards.slice(1));\n      }\n    }\n\n    try {\n      this$1.callback.apply(this$1.context, args);\n    } catch (err) {\n      warnIfDebug(\n        (\"Failed to execute pattern observer callback for '\" + (this$1.keypath) + \"': \" + (err.message || err))\n      );\n    }\n  });\n\n  updateOld$1(this, newValues, this.partial);\n\n  this.dirty = false;\n};\n\nPatternObserver__proto__.notify = function notify (keys$$1) {\n  var path = joinKeys(keys$$1);\n  if (!~this.cache.indexOf(path)) {\n    this.cache.push(path);\n    this.changed.push(keys$$1);\n  }\n};\n\nPatternObserver__proto__.shuffle = function shuffle (newIndices) {\n    var this$1 = this;\n\n  if (!isArray(this.baseModel.value)) { return; }\n\n  var max = this.baseModel.value.length;\n\n  for (var i = 0; i < newIndices.length; i++) {\n    if (newIndices[i] === -1 || newIndices[i] === i) { continue; }\n    this$1.changed.push([i]);\n  }\n\n  for (var i$1 = newIndices.touchedFrom; i$1 < max; i$1++) {\n    this$1.changed.push([i$1]);\n  }\n};\n\nPatternObserver__proto__.handleChange = function handleChange () {\n    var this$1 = this;\n\n  if (!this.dirty || this.changed.length) {\n    if (!this.dirty) { this.newValues = {}; }\n\n    if (!this.changed.length) {\n      this.baseModel.findMatches(this.keys).forEach(function (model) {\n        var keypath = model.getKeypath(this$1.ractive);\n        this$1.newValues[keypath] = model.get();\n      });\n      this.partial = false;\n    } else {\n      var count = 0;\n\n      if (this.recursive) {\n        var changed = this.changed.slice();\n        this.changed.length = 0;\n        this.dirty = true;\n        changed.forEach(function (keys$$1) {\n          var model = this$1.baseModel.joinAll(keys$$1);\n          if (model.isLink && !this$1.links) { return; }\n          count++;\n          this$1.newValues[model.getKeypath(this$1.ractive)] = model.get();\n        });\n        this.dirty = false;\n      } else {\n        var ok = this.baseModel.isRoot\n          ? this.changed.map(function (keys$$1) { return keys$$1.map(escapeKey).join('.'); })\n          : this.changed.map(function (keys$$1) { return this$1.baseKeypath + '.' + keys$$1.map(escapeKey).join('.'); });\n\n        this.baseModel.findMatches(this.keys).forEach(function (model) {\n          var keypath = model.getKeypath(this$1.ractive);\n          var check = function (k) {\n            return (\n              (k.indexOf(keypath) === 0 &&\n                (k.length === keypath.length || k[keypath.length] === '.')) ||\n              (keypath.indexOf(k) === 0 &&\n                (k.length === keypath.length || keypath[k.length] === '.'))\n            );\n          };\n\n          // is this model on a changed keypath?\n          if (ok.filter(check).length) {\n            count++;\n            this$1.newValues[keypath] = model.get();\n          }\n        });\n      }\n\n      // no valid change triggered, so bail to avoid breakage\n      if (!count) { return; }\n\n      this.partial = true;\n    }\n\n    runloop.addObserver(this, this.defer);\n    this.dirty = true;\n    this.changed.length = 0;\n    this.cache = [];\n\n    if (this.once) { this.cancel(); }\n  }\n};\n\nfunction updateOld$1(observer, vals, partial) {\n  var olds = observer.oldValues;\n\n  if (observer.oldFn) {\n    if (!partial) { observer.oldValues = {}; }\n\n    keys(vals).forEach(function (k) {\n      var args = [olds[k], vals[k], k];\n      var parts = observer.pattern.exec(k);\n      if (parts) {\n        args.push.apply(args, parts.slice(1));\n      }\n      observer.oldValues[k] = observer.oldFn.apply(observer.oldContext, args);\n    });\n  } else {\n    if (partial) {\n      keys(vals).forEach(function (k) { return (olds[k] = vals[k]); });\n    } else {\n      observer.oldValues = vals;\n    }\n  }\n}\n\nfunction negativeOne() {\n  return -1;\n}\n\nvar ArrayObserver = function ArrayObserver(ractive, model, callback, options) {\n  this.ractive = ractive;\n  this.model = model;\n  this.keypath = model.getKeypath();\n  this.callback = callback;\n  this.options = options;\n\n  this.pending = null;\n\n  model.register(this);\n\n  if (options.init !== false) {\n    this.sliced = [];\n    this.shuffle([]);\n    this.dispatch();\n  } else {\n    this.sliced = this.slice();\n  }\n};\nvar ArrayObserver__proto__ = ArrayObserver.prototype;\n\nArrayObserver__proto__.cancel = function cancel () {\n  this.model.unregister(this);\n  removeFromArray(this.ractive._observers, this);\n};\n\nArrayObserver__proto__.dispatch = function dispatch () {\n  try {\n    this.callback(this.pending);\n  } catch (err) {\n    warnIfDebug(\n      (\"Failed to execute array observer callback for '\" + (this.keypath) + \"': \" + (err.message || err))\n    );\n  }\n  this.pending = null;\n  if (this.options.once) { this.cancel(); }\n};\n\nArrayObserver__proto__.handleChange = function handleChange (path) {\n  if (this.pending) {\n    // post-shuffle\n    runloop.addObserver(this, this.options.defer);\n  } else if (!path) {\n    // entire array changed\n    this.shuffle(this.sliced.map(negativeOne));\n    this.handleChange();\n  }\n};\n\nArrayObserver__proto__.shuffle = function shuffle (newIndices) {\n    var this$1 = this;\n\n  var newValue = this.slice();\n\n  var inserted = [];\n  var deleted = [];\n  var start;\n\n  var hadIndex = {};\n\n  newIndices.forEach(function (newIndex, oldIndex) {\n    hadIndex[newIndex] = true;\n\n    if (newIndex !== oldIndex && isUndefined(start)) {\n      start = oldIndex;\n    }\n\n    if (newIndex === -1) {\n      deleted.push(this$1.sliced[oldIndex]);\n    }\n  });\n\n  if (isUndefined(start)) { start = newIndices.length; }\n\n  var len = newValue.length;\n  for (var i = 0; i < len; i += 1) {\n    if (!hadIndex[i]) { inserted.push(newValue[i]); }\n  }\n\n  this.pending = { inserted: inserted, deleted: deleted, start: start };\n  this.sliced = newValue;\n};\n\nArrayObserver__proto__.slice = function slice () {\n  var value = this.model.get();\n  return isArray(value) ? value.slice() : [];\n};\n\nfunction observe(keypath, callback, options) {\n  var this$1 = this;\n\n  var observers = [];\n  var map;\n  var opts;\n\n  if (isObject(keypath)) {\n    map = keypath;\n    opts = callback || {};\n  } else {\n    if (isFunction(keypath)) {\n      map = { '': keypath };\n      opts = callback || {};\n    } else {\n      map = {};\n      map[keypath] = callback;\n      opts = options || {};\n    }\n  }\n\n  var silent = false;\n  keys(map).forEach(function (keypath) {\n    var callback = map[keypath];\n    var caller = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (silent) { return; }\n      return callback.apply(this, args);\n    };\n\n    var keypaths = keypath.split(' ');\n    if (keypaths.length > 1) { keypaths = keypaths.filter(function (k) { return k; }); }\n\n    keypaths.forEach(function (keypath) {\n      opts.keypath = keypath;\n      var observer = createObserver(this$1, keypath, caller, opts);\n      if (observer) { observers.push(observer); }\n    });\n  });\n\n  // add observers to the Ractive instance, so they can be\n  // cancelled on ractive.teardown()\n  this._observers.push.apply(this._observers, observers);\n\n  return {\n    cancel: function () { return observers.forEach(function (o) { return o.cancel(); }); },\n    isSilenced: function () { return silent; },\n    silence: function () { return (silent = true); },\n    resume: function () { return (silent = false); }\n  };\n}\n\nfunction createObserver(ractive, keypath, callback, options) {\n  var keys$$1 = splitKeypath(keypath);\n  var wildcardIndex = keys$$1.indexOf('*');\n  if (!~wildcardIndex) { wildcardIndex = keys$$1.indexOf('**'); }\n\n  options.fragment = options.fragment || ractive.fragment;\n\n  var model;\n  if (!options.fragment) {\n    model = ractive.viewmodel.joinKey(keys$$1[0]);\n  } else {\n    // .*.whatever relative wildcard is a special case because splitkeypath doesn't handle the leading .\n    if (~keys$$1[0].indexOf('.*')) {\n      model = options.fragment.findContext();\n      wildcardIndex = 0;\n      keys$$1[0] = keys$$1[0].slice(1);\n    } else {\n      model =\n        wildcardIndex === 0\n          ? options.fragment.findContext()\n          : resolveReference(options.fragment, keys$$1[0]);\n    }\n  }\n\n  // the model may not exist key\n  if (!model) { model = ractive.viewmodel.joinKey(keys$$1[0]); }\n\n  if (!~wildcardIndex) {\n    model = model.joinAll(keys$$1.slice(1));\n    if (options.array) {\n      return new ArrayObserver(ractive, model, callback, options);\n    } else {\n      return new Observer(ractive, model, callback, options);\n    }\n  } else {\n    var double = keys$$1.indexOf('**');\n    if (~double) {\n      if (double + 1 !== keys$$1.length || ~keys$$1.indexOf('*')) {\n        warnOnceIfDebug(\n          \"Recursive observers may only specify a single '**' at the end of the path.\"\n        );\n        return;\n      }\n    }\n\n    model = model.joinAll(keys$$1.slice(1, wildcardIndex));\n\n    return new PatternObserver(ractive, model, keys$$1.slice(wildcardIndex), callback, options);\n  }\n}\n\nvar onceOptions = { init: false, once: true };\n\nfunction observeOnce(keypath, callback, options) {\n  if (isObject(keypath) || isFunction(keypath)) {\n    options = assign(callback || {}, onceOptions);\n    return this.observe(keypath, options);\n  }\n\n  options = assign(options || {}, onceOptions);\n  return this.observe(keypath, callback, options);\n}\n\nvar trim = function (str) { return str.trim(); };\n\nvar notEmptyString = function (str) { return str !== ''; };\n\nfunction Ractive$off(eventName, callback) {\n  var this$1 = this;\n\n  // if no event is specified, remove _all_ event listeners\n  if (!eventName) {\n    this._subs = {};\n  } else {\n    // Handle multiple space-separated event names\n    var eventNames = eventName\n      .split(' ')\n      .map(trim)\n      .filter(notEmptyString);\n\n    eventNames.forEach(function (event) {\n      var subs = this$1._subs[event];\n      // if given a specific callback to remove, remove only it\n      if (subs && callback) {\n        var entry = subs.find(function (s) { return s.callback === callback; });\n        if (entry) {\n          removeFromArray(subs, entry);\n          entry.off = true;\n\n          if (event.indexOf('.')) { this$1._nsSubs--; }\n        }\n      } else if (subs) {\n        // otherwise, remove all listeners for this event\n        if (event.indexOf('.')) { this$1._nsSubs -= subs.length; }\n        subs.length = 0;\n      }\n    });\n  }\n\n  return this;\n}\n\nfunction Ractive$on(eventName, callback) {\n  var this$1 = this;\n\n  // eventName may already be a map\n  var map = isObjectType(eventName) ? eventName : {};\n  // or it may be a string along with a callback\n  if (isString(eventName)) { map[eventName] = callback; }\n\n  var silent = false;\n  var events = [];\n\n  var loop = function ( k ) {\n    var callback$1 = map[k];\n    var caller = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (!silent) { return callback$1.apply(this, args); }\n    };\n    var entry = {\n      callback: callback$1,\n      handler: caller\n    };\n\n    if (hasOwn(map, k)) {\n      var names = k\n        .split(' ')\n        .map(trim)\n        .filter(notEmptyString);\n      names.forEach(function (n) {\n        (this$1._subs[n] || (this$1._subs[n] = [])).push(entry);\n        if (n.indexOf('.')) { this$1._nsSubs++; }\n        events.push([n, entry]);\n      });\n    }\n  };\n\n  for (var k in map) loop( k );\n\n  return {\n    cancel: function () { return events.forEach(function (e) { return this$1.off(e[0], e[1].callback); }); },\n    isSilenced: function () { return silent; },\n    silence: function () { return (silent = true); },\n    resume: function () { return (silent = false); }\n  };\n}\n\nfunction Ractive$once(eventName, handler) {\n  var listener = this.on(eventName, function() {\n    handler.apply(this, arguments);\n    listener.cancel();\n  });\n\n  // so we can still do listener.cancel() manually\n  return listener;\n}\n\nvar pop = makeArrayMethod('pop').path;\n\nvar push = makeArrayMethod('push').path;\n\nfunction readLink(keypath, options) {\n  if ( options === void 0 ) options = {};\n\n  var path = splitKeypath(keypath);\n\n  if (this.viewmodel.has(path[0])) {\n    var model = this.viewmodel.joinAll(path);\n\n    if (!model.isLink) { return; }\n\n    while ((model = model.target) && options.canonical !== false) {\n      if (!model.isLink) { break; }\n    }\n\n    if (model) { return { ractive: model.root.ractive, keypath: model.getKeypath() }; }\n  }\n}\n\nvar PREFIX = '/* Ractive.js component styles */';\n\n// Holds current definitions of styles.\nvar styleDefinitions = [];\n\n// Flag to tell if we need to update the CSS\nvar isDirty = false;\n\n// These only make sense on the browser. See additional setup below.\nvar styleElement = null;\nvar useCssText = null;\n\n// flag to use multiple style tags\nvar _splitTag = false;\nfunction splitTag(v) {\n  return v === undefined ? _splitTag : (_splitTag = v);\n}\n\nfunction addCSS(styleDefinition) {\n  styleDefinitions.push(styleDefinition);\n  isDirty = true;\n}\n\nfunction applyCSS(force) {\n  var styleElement = style();\n\n  // Apply only seems to make sense when we're in the DOM. Server-side renders\n  // can call toCSS to get the updated CSS.\n  if (!styleElement || (!force && !isDirty)) { return; }\n\n  if (_splitTag) {\n    styleDefinitions.forEach(function (s) {\n      var el = getStyle(s.id);\n      if (el) {\n        var css = getCSS(s.id);\n        if (useCssText) {\n          el.styleSheet.cssText !== css && (el.styleSheet.cssText = css);\n        } else {\n          el.innerHTML !== css && (el.innerHTML = css);\n        }\n      }\n    });\n  } else {\n    if (useCssText) {\n      styleElement.styleSheet.cssText = getCSS(null);\n    } else {\n      styleElement.innerHTML = getCSS(null);\n    }\n  }\n\n  isDirty = false;\n}\n\nfunction getCSS(cssIds) {\n  if (cssIds && !isArray(cssIds)) { cssIds = [cssIds]; }\n  var filteredStyleDefinitions = cssIds\n    ? styleDefinitions.filter(function (style) { return ~cssIds.indexOf(style.id); })\n    : styleDefinitions;\n\n  filteredStyleDefinitions.forEach(function (d) { return (d.applied = true); });\n\n  return filteredStyleDefinitions.reduce(\n    function (styles, style) { return (\"\" + (styles ? (styles + \"\\n\\n/* {\" + (style.id) + \"} */\\n\" + (style.styles)) : '')); },\n    PREFIX\n  );\n}\n\nfunction getStyle(id) {\n  return doc && (doc.querySelector((\"[data-ractive-css=\\\"\" + id + \"\\\"]\")) || makeStyle(id));\n}\n\nfunction makeStyle(id) {\n  if (doc) {\n    var el = doc.createElement('style');\n    el.type = 'text/css';\n    el.setAttribute('data-ractive-css', id || '');\n\n    doc.getElementsByTagName('head')[0].appendChild(el);\n\n    if (useCssText === null) { useCssText = !!el.styleSheet; }\n\n    return el;\n  }\n}\n\nfunction style() {\n  if (!styleElement) { styleElement = makeStyle(); }\n\n  return styleElement;\n}\n\nvar adaptConfigurator = {\n  extend: function (Parent, proto, options) {\n    proto.adapt = combine(proto.adapt, ensureArray(options.adapt));\n  },\n\n  init: function init() {}\n};\n\nvar remove = /\\/\\*(?:[\\s\\S]*?)\\*\\//g;\nvar escape = /url\\(\\s*(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\1\\s*\\)|url\\((?:\\\\[\\s\\S]|[^)])*\\)|(['\"])(?:\\\\[\\s\\S]|(?!\\2).)*\\2/gi;\nvar value = /\\0(\\d+)/g;\n\n// Removes comments and strings from the given CSS to make it easier to parse.\n// Callback receives the cleaned CSS and a function which can be used to put\n// the removed strings back in place after parsing is done.\nfunction cleanCss(css, callback, additionalReplaceRules) {\n  if ( additionalReplaceRules === void 0 ) additionalReplaceRules = [];\n\n  var values = [];\n  var reconstruct = function (css) { return css.replace(value, function (match, n) { return values[n]; }); };\n  css = css.replace(escape, function (match) { return (\"\\u0000\" + (values.push(match) - 1)); }).replace(remove, '');\n\n  additionalReplaceRules.forEach(function (pattern) {\n    css = css.replace(pattern, function (match) { return (\"\\u0000\" + (values.push(match) - 1)); });\n  });\n\n  return callback(css, reconstruct);\n}\n\nvar selectorsPattern = /(?:^|\\}|\\{|\\x01)\\s*([^\\{\\}\\0\\x01]+)\\s*(?=\\{)/g;\nvar importPattern = /@import\\s*\\([^)]*\\)\\s*;?/gi;\nvar importEndPattern = /\\x01/g;\nvar keyframesDeclarationPattern = /@keyframes\\s+[^\\{\\}]+\\s*\\{(?:[^{}]+|\\{[^{}]+})*}/gi;\nvar selectorUnitPattern = /((?:(?:\\[[^\\]]+\\])|(?:[^\\s\\+\\>~:]))+)((?:::?[^\\s\\+\\>\\~\\(:]+(?:\\([^\\)]+\\))?)*\\s*[\\s\\+\\>\\~]?)\\s*/g;\nvar excludePattern = /^(?:@|\\d+%)/;\nvar dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n\nfunction trim$1(str) {\n  return str.trim();\n}\n\nfunction extractString(unit) {\n  return unit.str;\n}\n\nfunction transformSelector(selector, parent) {\n  var selectorUnits = [];\n  var match;\n\n  while ((match = selectorUnitPattern.exec(selector))) {\n    selectorUnits.push({\n      str: match[0],\n      base: match[1],\n      modifiers: match[2]\n    });\n  }\n\n  // For each simple selector within the selector, we need to create a version\n  // that a) combines with the id, and b) is inside the id\n  var base = selectorUnits.map(extractString);\n\n  var transformed = [];\n  var i = selectorUnits.length;\n\n  while (i--) {\n    var appended = base.slice();\n\n    // Pseudo-selectors should go after the attribute selector\n    var unit = selectorUnits[i];\n    appended[i] = unit.base + parent + unit.modifiers || '';\n\n    var prepended = base.slice();\n    prepended[i] = parent + ' ' + prepended[i];\n\n    transformed.push(appended.join(' '), prepended.join(' '));\n  }\n\n  return transformed.join(', ');\n}\n\nfunction transformCss(css, id) {\n  var dataAttr = \"[data-ractive-css~=\\\"{\" + id + \"}\\\"]\";\n\n  var transformed;\n\n  if (dataRvcGuidPattern.test(css)) {\n    transformed = css.replace(dataRvcGuidPattern, dataAttr);\n  } else {\n    transformed = cleanCss(\n      css,\n      function (css, reconstruct) {\n        css = css\n          .replace(importPattern, '$&\\x01')\n          .replace(selectorsPattern, function (match, $1) {\n            // don't transform at-rules and keyframe declarations\n            if (excludePattern.test($1)) { return match; }\n\n            var selectors = $1.split(',').map(trim$1);\n            var transformed =\n              selectors.map(function (selector) { return transformSelector(selector, dataAttr); }).join(', ') + ' ';\n\n            return match.replace($1, transformed);\n          })\n          .replace(importEndPattern, '');\n\n        return reconstruct(css);\n      },\n      [keyframesDeclarationPattern]\n    );\n  }\n\n  return transformed;\n}\n\nfunction s4() {\n  return Math.floor((1 + Math.random()) * 0x10000)\n    .toString(16)\n    .substring(1);\n}\n\nfunction uuid() {\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\nfunction setCSSData(keypath, value, options) {\n  var opts = isObjectType(keypath) ? value : options;\n  var model = this._cssModel;\n\n  model.locked = true;\n  var promise = set(build({ viewmodel: model }, keypath, value, true), opts);\n  model.locked = false;\n\n  var cascade = runloop.start();\n  this.extensions.forEach(function (e) {\n    var model = e._cssModel;\n    model.mark();\n    model.downstreamChanged('', 1);\n  });\n  runloop.end();\n\n  applyChanges(this, !opts || opts.apply !== false);\n\n  return promise.then(function () { return cascade; });\n}\n\nfunction applyChanges(component, apply) {\n  var local = recomputeCSS(component);\n  var child = component.extensions\n    .map(function (e) { return applyChanges(e, false); })\n    .reduce(function (a, c) { return c || a; }, false);\n\n  if (apply && (local || child)) {\n    var def = component._cssDef;\n    if (!def || (def && def.applied)) { applyCSS(true); }\n  }\n\n  return local || child;\n}\n\nfunction recomputeCSS(component) {\n  var css = component.css;\n\n  if (!isFunction(css)) { return; }\n\n  var def = component._cssDef;\n  var result = evalCSS(component, css);\n  var styles = def.transform ? transformCss(result, def.id) : result;\n\n  if (def.styles === styles) { return; }\n\n  def.styles = styles;\n\n  return true;\n}\n\nvar CSSModel = (function (SharedModel) {\n  function CSSModel(component) {\n    SharedModel.call(this, component.cssData, '@style');\n    this.component = component;\n  }\n\n  if ( SharedModel ) CSSModel.__proto__ = SharedModel;\n  var CSSModel__proto__ = CSSModel.prototype = Object.create( SharedModel && SharedModel.prototype );\n  CSSModel__proto__.constructor = CSSModel;\n\n  CSSModel__proto__.downstreamChanged = function downstreamChanged (path, depth) {\n    if (this.locked) { return; }\n\n    var component = this.component;\n\n    component.extensions.forEach(function (e) {\n      var model = e._cssModel;\n      model.mark();\n      model.downstreamChanged(path, depth || 1);\n    });\n\n    if (!depth) {\n      applyChanges(component, true);\n    }\n  };\n\n  return CSSModel;\n}(SharedModel));\n\nvar hasCurly = /\\{/;\nvar cssConfigurator = {\n  name: 'css',\n\n  // Called when creating a new component definition\n  extend: function (Parent, proto, options, Child) {\n    Child._cssIds = gatherIds(Parent);\n\n    defineProperty(Child, 'cssData', {\n      configurable: true,\n      value: assign(create(Parent.cssData), options.cssData || {})\n    });\n\n    defineProperty(Child, '_cssModel', {\n      configurable: true,\n      value: new CSSModel(Child)\n    });\n\n    if (options.css) { initCSS(options, Child, proto); }\n  },\n\n  // Called when creating a new component instance\n  init: function (Parent, target, options) {\n    if (!options.css) { return; }\n\n    warnIfDebug(\"\\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\\n\\nconst Component = Ractive.extend({\\n\\t...\\n\\tcss: '/* your css */',\\n\\t...\\n});\\n\\nconst componentInstance = new Component({ ... })\\n\\t\\t\");\n  }\n};\n\nfunction gatherIds(start) {\n  var cmp = start;\n  var ids = [];\n\n  while (cmp) {\n    if (cmp.prototype.cssId) { ids.push(cmp.prototype.cssId); }\n    cmp = cmp.Parent;\n  }\n\n  return ids;\n}\n\nfunction evalCSS(component, css) {\n  if (isString(css)) { return css; }\n\n  var cssData = component.cssData;\n  var model = component._cssModel;\n  var data = function data(path) {\n    return model.joinAll(splitKeypath(path)).get();\n  };\n  data.__proto__ = cssData;\n\n  var result = css.call(component, data);\n  return isString(result) ? result : '';\n}\n\nfunction initCSS(options, target, proto) {\n  var css =\n    options.css === true\n      ? ''\n      : isString(options.css) && !hasCurly.test(options.css)\n      ? getElement(options.css) || options.css\n      : options.css;\n  var cssProp = css;\n\n  var id = options.cssId || uuid();\n\n  if (isObjectType(css)) {\n    css = 'textContent' in css ? css.textContent : css.innerHTML;\n    cssProp = css;\n  } else if (isFunction(css)) {\n    cssProp = css;\n    css = evalCSS(target, css);\n  }\n\n  var def = {\n    transform: 'noCSSTransform' in options ? !options.noCSSTransform : !options.noCssTransform\n  };\n\n  defineProperty(target, '_cssDef', { configurable: true, value: def });\n\n  defineProperty(target, 'css', {\n    get: function get() {\n      return cssProp;\n    },\n    set: function set(next) {\n      cssProp = next;\n      var css = evalCSS(target, cssProp);\n      var styles = def.styles;\n      def.styles = def.transform ? transformCss(css, id) : css;\n      if (def.applied && styles !== def.styles) { applyCSS(true); }\n    }\n  });\n\n  def.styles = def.transform ? transformCss(css, id) : css;\n  def.id = proto.cssId = id;\n  target._cssIds.push(id);\n\n  addCSS(target._cssDef);\n}\n\nfunction validate(data) {\n  // Warn if userOptions.data is a non-POJO\n  if (data && data.constructor !== Object) {\n    if (isFunction(data)) {\n      // TODO do we need to support this in the new Ractive() case?\n    } else if (!isObjectType(data)) {\n      fatal((\"data option must be an object or a function, `\" + data + \"` is not valid\"));\n    } else {\n      warnIfDebug(\n        'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged'\n      );\n    }\n  }\n}\n\nvar dataConfigurator = {\n  name: 'data',\n\n  extend: function (Parent, proto, options) {\n    var key;\n    var value;\n\n    // check for non-primitives, which could cause mutation-related bugs\n    if (options.data && isObject(options.data)) {\n      for (key in options.data) {\n        value = options.data[key];\n\n        if (value && isObjectType(value)) {\n          if (isObject(value) || isArray(value)) {\n            warnIfDebug(\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\");\n          }\n        }\n      }\n    }\n\n    proto.data = combine$1(proto.data, options.data);\n  },\n\n  init: function (Parent, ractive, options) {\n    var result = combine$1(Parent.prototype.data, options.data);\n\n    if (isFunction(result)) { result = result.call(ractive); }\n\n    // bind functions to the ractive instance at the top level,\n    // unless it's a non-POJO (in which case alarm bells should ring)\n    if (result && result.constructor === Object) {\n      for (var prop in result) {\n        if (isFunction(result[prop])) {\n          var value = result[prop];\n          result[prop] = bind(value, ractive);\n          result[prop]._r_unbound = value;\n        }\n      }\n    }\n\n    return result || {};\n  },\n\n  reset: function reset(ractive) {\n    var result = this.init(ractive.constructor, ractive, ractive.viewmodel);\n    ractive.viewmodel.root.set(result);\n    return true;\n  }\n};\n\nfunction emptyData() {\n  return {};\n}\n\nfunction combine$1(parentValue, childValue) {\n  validate(childValue);\n\n  var parentIsFn = isFunction(parentValue);\n\n  // Very important, otherwise child instance can become\n  // the default data object on Ractive or a component.\n  // then ractive.set() ends up setting on the prototype!\n  if (!childValue && !parentIsFn) {\n    // this needs to be a function so that it can still inherit parent defaults\n    childValue = emptyData;\n  }\n\n  var childIsFn = isFunction(childValue);\n\n  // Fast path, where we just need to copy properties from\n  // parent to child\n  if (!parentIsFn && !childIsFn) {\n    return fromProperties(childValue, parentValue);\n  }\n\n  return function() {\n    var child = childIsFn ? callDataFunction(childValue, this) : childValue;\n    var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;\n\n    return fromProperties(child, parent);\n  };\n}\n\nfunction callDataFunction(fn, context) {\n  var data = fn.call(context);\n\n  if (!data) { return; }\n\n  if (!isObjectType(data)) {\n    fatal('Data function must return an object');\n  }\n\n  if (data.constructor !== Object) {\n    warnOnceIfDebug(\n      'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged'\n    );\n  }\n\n  return data;\n}\n\nfunction fromProperties(primary, secondary) {\n  if (primary && secondary) {\n    for (var key in secondary) {\n      if (!(key in primary)) {\n        primary[key] = secondary[key];\n      }\n    }\n\n    return primary;\n  }\n\n  return primary || secondary;\n}\n\nvar templateConfigurator = {\n  name: 'template',\n\n  extend: function extend(Parent, proto, options) {\n    // only assign if exists\n    if ('template' in options) {\n      var template = options.template;\n\n      if (isFunction(template)) {\n        proto.template = template;\n      } else {\n        proto.template = parseTemplate(template, proto);\n      }\n    }\n  },\n\n  init: function init(Parent, ractive, options) {\n    // TODO because of prototypal inheritance, we might just be able to use\n    // ractive.template, and not bother passing through the Parent object.\n    // At present that breaks the test mocks' expectations\n    var template = 'template' in options ? options.template : Parent.prototype.template;\n    template = template || { v: TEMPLATE_VERSION, t: [] };\n\n    if (isFunction(template)) {\n      var fn = template;\n      template = getDynamicTemplate(ractive, fn);\n\n      ractive._config.template = {\n        fn: fn,\n        result: template\n      };\n    }\n\n    template = parseTemplate(template, ractive);\n\n    // TODO the naming of this is confusing - ractive.template refers to [...],\n    // but Component.prototype.template refers to {v:1,t:[],p:[]}...\n    // it's unnecessary, because the developer never needs to access\n    // ractive.template\n    ractive.template = template.t;\n\n    if (template.p) {\n      extendPartials(ractive.partials, template.p);\n    }\n  },\n\n  reset: function reset(ractive) {\n    var result = resetValue(ractive);\n\n    if (result) {\n      var parsed = parseTemplate(result, ractive);\n\n      ractive.template = parsed.t;\n      extendPartials(ractive.partials, parsed.p, true);\n\n      return true;\n    }\n  }\n};\n\nfunction resetValue(ractive) {\n  var initial = ractive._config.template;\n\n  // If this isn't a dynamic template, there's nothing to do\n  if (!initial || !initial.fn) {\n    return;\n  }\n\n  var result = getDynamicTemplate(ractive, initial.fn);\n\n  // TODO deep equality check to prevent unnecessary re-rendering\n  // in the case of already-parsed templates\n  if (result !== initial.result) {\n    initial.result = result;\n    return result;\n  }\n}\n\nfunction getDynamicTemplate(ractive, fn) {\n  return fn.call(ractive, {\n    fromId: parser.fromId,\n    isParsed: parser.isParsed,\n    parse: function parse(template, options) {\n      if ( options === void 0 ) options = parser.getParseOptions(ractive);\n\n      return parser.parse(template, options);\n    }\n  });\n}\n\nfunction parseTemplate(template, ractive) {\n  if (isString(template)) {\n    // parse will validate and add expression functions\n    template = parseAsString(template, ractive);\n  } else {\n    // need to validate and add exp for already parsed template\n    validate$1(template);\n    addFunctions(template);\n  }\n\n  return template;\n}\n\nfunction parseAsString(template, ractive) {\n  // ID of an element containing the template?\n  if (template[0] === '#') {\n    template = parser.fromId(template);\n  }\n\n  return parser.parseFor(template, ractive);\n}\n\nfunction validate$1(template) {\n  // Check that the template even exists\n  if (template == undefined) {\n    throw new Error((\"The template cannot be \" + template + \".\"));\n  } else if (!isNumber(template.v)) {\n    // Check the parsed template has a version at all\n    throw new Error(\n      \"The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.\"\n    );\n  } else if (template.v !== TEMPLATE_VERSION) {\n    // Check we're using the correct version\n    throw new Error(\n      (\"Mismatched template version (expected \" + TEMPLATE_VERSION + \", got \" + (template.v) + \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\")\n    );\n  }\n}\n\nfunction extendPartials(existingPartials, newPartials, overwrite) {\n  if (!newPartials) { return; }\n\n  // TODO there's an ambiguity here - we need to overwrite in the `reset()`\n  // case, but not initially...\n\n  for (var key in newPartials) {\n    if (overwrite || !hasOwn(existingPartials, key)) {\n      existingPartials[key] = newPartials[key];\n    }\n  }\n}\n\nvar registryNames = [\n  'adaptors',\n  'components',\n  'computed',\n  'decorators',\n  'easing',\n  'events',\n  'helpers',\n  'interpolators',\n  'partials',\n  'transitions'\n];\n\nvar registriesOnDefaults = ['computed', 'helpers'];\n\nvar Registry = function Registry(name, useDefaults) {\n  this.name = name;\n  this.useDefaults = useDefaults;\n};\nvar Registry__proto__ = Registry.prototype;\n\nRegistry__proto__.extend = function extend (Parent, proto, options) {\n  var parent = this.useDefaults ? Parent.defaults : Parent;\n  var target = this.useDefaults ? proto : proto.constructor;\n  this.configure(parent, target, options);\n};\n\nRegistry__proto__.init = function init () {\n  // noop\n};\n\nRegistry__proto__.configure = function configure (Parent, target, options) {\n  var name = this.name;\n  var option = options[name];\n\n  var registry = create(Parent[name]);\n\n  assign(registry, option);\n\n  target[name] = registry;\n\n  if (name === 'partials' && target[name]) {\n    keys(target[name]).forEach(function (key) {\n      addFunctions(target[name][key]);\n    });\n  }\n};\n\nRegistry__proto__.reset = function reset (ractive) {\n  var registry = ractive[this.name];\n  var changed = false;\n\n  keys(registry).forEach(function (key) {\n    var item = registry[key];\n\n    if (item._fn) {\n      if (item._fn.isOwner) {\n        registry[key] = item._fn;\n      } else {\n        delete registry[key];\n      }\n      changed = true;\n    }\n  });\n\n  return changed;\n};\n\nvar registries = registryNames.map(function (name) {\n  var putInDefaults = registriesOnDefaults.indexOf(name) > -1;\n  return new Registry(name, putInDefaults);\n});\n\nfunction wrap$1(parent, name, method) {\n  if (!/_super/.test(method)) { return method; }\n\n  function wrapper() {\n    var superMethod = getSuperMethod(wrapper._parent, name);\n    var hasSuper = '_super' in this;\n    var oldSuper = this._super;\n\n    this._super = superMethod;\n\n    var result = method.apply(this, arguments);\n\n    if (hasSuper) {\n      this._super = oldSuper;\n    } else {\n      delete this._super;\n    }\n\n    return result;\n  }\n\n  wrapper._parent = parent;\n  wrapper._method = method;\n\n  return wrapper;\n}\n\nfunction getSuperMethod(parent, name) {\n  if (name in parent) {\n    var value = parent[name];\n\n    return isFunction(value) ? value : function () { return value; };\n  }\n\n  return noop;\n}\n\nfunction getMessage(deprecated, correct, isError) {\n  return (\n    \"options.\" + deprecated + \" has been deprecated in favour of options.\" + correct + \".\" +\n    (isError ? (\" You cannot specify both options, please use options.\" + correct + \".\") : '')\n  );\n}\n\nfunction deprecateOption(options, deprecatedOption, correct) {\n  if (deprecatedOption in options) {\n    if (!(correct in options)) {\n      warnIfDebug(getMessage(deprecatedOption, correct));\n      options[correct] = options[deprecatedOption];\n    } else {\n      throw new Error(getMessage(deprecatedOption, correct, true));\n    }\n  }\n}\n\nfunction deprecate(options) {\n  deprecateOption(options, 'beforeInit', 'onconstruct');\n  deprecateOption(options, 'init', 'onrender');\n  deprecateOption(options, 'complete', 'oncomplete');\n  deprecateOption(options, 'eventDefinitions', 'events');\n\n  // Using extend with Component instead of options,\n  // like Human.extend( Spider ) means adaptors as a registry\n  // gets copied to options. So we have to check if actually an array\n  if (isArray(options.adaptors)) {\n    deprecateOption(options, 'adaptors', 'adapt');\n  }\n}\n\nvar config = {\n  extend: function (Parent, proto, options, Child) { return configure('extend', Parent, proto, options, Child); },\n  init: function (Parent, ractive, options) { return configure('init', Parent, ractive, options); },\n  reset: function (ractive) { return order.filter(function (c) { return c.reset && c.reset(ractive); }).map(function (c) { return c.name; }); }\n};\n\nvar custom = {\n  adapt: adaptConfigurator,\n  computed: config,\n  css: cssConfigurator,\n  data: dataConfigurator,\n  helpers: config,\n  template: templateConfigurator\n};\n\nvar defaultKeys = keys(defaults);\n\nvar isStandardKey = makeObj(defaultKeys.filter(function (key) { return !custom[key]; }));\n\n// blacklisted keys that we don't double extend\nvar isBlacklisted = makeObj(\n  defaultKeys.concat(registries.map(function (r) { return r.name; }), ['on', 'observe', 'attributes', 'cssData', 'use'])\n);\n\nvar order = [].concat(\n  defaultKeys.filter(function (key) { return !registries[key] && !custom[key]; }),\n  registries,\n  //custom.data,\n  custom.template,\n  custom.css\n);\n\nfunction configure(method, Parent, target, options, Child) {\n  deprecate(options);\n\n  for (var key in options) {\n    if (hasOwn(isStandardKey, key)) {\n      var value = options[key];\n\n      // warn the developer if they passed a function and ignore its value\n\n      // NOTE: we allow some functions on \"el\" because we duck type element lists\n      // and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n      // function object as the result of querySelector methods\n      if (key !== 'el' && isFunction(value)) {\n        warnIfDebug(\n          (key + \" is a Ractive option that does not expect a function and will be ignored\"),\n          method === 'init' ? target : null\n        );\n      } else {\n        target[key] = value;\n      }\n    }\n  }\n\n  // disallow combination of `append` and `enhance`\n  if (target.append && target.enhance) {\n    throw new Error('Cannot use append and enhance at the same time');\n  }\n\n  registries.forEach(function (registry) {\n    registry[method](Parent, target, options, Child);\n  });\n\n  adaptConfigurator[method](Parent, target, options, Child);\n  templateConfigurator[method](Parent, target, options, Child);\n  cssConfigurator[method](Parent, target, options, Child);\n\n  extendOtherMethods(Parent.prototype, target, options);\n}\n\nvar _super = /\\b_super\\b/;\nfunction extendOtherMethods(parent, target, options) {\n  for (var key in options) {\n    if (!isBlacklisted[key] && hasOwn(options, key)) {\n      var member = options[key];\n\n      // if this is a method that overwrites a method, wrap it:\n      if (isFunction(member)) {\n        if (\n          (key in proto$9 ||\n            (key.slice(0, 2) === 'on' && key.slice(2) in hooks && key in target)) &&\n          !_super.test(member.toString())\n        ) {\n          warnIfDebug(\n            (\"Overriding Ractive prototype function '\" + key + \"' without calling the '\" + _super + \"' method can be very dangerous.\")\n          );\n        }\n        member = wrap$1(parent, key, member);\n      }\n\n      target[key] = member;\n    }\n  }\n}\n\nfunction makeObj(array) {\n  var obj = {};\n  array.forEach(function (x) { return (obj[x] = true); });\n  return obj;\n}\n\nvar Item = function Item(options) {\n  this.up = options.up;\n  this.ractive = options.up.ractive;\n\n  this.template = options.template;\n  this.index = options.index;\n  this.type = options.template.t;\n\n  this.dirty = false;\n};\nvar Item__proto__ = Item.prototype;\n\nItem__proto__.bubble = function bubble () {\n  if (!this.dirty) {\n    this.dirty = true;\n    this.up.bubble();\n  }\n};\n\nItem__proto__.destroyed = function destroyed () {\n  if (this.fragment) { this.fragment.destroyed(); }\n};\n\nItem__proto__.find = function find () {\n  return null;\n};\n\nItem__proto__.findComponent = function findComponent () {\n  return null;\n};\n\nItem__proto__.findNextNode = function findNextNode () {\n  return this.up.findNextNode(this);\n};\n\nItem__proto__.rebound = function rebound (update) {\n  if (this.fragment) { this.fragment.rebound(update); }\n};\n\nItem__proto__.shuffled = function shuffled () {\n  if (this.fragment) { this.fragment.shuffled(); }\n};\n\nItem__proto__.valueOf = function valueOf () {\n  return this.toString();\n};\n\nItem.prototype.findAll = noop;\nItem.prototype.findAllComponents = noop;\n\nvar ContainerItem = (function (Item) {\n  function ContainerItem(options) {\n    Item.call(this, options);\n  }\n\n  if ( Item ) ContainerItem.__proto__ = Item;\n  var ContainerItem__proto__ = ContainerItem.prototype = Object.create( Item && Item.prototype );\n  ContainerItem__proto__.constructor = ContainerItem;\n\n  ContainerItem__proto__.detach = function detach () {\n    return this.fragment ? this.fragment.detach() : createDocumentFragment();\n  };\n\n  ContainerItem__proto__.find = function find (selector) {\n    if (this.fragment) {\n      return this.fragment.find(selector);\n    }\n  };\n\n  ContainerItem__proto__.findAll = function findAll (selector, options) {\n    if (this.fragment) {\n      this.fragment.findAll(selector, options);\n    }\n  };\n\n  ContainerItem__proto__.findComponent = function findComponent (name) {\n    if (this.fragment) {\n      return this.fragment.findComponent(name);\n    }\n  };\n\n  ContainerItem__proto__.findAllComponents = function findAllComponents (name, options) {\n    if (this.fragment) {\n      this.fragment.findAllComponents(name, options);\n    }\n  };\n\n  ContainerItem__proto__.firstNode = function firstNode (skipParent) {\n    return this.fragment && this.fragment.firstNode(skipParent);\n  };\n\n  ContainerItem__proto__.toString = function toString (escape) {\n    return this.fragment ? this.fragment.toString(escape) : '';\n  };\n\n  return ContainerItem;\n}(Item));\n\nvar space = /\\s+/;\n\nfunction readStyle(css) {\n  if (!isString(css)) { return {}; }\n\n  return cleanCss(css, function (css, reconstruct) {\n    return css\n      .split(';')\n      .filter(function (rule) { return !!rule.trim(); })\n      .map(reconstruct)\n      .reduce(function (rules, rule) {\n        var i = rule.indexOf(':');\n        var name = rule.substr(0, i).trim();\n        rules[name] = rule.substr(i + 1).trim();\n        return rules;\n      }, {});\n  });\n}\n\nfunction readClass(str) {\n  var list = str.split(space);\n\n  // remove any empty entries\n  var i = list.length;\n  while (i--) {\n    if (!list[i]) { list.splice(i, 1); }\n  }\n\n  return list;\n}\n\nvar textTypes = [\n  undefined,\n  'text',\n  'search',\n  'url',\n  'email',\n  'hidden',\n  'password',\n  'search',\n  'reset',\n  'submit'\n];\n\nfunction getUpdateDelegate(attribute) {\n  var element = attribute.element;\n  var name = attribute.name;\n\n  if (name === 'value') {\n    if (attribute.interpolator) { attribute.interpolator.bound = true; }\n\n    // special case - selects\n    if (element.name === 'select' && name === 'value') {\n      return element.getAttribute('multiple') ? updateMultipleSelectValue : updateSelectValue;\n    }\n\n    if (element.name === 'textarea') { return updateStringValue; }\n\n    // special case - contenteditable\n    if (element.getAttribute('contenteditable') != null) { return updateContentEditableValue; }\n\n    // special case - <input>\n    if (element.name === 'input') {\n      var type = element.getAttribute('type');\n\n      // type='file' value='{{fileList}}'>\n      if (type === 'file') { return noop; } // read-only\n\n      // type='radio' name='{{twoway}}'\n      if (type === 'radio' && element.binding && element.binding.attribute.name === 'name')\n        { return updateRadioValue; }\n\n      if (~textTypes.indexOf(type)) { return updateStringValue; }\n    }\n\n    return updateValue;\n  }\n\n  var node = element.node;\n\n  // special case - <input type='radio' name='{{twoway}}' value='foo'>\n  if (attribute.isTwoway && name === 'name') {\n    if (node.type === 'radio') { return updateRadioName; }\n    if (node.type === 'checkbox') { return updateCheckboxName; }\n  }\n\n  if (name === 'style') { return updateStyleAttribute; }\n\n  if (name.indexOf('style-') === 0) { return updateInlineStyle; }\n\n  // special case - class names. IE fucks things up, again\n  if (name === 'class' && (!node.namespaceURI || node.namespaceURI === html))\n    { return updateClassName; }\n\n  if (name.indexOf('class-') === 0) { return updateInlineClass; }\n\n  if (attribute.isBoolean) {\n    var type$1 = element.getAttribute('type');\n    if (attribute.interpolator && name === 'checked' && (type$1 === 'checkbox' || type$1 === 'radio'))\n      { attribute.interpolator.bound = true; }\n    return updateBoolean;\n  }\n\n  if (attribute.namespace && attribute.namespace !== attribute.node.namespaceURI)\n    { return updateNamespacedAttribute; }\n\n  return updateAttribute;\n}\n\nfunction updateMultipleSelectValue(reset) {\n  var value = this.getValue();\n\n  if (!isArray(value)) { value = [value]; }\n\n  var options = this.node.options;\n  var i = options.length;\n\n  if (reset) {\n    while (i--) { options[i].selected = false; }\n  } else {\n    while (i--) {\n      var option = options[i];\n      var optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n      option.selected = arrayContains(value, optionValue);\n    }\n  }\n}\n\nfunction updateSelectValue(reset) {\n  var value = this.getValue();\n\n  if (!this.locked) {\n    // TODO is locked still a thing?\n    this.node._ractive.value = value;\n\n    var options = this.node.options;\n    var i = options.length;\n    var wasSelected = false;\n\n    if (reset) {\n      while (i--) { options[i].selected = false; }\n    } else {\n      while (i--) {\n        var option = options[i];\n        var optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n        if (option.disabled && option.selected) { wasSelected = true; }\n\n        if (optionValue == value) {\n          // double equals as we may be comparing numbers with strings\n          option.selected = true;\n          return;\n        }\n      }\n    }\n\n    if (!wasSelected) { this.node.selectedIndex = -1; }\n  }\n}\n\nfunction updateContentEditableValue(reset) {\n  var value = this.getValue();\n\n  if (!this.locked) {\n    if (reset) { this.node.innerHTML = ''; }\n    else { this.node.innerHTML = isUndefined(value) ? '' : value; }\n  }\n}\n\nfunction updateRadioValue(reset) {\n  var node = this.node;\n  var wasChecked = node.checked;\n\n  var value = this.getValue();\n\n  if (reset) { return (node.checked = false); }\n\n  //node.value = this.element.getAttribute( 'value' );\n  node.value = this.node._ractive.value = value;\n  node.checked = this.element.compare(value, this.element.getAttribute('name'));\n\n  // This is a special case - if the input was checked, and the value\n  // changed so that it's no longer checked, the twoway binding is\n  // most likely out of date. To fix it we have to jump through some\n  // hoops... this is a little kludgy but it works\n  if (wasChecked && !node.checked && this.element.binding && this.element.binding.rendered) {\n    this.element.binding.group.model.set(this.element.binding.group.getValue());\n  }\n}\n\nfunction updateValue(reset) {\n  if (!this.locked) {\n    if (reset) {\n      this.node.removeAttribute('value');\n      this.node.value = this.node._ractive.value = null;\n    } else {\n      var value = this.getValue();\n\n      this.node.value = this.node._ractive.value = value;\n      this.node.setAttribute('value', safeToStringValue(value));\n    }\n  }\n}\n\nfunction updateStringValue(reset) {\n  if (!this.locked) {\n    if (reset) {\n      this.node._ractive.value = '';\n      this.node.removeAttribute('value');\n    } else {\n      var value = this.getValue();\n\n      this.node._ractive.value = value;\n\n      var safeValue = safeToStringValue(value);\n\n      // fixes #3281  Safari moves caret position when setting an input value to the same value\n      if (this.node.value !== safeValue) {\n        this.node.value = safeValue;\n      }\n\n      this.node.setAttribute('value', safeValue);\n    }\n  }\n}\n\nfunction updateRadioName(reset) {\n  if (reset) { this.node.checked = false; }\n  else { this.node.checked = this.element.compare(this.getValue(), this.element.binding.getValue()); }\n}\n\nfunction updateCheckboxName(reset) {\n  var ref = this;\n  var element = ref.element;\n  var node = ref.node;\n  var binding = element.binding;\n\n  var value = this.getValue();\n  var valueAttribute = element.getAttribute('value');\n\n  if (!isArray(value)) {\n    binding.isChecked = node.checked = element.compare(value, valueAttribute);\n  } else {\n    var i = value.length;\n    while (i--) {\n      if (element.compare(valueAttribute, value[i])) {\n        binding.isChecked = node.checked = true;\n        return;\n      }\n    }\n    binding.isChecked = node.checked = false;\n  }\n}\n\nfunction updateStyleAttribute(reset) {\n  var props = reset ? {} : readStyle(this.getValue() || '');\n  var style = this.node.style;\n  var keys$$1 = keys(props);\n  var prev = this.previous || [];\n\n  var i = 0;\n  while (i < keys$$1.length) {\n    if (keys$$1[i] in style) {\n      var safe = props[keys$$1[i]].replace('!important', '');\n      style.setProperty(keys$$1[i], safe, safe.length !== props[keys$$1[i]].length ? 'important' : '');\n    }\n    i++;\n  }\n\n  // remove now-missing attrs\n  i = prev.length;\n  while (i--) {\n    if (!~keys$$1.indexOf(prev[i]) && prev[i] in style) { style.setProperty(prev[i], '', ''); }\n  }\n\n  this.previous = keys$$1;\n}\n\nfunction updateInlineStyle(reset) {\n  if (!this.style) {\n    this.style = hyphenateCamel(this.name.substr(6));\n  }\n\n  if (reset && this.node.style.getPropertyValue(this.style) !== this.last) { return; }\n\n  var value = reset ? '' : safeToStringValue(this.getValue());\n  var safe = value.replace('!important', '');\n  this.node.style.setProperty(this.style, safe, safe.length !== value.length ? 'important' : '');\n  this.last = this.node.style.getPropertyValue(this.style);\n}\n\nfunction updateClassName(reset) {\n  var value = reset ? [] : readClass(safeToStringValue(this.getValue()));\n\n  // watch out for weirdo svg elements\n  var cls = this.node.className;\n  cls = cls.baseVal !== undefined ? cls.baseVal : cls;\n\n  var attr = readClass(cls);\n  var prev = this.previous || [];\n\n  var className = value.concat(attr.filter(function (c) { return !~prev.indexOf(c); })).join(' ');\n\n  if (className !== cls) {\n    if (!isString(this.node.className)) {\n      this.node.className.baseVal = className;\n    } else {\n      this.node.className = className;\n    }\n  }\n\n  this.previous = value;\n}\n\nfunction updateInlineClass(reset) {\n  var name = this.name.substr(6);\n\n  // watch out for weirdo svg elements\n  var cls = this.node.className;\n  cls = cls.baseVal !== undefined ? cls.baseVal : cls;\n\n  var attr = readClass(cls);\n  var value = reset ? false : this.getValue();\n\n  if (!this.inlineClass) { this.inlineClass = name; }\n\n  if (value && !~attr.indexOf(name)) { attr.push(name); }\n  else if (!value && ~attr.indexOf(name)) { attr.splice(attr.indexOf(name), 1); }\n\n  if (!isString(this.node.className)) {\n    this.node.className.baseVal = attr.join(' ');\n  } else {\n    this.node.className = attr.join(' ');\n  }\n}\n\nfunction updateBoolean(reset) {\n  // with two-way binding, only update if the change wasn't initiated by the user\n  // otherwise the cursor will often be sent to the wrong place\n  if (!this.locked) {\n    if (reset) {\n      if (this.useProperty) { this.node[this.propertyName] = false; }\n      this.node.removeAttribute(this.propertyName);\n    } else {\n      if (this.useProperty) {\n        this.node[this.propertyName] = this.getValue();\n      } else {\n        var val = this.getValue();\n        if (val) {\n          this.node.setAttribute(this.propertyName, isString(val) ? val : '');\n        } else {\n          this.node.removeAttribute(this.propertyName);\n        }\n      }\n    }\n  }\n}\n\nfunction updateAttribute(reset) {\n  if (reset) {\n    if (this.node.getAttribute(this.name) === this.value) {\n      this.node.removeAttribute(this.name);\n    }\n  } else {\n    this.value = safeToStringValue(this.getString());\n    this.node.setAttribute(this.name, this.value);\n  }\n}\n\nfunction updateNamespacedAttribute(reset) {\n  if (reset) {\n    if (\n      this.value ===\n      this.node.getAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1))\n    ) {\n      this.node.removeAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1));\n    }\n  } else {\n    this.value = safeToStringValue(this.getString());\n    this.node.setAttributeNS(\n      this.namespace,\n      this.name.slice(this.name.indexOf(':') + 1),\n      this.value\n    );\n  }\n}\n\nvar propertyNames = {\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  bgcolor: 'bgColor',\n  class: 'className',\n  codebase: 'codeBase',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  datetime: 'dateTime',\n  dirname: 'dirName',\n  for: 'htmlFor',\n  'http-equiv': 'httpEquiv',\n  ismap: 'isMap',\n  maxlength: 'maxLength',\n  novalidate: 'noValidate',\n  pubdate: 'pubDate',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  tabindex: 'tabIndex',\n  usemap: 'useMap'\n};\n\nvar div$1 = doc ? createElement('div') : null;\n\nvar attributes = false;\nfunction inAttributes() {\n  return attributes;\n}\n\nvar ConditionalAttribute = (function (Item) {\n  function ConditionalAttribute(options) {\n    Item.call(this, options);\n\n    this.attributes = [];\n\n    this.owner = options.owner;\n\n    this.fragment = new Fragment({\n      ractive: this.ractive,\n      owner: this,\n      template: this.template\n    });\n\n    // this fragment can't participate in node-y things\n    this.fragment.findNextNode = noop;\n\n    this.dirty = false;\n  }\n\n  if ( Item ) ConditionalAttribute.__proto__ = Item;\n  var ConditionalAttribute__proto__ = ConditionalAttribute.prototype = Object.create( Item && Item.prototype );\n  ConditionalAttribute__proto__.constructor = ConditionalAttribute;\n\n  ConditionalAttribute__proto__.bind = function bind () {\n    this.fragment.bind();\n  };\n\n  ConditionalAttribute__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.dirty = true;\n      this.owner.bubble();\n    }\n  };\n\n  ConditionalAttribute__proto__.destroyed = function destroyed () {\n    this.unrender();\n  };\n\n  ConditionalAttribute__proto__.render = function render () {\n    this.node = this.owner.node;\n    if (this.node) {\n      this.isSvg = this.node.namespaceURI === svg$1;\n    }\n\n    attributes = true;\n    if (!this.rendered) { this.fragment.render(); }\n\n    this.rendered = true;\n    this.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js\n    this.update();\n    attributes = false;\n  };\n\n  ConditionalAttribute__proto__.toString = function toString () {\n    return this.fragment.toString();\n  };\n\n  ConditionalAttribute__proto__.unbind = function unbind (view) {\n    this.fragment.unbind(view);\n  };\n\n  ConditionalAttribute__proto__.unrender = function unrender () {\n    this.rendered = false;\n    this.fragment.unrender();\n  };\n\n  ConditionalAttribute__proto__.update = function update () {\n    var this$1 = this;\n\n    var str;\n    var attrs;\n\n    if (this.dirty) {\n      this.dirty = false;\n\n      var current = attributes;\n      attributes = true;\n      this.fragment.update();\n\n      if (this.rendered && this.node) {\n        str = this.fragment.toString();\n\n        attrs = parseAttributes(str, this.isSvg);\n\n        // any attributes that previously existed but no longer do\n        // must be removed\n        this.attributes\n          .filter(function (a) { return notIn(attrs, a); })\n          .forEach(function (a) {\n            this$1.node.removeAttribute(a.name);\n          });\n\n        attrs.forEach(function (a) {\n          this$1.node.setAttribute(a.name, a.value);\n        });\n\n        this.attributes = attrs;\n      }\n\n      attributes = current || false;\n    }\n  };\n\n  return ConditionalAttribute;\n}(Item));\n\nvar onlyWhitespace = /^\\s*$/;\nfunction parseAttributes(str, isSvg) {\n  if (onlyWhitespace.test(str)) { return []; }\n  var tagName = isSvg ? 'svg' : 'div';\n  return str\n    ? (div$1.innerHTML = \"<\" + tagName + \" \" + str + \"></\" + tagName + \">\") && toArray(div$1.childNodes[0].attributes)\n    : [];\n}\n\nfunction notIn(haystack, needle) {\n  var i = haystack.length;\n\n  while (i--) {\n    if (haystack[i].name === needle.name) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction lookupNamespace(node, prefix) {\n  var qualified = \"xmlns:\" + prefix;\n\n  while (node) {\n    if (node.hasAttribute && node.hasAttribute(qualified)) { return node.getAttribute(qualified); }\n    node = node.parentNode;\n  }\n\n  return namespaces[prefix];\n}\n\nvar attribute = false;\nfunction inAttribute() {\n  return attribute;\n}\n\nvar Attribute = (function (Item) {\n  function Attribute(options) {\n    Item.call(this, options);\n\n    this.name = options.template.n;\n    this.namespace = null;\n\n    this.owner = options.owner || options.up.owner || options.element || findElement(options.up);\n    this.element =\n      options.element || (this.owner.attributeByName ? this.owner : findElement(options.up));\n    this.up = options.up; // shared\n    this.ractive = this.up.ractive;\n\n    this.rendered = false;\n    this.updateDelegate = null;\n    this.fragment = null;\n\n    this.element.attributeByName[this.name] = this;\n\n    if (!isArray(options.template.f)) {\n      this.value = options.template.f;\n      if (this.value === 0) {\n        this.value = '';\n      } else if (isUndefined(this.value)) {\n        this.value = true;\n      }\n      return;\n    } else {\n      this.fragment = new Fragment({\n        owner: this,\n        template: options.template.f\n      });\n    }\n\n    this.interpolator =\n      this.fragment &&\n      this.fragment.items.length === 1 &&\n      this.fragment.items[0].type === INTERPOLATOR &&\n      this.fragment.items[0];\n\n    if (this.interpolator) { this.interpolator.owner = this; }\n  }\n\n  if ( Item ) Attribute.__proto__ = Item;\n  var Attribute__proto__ = Attribute.prototype = Object.create( Item && Item.prototype );\n  Attribute__proto__.constructor = Attribute;\n\n  Attribute__proto__.bind = function bind () {\n    if (this.fragment) {\n      this.fragment.bind();\n    }\n  };\n\n  Attribute__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.up.bubble();\n      this.element.bubble();\n      this.dirty = true;\n    }\n  };\n\n  Attribute__proto__.firstNode = function firstNode () {};\n\n  Attribute__proto__.getString = function getString () {\n    attribute = true;\n    var value = this.fragment\n      ? this.fragment.toString()\n      : this.value != null\n      ? '' + this.value\n      : '';\n    attribute = false;\n    return value;\n  };\n\n  // TODO could getValue ever be called for a static attribute,\n  // or can we assume that this.fragment exists?\n  Attribute__proto__.getValue = function getValue () {\n    attribute = true;\n    var value = this.fragment\n      ? this.fragment.valueOf()\n      : booleanAttributes[this.name.toLowerCase()]\n      ? true\n      : this.value;\n    attribute = false;\n    return value;\n  };\n\n  Attribute__proto__.render = function render () {\n    var node = this.element.node;\n    this.node = node;\n\n    // should we use direct property access, or setAttribute?\n    if (!node.namespaceURI || node.namespaceURI === namespaces.html) {\n      this.propertyName = propertyNames[this.name] || this.name;\n\n      if (node[this.propertyName] !== undefined) {\n        this.useProperty = true;\n      }\n\n      // is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n      // node.selected = true rather than node.setAttribute( 'selected', '' )\n      if (booleanAttributes[this.name.toLowerCase()] || this.isTwoway) {\n        this.isBoolean = true;\n      }\n\n      if (this.propertyName === 'value') {\n        node._ractive.value = this.value;\n      }\n    }\n\n    if (node.namespaceURI) {\n      var index = this.name.indexOf(':');\n      if (index !== -1) {\n        this.namespace = lookupNamespace(node, this.name.slice(0, index));\n      } else {\n        this.namespace = node.namespaceURI;\n      }\n    }\n\n    this.rendered = true;\n    this.updateDelegate = getUpdateDelegate(this);\n    this.updateDelegate();\n  };\n\n  Attribute__proto__.toString = function toString () {\n    if (inAttributes()) { return ''; }\n    attribute = true;\n\n    var value = this.getValue();\n\n    // Special case - select and textarea values (should not be stringified)\n    if (\n      this.name === 'value' &&\n      (this.element.getAttribute('contenteditable') !== undefined ||\n        (this.element.name === 'select' || this.element.name === 'textarea'))\n    ) {\n      return;\n    }\n\n    // Special case  bound radio `name` attributes\n    if (\n      this.name === 'name' &&\n      this.element.name === 'input' &&\n      this.interpolator &&\n      this.element.getAttribute('type') === 'radio'\n    ) {\n      return (\"name=\\\"{{\" + (this.interpolator.model.getKeypath()) + \"}}\\\"\");\n    }\n\n    // Special case - style and class attributes and directives\n    if (\n      this.owner === this.element &&\n      (this.name === 'style' || this.name === 'class' || this.style || this.inlineClass)\n    ) {\n      return;\n    }\n\n    if (\n      !this.rendered &&\n      this.owner === this.element &&\n      (!this.name.indexOf('style-') || !this.name.indexOf('class-'))\n    ) {\n      if (!this.name.indexOf('style-')) {\n        this.style = hyphenateCamel(this.name.substr(6));\n      } else {\n        this.inlineClass = this.name.substr(6);\n      }\n\n      return;\n    }\n\n    if (booleanAttributes[this.name.toLowerCase()])\n      { return value\n        ? isString(value)\n          ? ((this.name) + \"=\\\"\" + (safeAttributeString(value)) + \"\\\"\")\n          : this.name\n        : ''; }\n    if (value == null) { return ''; }\n\n    var str = safeAttributeString(this.getString());\n    attribute = false;\n\n    return str ? ((this.name) + \"=\\\"\" + str + \"\\\"\") : this.name;\n  };\n\n  Attribute__proto__.unbind = function unbind (view) {\n    if (this.fragment) { this.fragment.unbind(view); }\n  };\n\n  Attribute__proto__.unrender = function unrender () {\n    this.updateDelegate(true);\n\n    this.rendered = false;\n  };\n\n  Attribute__proto__.update = function update () {\n    if (this.dirty) {\n      var binding;\n      this.dirty = false;\n      if (this.fragment) { this.fragment.update(); }\n      if (this.rendered) { this.updateDelegate(); }\n      if (this.isTwoway && !this.locked) {\n        this.interpolator.twowayBinding.lastVal(true, this.interpolator.model.get());\n      } else if (this.name === 'value' && (binding = this.element.binding)) {\n        // special case: name bound element with dynamic value\n        var attr = binding.attribute;\n        if (attr && !attr.dirty && attr.rendered) {\n          this.element.binding.attribute.updateDelegate();\n        }\n      }\n    }\n  };\n\n  return Attribute;\n}(Item));\n\nvar BindingFlag = (function (Item) {\n  function BindingFlag(options) {\n    Item.call(this, options);\n\n    this.owner = options.owner || options.up.owner || findElement(options.up);\n    this.element = this.owner.attributeByName ? this.owner : findElement(options.up);\n    this.flag = options.template.v === 'l' ? 'lazy' : 'twoway';\n    this.bubbler = this.owner === this.element ? this.element : this.up;\n\n    if (this.element.type === ELEMENT) {\n      if (isArray(options.template.f)) {\n        this.fragment = new Fragment({\n          owner: this,\n          template: options.template.f\n        });\n      }\n\n      this.interpolator =\n        this.fragment &&\n        this.fragment.items.length === 1 &&\n        this.fragment.items[0].type === INTERPOLATOR &&\n        this.fragment.items[0];\n    }\n  }\n\n  if ( Item ) BindingFlag.__proto__ = Item;\n  var BindingFlag__proto__ = BindingFlag.prototype = Object.create( Item && Item.prototype );\n  BindingFlag__proto__.constructor = BindingFlag;\n\n  BindingFlag__proto__.bind = function bind () {\n    if (this.fragment) { this.fragment.bind(); }\n    set$1(this, this.getValue(), true);\n  };\n\n  BindingFlag__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.bubbler.bubble();\n      this.dirty = true;\n    }\n  };\n\n  BindingFlag__proto__.getValue = function getValue () {\n    if (this.fragment) { return this.fragment.valueOf(); }\n    else if ('value' in this) { return this.value; }\n    else if ('f' in this.template) { return this.template.f; }\n    else { return true; }\n  };\n\n  BindingFlag__proto__.render = function render () {\n    set$1(this, this.getValue(), true);\n  };\n\n  BindingFlag__proto__.toString = function toString () {\n    return '';\n  };\n\n  BindingFlag__proto__.unbind = function unbind (view) {\n    if (this.fragment) { this.fragment.unbind(view); }\n\n    delete this.element[this.flag];\n  };\n\n  BindingFlag__proto__.unrender = function unrender () {\n    if (this.element.rendered) { this.element.recreateTwowayBinding(); }\n  };\n\n  BindingFlag__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n      if (this.fragment) { this.fragment.update(); }\n      set$1(this, this.getValue(), true);\n    }\n  };\n\n  return BindingFlag;\n}(Item));\n\nfunction set$1(flag, value, update) {\n  if (value === 0) {\n    flag.value = true;\n  } else if (value === 'true') {\n    flag.value = true;\n  } else if (value === 'false' || value === '0') {\n    flag.value = false;\n  } else {\n    flag.value = value;\n  }\n\n  var current = flag.element[flag.flag];\n  flag.element[flag.flag] = flag.value;\n  if (update && !flag.element.attributes.binding && current !== flag.value) {\n    flag.element.recreateTwowayBinding();\n  }\n\n  return flag.value;\n}\n\nfunction Comment(options) {\n  Item.call(this, options);\n}\n\nvar proto$1 = create(Item.prototype);\n\nassign(proto$1, {\n  bind: noop,\n  unbind: noop,\n  update: noop,\n\n  detach: function detach() {\n    return detachNode(this.node);\n  },\n\n  firstNode: function firstNode() {\n    return this.node;\n  },\n\n  render: function render(target) {\n    this.rendered = true;\n\n    this.node = doc.createComment(this.template.c);\n    target.appendChild(this.node);\n  },\n\n  toString: function toString() {\n    return (\"<!-- \" + (this.template.c) + \" -->\");\n  },\n\n  unrender: function unrender(shouldDestroy) {\n    if (this.rendered && shouldDestroy) { this.detach(); }\n    this.rendered = false;\n  }\n});\n\nComment.prototype = proto$1;\n\n// Teardown. This goes through the root fragment and all its children, removing observers\n// and generally cleaning up after itself\n\nfunction Ractive$teardown() {\n  var this$1 = this;\n\n  if (this.torndown) {\n    warnIfDebug('ractive.teardown() was called on a Ractive instance that was already torn down');\n    return Promise.resolve();\n  }\n\n  this.shouldDestroy = true;\n  return teardown$1(this, function () { return (this$1.fragment.rendered ? this$1.unrender() : Promise.resolve()); });\n}\n\nfunction teardown$1(instance, getPromise) {\n  instance.torndown = true;\n  instance.fragment.unbind();\n  instance._observers.slice().forEach(cancel);\n\n  if (instance.el && instance.el.__ractive_instances__) {\n    removeFromArray(instance.el.__ractive_instances__, instance);\n  }\n\n  var promise = getPromise();\n\n  hooks.teardown.fire(instance);\n\n  promise.then(function () {\n    hooks.destruct.fire(instance);\n    instance.viewmodel.teardown();\n  });\n\n  return promise;\n}\n\nvar RactiveModel = (function (SharedModel) {\n  function RactiveModel(ractive) {\n    SharedModel.call(this, ractive, '@this');\n    this.ractive = ractive;\n  }\n\n  if ( SharedModel ) RactiveModel.__proto__ = SharedModel;\n  var RactiveModel__proto__ = RactiveModel.prototype = Object.create( SharedModel && SharedModel.prototype );\n  RactiveModel__proto__.constructor = RactiveModel;\n\n  RactiveModel__proto__.joinKey = function joinKey (key) {\n    var model = SharedModel.prototype.joinKey.call(this, key);\n\n    if ((key === 'root' || key === 'parent') && !model.isLink) { return initLink(model, key); }\n    else if (key === 'data') { return this.ractive.viewmodel; }\n    else if (key === 'cssData') { return this.ractive.constructor._cssModel; }\n\n    return model;\n  };\n\n  return RactiveModel;\n}(SharedModel));\n\nfunction initLink(model, key) {\n  model.applyValue = function(value) {\n    this.parent.value[key] = value;\n    if (value && value.viewmodel) {\n      this.link(value.viewmodel.getRactiveModel(), key);\n      this._link.markedAll();\n    } else {\n      this.link(create(Missing), key);\n      this._link.markedAll();\n    }\n  };\n\n  if (key === 'root') {\n    var mark = model.mark;\n    model.mark = function(force) {\n      if (this._marking) { return; }\n      this._marking = true;\n      mark.apply(this, force);\n      this._marking = false;\n    };\n  }\n\n  model.applyValue(model.parent.ractive[key], key);\n  model._link.set = function (v) { return model.applyValue(v); };\n  model._link.applyValue = function (v) { return model.applyValue(v); };\n\n  return model._link;\n}\n\nvar specialModels = {\n  '@this': function _this(root) {\n    return root.getRactiveModel();\n  },\n  '@global': function _global() {\n    return GlobalModel;\n  },\n  '@shared': function _shared() {\n    return SharedModel$1;\n  },\n  '@style': function _style(root) {\n    return root.getRactiveModel().joinKey('cssData');\n  },\n  '@helpers': function _helpers(root) {\n    return root.getHelpers();\n  }\n};\nspecialModels['@'] = specialModels['@this'];\n\nvar RootModel = (function (Model) {\n  function RootModel(options) {\n    Model.call(this, null, null);\n\n    this.isRoot = true;\n    this.root = this;\n    this.ractive = options.ractive; // TODO sever this link\n\n    this.value = options.data;\n    this.adaptors = options.adapt;\n    this.adapt();\n  }\n\n  if ( Model ) RootModel.__proto__ = Model;\n  var RootModel__proto__ = RootModel.prototype = Object.create( Model && Model.prototype );\n  RootModel__proto__.constructor = RootModel;\n\n  RootModel__proto__.attached = function attached (fragment) {\n    attachImplicits(this, fragment);\n  };\n\n  RootModel__proto__.createLink = function createLink (keypath, target, targetPath, options) {\n    var keys = splitKeypath(keypath);\n\n    var model = this;\n    while (keys.length) {\n      var key = keys.shift();\n      model = model.childByKey[key] || model.joinKey(key);\n    }\n\n    return model.link(target, targetPath, options);\n  };\n\n  RootModel__proto__.detached = function detached () {\n    detachImplicits(this);\n  };\n\n  RootModel__proto__.get = function get (shouldCapture, options) {\n    if (shouldCapture) { capture(this); }\n\n    if (!options || options.virtual !== false) {\n      return this.getVirtual();\n    } else {\n      return this.value;\n    }\n  };\n\n  RootModel__proto__.getHelpers = function getHelpers () {\n    if (!this.helpers) { this.helpers = new SharedModel(this.ractive.helpers, 'helpers', this.ractive); }\n    return this.helpers;\n  };\n\n  RootModel__proto__.getKeypath = function getKeypath () {\n    return '';\n  };\n\n  RootModel__proto__.getRactiveModel = function getRactiveModel () {\n    return this.ractiveModel || (this.ractiveModel = new RactiveModel(this.ractive));\n  };\n\n  RootModel__proto__.getValueChildren = function getValueChildren () {\n    var children = Model.prototype.getValueChildren.call(this, this.value);\n\n    this.children.forEach(function (child) {\n      if (child._link) {\n        var idx = children.indexOf(child);\n        if (~idx) { children.splice(idx, 1, child._link); }\n        else { children.push(child._link); }\n      }\n    });\n\n    return children;\n  };\n\n  RootModel__proto__.has = function has (key) {\n    if (key[0] === '~' && key[1] === '/') { key = key.slice(2); }\n    if (specialModels[key] || key === '') { return true; }\n\n    if (Model.prototype.has.call(this, key)) {\n      return true;\n    } else {\n      var unescapedKey = unescapeKey(key);\n\n      // mappings/links and computations\n      if (this.childByKey[unescapedKey] && this.childByKey[unescapedKey]._link) { return true; }\n    }\n  };\n\n  RootModel__proto__.joinKey = function joinKey (key, opts) {\n    if (key[0] === '~' && key[1] === '/') { key = key.slice(2); }\n\n    if (key[0] === '@') {\n      var fn = specialModels[key];\n      if (fn) { return fn(this); }\n    } else {\n      return Model.prototype.joinKey.call(this, key, opts);\n    }\n  };\n\n  RootModel__proto__.set = function set (value) {\n    // TODO wrapping root node is a baaaad idea. We should prevent this\n    var wrapper = this.wrapper;\n    if (wrapper) {\n      var shouldTeardown = !wrapper.reset || wrapper.reset(value) === false;\n\n      if (shouldTeardown) {\n        wrapper.teardown();\n        this.wrapper = null;\n        this.value = value;\n        this.adapt();\n      }\n    } else {\n      this.value = value;\n      this.adapt();\n    }\n\n    this.deps.forEach(handleChange);\n    this.children.forEach(mark);\n  };\n\n  RootModel__proto__.retrieve = function retrieve () {\n    return this.wrapper ? this.wrapper.get() : this.value;\n  };\n\n  RootModel__proto__.teardown = function teardown () {\n    Model.prototype.teardown.call(this);\n    this.ractiveModel && this.ractiveModel.teardown();\n  };\n\n  return RootModel;\n}(Model));\nRootModel.prototype.update = noop;\n\nfunction attachImplicits(model, fragment) {\n  if (model._link && model._link.implicit && model._link.isDetached()) {\n    model.attach(fragment);\n  }\n\n  // look for virtual children to relink and cascade\n  for (var k in model.childByKey) {\n    if (model.value) {\n      if (k in model.value) {\n        attachImplicits(model.childByKey[k], fragment);\n      } else if (!model.childByKey[k]._link || model.childByKey[k]._link.isDetached()) {\n        var mdl = resolveReference(fragment, k);\n        if (mdl) {\n          model.childByKey[k].link(mdl, k, { implicit: true });\n        }\n      }\n    }\n  }\n}\n\nfunction detachImplicits(model) {\n  if (model._link && model._link.implicit) {\n    model.unlink();\n  }\n\n  for (var k in model.childByKey) {\n    detachImplicits(model.childByKey[k]);\n  }\n}\n\nfunction subscribe(instance, options, type) {\n  var subs = (instance.constructor[(\"_\" + type)] || []).concat(toPairs(options[type] || []));\n  var single = type === 'on' ? 'once' : (type + \"Once\");\n\n  subs.forEach(function (ref) {\n    var target = ref[0];\n    var config = ref[1];\n\n    if (isFunction(config)) {\n      instance[type](target, config);\n    } else if (isObjectType(config) && isFunction(config.handler)) {\n      instance[config.once ? single : type](target, config.handler, create(config));\n    }\n  });\n}\n\nvar registryNames$1 = [\n  'adaptors',\n  'components',\n  'decorators',\n  'easing',\n  'events',\n  'interpolators',\n  'partials',\n  'transitions'\n];\n\nvar protoRegistries = ['computed', 'helpers'];\n\nvar uid = 0;\n\nfunction construct(ractive, options) {\n  if (Ractive.DEBUG) { welcome(); }\n\n  initialiseProperties(ractive);\n  handleAttributes(ractive);\n\n  // set up event subscribers\n  subscribe(ractive, options, 'on');\n\n  // if there's not a delegation setting, inherit from parent if it's not default\n  if (\n    !hasOwn(options, 'delegate') &&\n    ractive.parent &&\n    ractive.parent.delegate !== ractive.delegate\n  ) {\n    ractive.delegate = false;\n  }\n\n  // plugins that need to run at construct\n  if (isArray(options.use)) {\n    ractive.use.apply(ractive, options.use.filter(function (p) { return p.construct; }));\n  }\n\n  hooks.construct.fire(ractive, options);\n  if (options.onconstruct) { options.onconstruct.call(ractive, getRactiveContext(ractive), options); }\n\n  // Add registries\n  var i = registryNames$1.length;\n  while (i--) {\n    var name = registryNames$1[i];\n    ractive[name] = assign(create(ractive.constructor[name] || null), options[name]);\n  }\n\n  i = protoRegistries.length;\n  while (i--) {\n    var name$1 = protoRegistries[i];\n    ractive[name$1] = assign(create(ractive.constructor.prototype[name$1]), options[name$1]);\n  }\n\n  if (ractive._attributePartial) {\n    ractive.partials['extra-attributes'] = ractive._attributePartial;\n    delete ractive._attributePartial;\n  }\n\n  // Create a viewmodel\n  var viewmodel = new RootModel({\n    adapt: getAdaptors(ractive, ractive.adapt, options),\n    data: dataConfigurator.init(ractive.constructor, ractive, options),\n    ractive: ractive\n  });\n\n  // once resolved, share the adaptors array between the root model and instance\n  ractive.adapt = viewmodel.adaptors;\n\n  ractive.viewmodel = viewmodel;\n\n  for (var k in ractive.computed) {\n    compute.call(ractive, k, ractive.computed[k]);\n  }\n}\n\nfunction getAdaptors(ractive, protoAdapt, options) {\n  protoAdapt = protoAdapt.map(lookup);\n  var adapt = ensureArray(options.adapt).map(lookup);\n\n  var srcs = [protoAdapt, adapt];\n  if (ractive.parent && !ractive.isolated) {\n    srcs.push(ractive.parent.viewmodel.adaptors);\n  }\n\n  return combine.apply(null, srcs);\n\n  function lookup(adaptor) {\n    if (isString(adaptor)) {\n      adaptor = findInViewHierarchy('adaptors', ractive, adaptor);\n\n      if (!adaptor) {\n        fatal(missingPlugin(adaptor, 'adaptor'));\n      }\n    }\n\n    return adaptor;\n  }\n}\n\nfunction initialiseProperties(ractive) {\n  // Generate a unique identifier, for places where you'd use a weak map if it\n  // existed\n  ractive._guid = 'r-' + uid++;\n\n  // events\n  ractive._subs = create(null);\n  ractive._nsSubs = 0;\n\n  // storage for item configuration from instantiation to reset,\n  // like dynamic functions or original values\n  ractive._config = {};\n\n  // events\n  ractive.event = null;\n  ractive._eventQueue = [];\n\n  // observers\n  ractive._observers = [];\n\n  // external children\n  ractive._children = [];\n  ractive._children.byName = {};\n  ractive.children = ractive._children;\n\n  if (!ractive.component) {\n    ractive.root = ractive;\n    ractive.parent = ractive.container = null; // TODO container still applicable?\n  }\n}\n\nfunction handleAttributes(ractive) {\n  var component = ractive.component;\n  var attributes = ractive.constructor.attributes;\n\n  if (attributes && component) {\n    var tpl = component.template;\n    var attrs = tpl.m ? tpl.m.slice() : [];\n\n    // grab all of the passed attribute names\n    var props = attrs.filter(function (a) { return a.t === ATTRIBUTE; }).map(function (a) { return a.n; });\n\n    // warn about missing requireds\n    attributes.required.forEach(function (p) {\n      if (!~props.indexOf(p)) {\n        warnIfDebug((\"Component '\" + (component.name) + \"' requires attribute '\" + p + \"' to be provided\"));\n      }\n    });\n\n    // set up a partial containing non-property attributes\n    var all = attributes.optional.concat(attributes.required);\n    var partial = [];\n    var i = attrs.length;\n    while (i--) {\n      var a = attrs[i];\n      if (a.t === ATTRIBUTE && !~all.indexOf(a.n)) {\n        if (attributes.mapAll) {\n          // map the attribute if requested and make the extra attribute in the partial refer to the mapping\n          partial.unshift({\n            t: ATTRIBUTE,\n            n: a.n,\n            f: [{ t: INTERPOLATOR, r: (\"~/\" + (a.n)) }]\n          });\n        } else {\n          // transfer the attribute to the extra attributes partal\n          partial.unshift(attrs.splice(i, 1)[0]);\n        }\n      } else if (\n        !attributes.mapAll &&\n        (a.t === DECORATOR || a.t === TRANSITION || a.t === BINDING_FLAG)\n      ) {\n        partial.unshift(attrs.splice(i, 1)[0]);\n      }\n    }\n\n    if (partial.length) { component.template = { t: tpl.t, e: tpl.e, f: tpl.f, m: attrs, p: tpl.p }; }\n    ractive._attributePartial = partial;\n  }\n}\n\nvar Component = (function (Item) {\n  function Component(options, ComponentConstructor) {\n    var this$1 = this;\n\n    Item.call(this, options);\n    var template = options.template;\n    this.isAnchor = template.t === ANCHOR;\n    this.type = this.isAnchor ? ANCHOR : COMPONENT; // override ELEMENT from super\n    var attrs = template.m;\n\n    var partials = template.p || {};\n    if (!('content' in partials)) { partials.content = template.f || []; }\n    this._partials = partials; // TEMP\n\n    if (this.isAnchor) {\n      this.name = template.n;\n\n      this.addChild = addChild;\n      this.removeChild = removeChild;\n    } else {\n      var instance = new ComponentConstructor({ component: true });\n\n      this.instance = instance;\n      this.name = template.e;\n\n      if (instance.el || instance.target) {\n        warnIfDebug(\n          (\"The <\" + (this.name) + \"> component has a default '\" + (instance.el ? 'el' : 'target') + \"' property; it has been disregarded\")\n        );\n        instance.el = instance.target = null;\n      }\n\n      // find container\n      var fragment = options.up;\n      var container;\n      while (fragment) {\n        if (fragment.owner.type === YIELDER) {\n          container = fragment.owner.container;\n          break;\n        }\n\n        fragment = fragment.parent;\n      }\n\n      // add component-instance-specific properties\n      instance.parent = this.up.ractive;\n      instance.container = container || null;\n      instance.root = instance.parent.root;\n      instance.component = this;\n\n      construct(this.instance, { partials: partials }, ComponentConstructor);\n\n      // these can be modified during construction\n      template = this.template;\n      attrs = template.m;\n\n      // allow components that are so inclined to add programmatic mappings\n      if (isArray(this.mappings)) {\n        attrs = (attrs || []).concat(this.mappings);\n      } else if (isString(this.mappings)) {\n        attrs = (attrs || []).concat(parser.parse(this.mappings, { attributes: true }).t);\n      }\n\n      // for hackability, this could be an open option\n      // for any ractive instance, but for now, just\n      // for components and just for ractive...\n      instance._inlinePartials = partials;\n    }\n\n    this.attributeByName = {};\n    this.attributes = [];\n\n    if (attrs) {\n      var leftovers = [];\n      attrs.forEach(function (template) {\n        switch (template.t) {\n          case ATTRIBUTE:\n          case EVENT:\n            this$1.attributes.push(\n              createItem({\n                owner: this$1,\n                up: this$1.up,\n                template: template\n              })\n            );\n            break;\n\n          case TRANSITION:\n          case BINDING_FLAG:\n          case DECORATOR:\n            break;\n\n          default:\n            leftovers.push(template);\n            break;\n        }\n      });\n\n      if (leftovers.length) {\n        this.attributes.push(\n          new ConditionalAttribute({\n            owner: this,\n            up: this.up,\n            template: leftovers\n          })\n        );\n      }\n    }\n\n    this.eventHandlers = [];\n  }\n\n  if ( Item ) Component.__proto__ = Item;\n  var Component__proto__ = Component.prototype = Object.create( Item && Item.prototype );\n  Component__proto__.constructor = Component;\n\n  Component__proto__.bind = function bind () {\n    if (!this.isAnchor) {\n      this.attributes.forEach(bind$1);\n      this.eventHandlers.forEach(bind$1);\n\n      initialise(\n        this.instance,\n        {\n          partials: this._partials\n        },\n        {\n          cssIds: this.up.cssIds\n        }\n      );\n\n      if (this.instance.target || this.instance.el) { this.extern = true; }\n\n      this.bound = true;\n    }\n  };\n\n  Component__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.dirty = true;\n      this.up.bubble();\n    }\n  };\n\n  Component__proto__.destroyed = function destroyed () {\n    if (!this.isAnchor && this.instance.fragment) { this.instance.fragment.destroyed(); }\n  };\n\n  Component__proto__.detach = function detach () {\n    if (this.isAnchor) {\n      if (this.instance) { return this.instance.fragment.detach(); }\n      return createDocumentFragment();\n    }\n\n    return this.instance.fragment.detach();\n  };\n\n  Component__proto__.find = function find (selector, options) {\n    if (this.instance) { return this.instance.fragment.find(selector, options); }\n  };\n\n  Component__proto__.findAll = function findAll (selector, options) {\n    if (this.instance) { this.instance.fragment.findAll(selector, options); }\n  };\n\n  Component__proto__.findComponent = function findComponent (name, options) {\n    if (!name || this.name === name) { return this.instance; }\n\n    if (this.instance.fragment) {\n      return this.instance.fragment.findComponent(name, options);\n    }\n  };\n\n  Component__proto__.findAllComponents = function findAllComponents (name, options) {\n    var result = options.result;\n\n    if (this.instance && (!name || this.name === name)) {\n      result.push(this.instance);\n    }\n\n    if (this.instance) { this.instance.findAllComponents(name, options); }\n  };\n\n  Component__proto__.firstNode = function firstNode (skipParent) {\n    if (this.instance) { return this.instance.fragment.firstNode(skipParent); }\n  };\n\n  Component__proto__.getContext = function getContext () {\n    var assigns = [], len = arguments.length;\n    while ( len-- ) assigns[ len ] = arguments[ len ];\n\n    assigns.unshift(this.instance);\n    return getRactiveContext.apply(null, assigns);\n  };\n\n  Component__proto__.rebound = function rebound (update$$1) {\n    this.attributes.forEach(function (x) { return x.rebound(update$$1); });\n  };\n\n  Component__proto__.render = function render$2 (target, occupants) {\n    if (this.isAnchor) {\n      this.rendered = true;\n      this.target = target;\n\n      if (!checking.length) {\n        checking.push(this.ractive);\n        if (occupants) {\n          this.occupants = occupants;\n          checkAnchors();\n          this.occupants = null;\n        } else {\n          runloop.scheduleTask(checkAnchors, true);\n        }\n      }\n    } else {\n      this.attributes.forEach(render);\n      this.eventHandlers.forEach(render);\n\n      if (this.extern) {\n        this.instance.delegate = false;\n        this.instance.render();\n      } else {\n        render$1(this.instance, target, null, occupants);\n      }\n\n      this.rendered = true;\n    }\n  };\n\n  Component__proto__.shuffled = function shuffled () {\n    Item.prototype.shuffled.call(this);\n    this.instance &&\n      !this.instance.isolated &&\n      this.instance.fragment &&\n      this.instance.fragment.shuffled();\n  };\n\n  Component__proto__.toString = function toString () {\n    if (this.instance) { return this.instance.toHTML(); }\n  };\n\n  Component__proto__.unbind = function unbind$1 (view) {\n    if (!this.isAnchor) {\n      this.bound = false;\n\n      this.attributes.forEach(unbind);\n\n      if (view) { this.instance.fragment.unbind(); }\n      else { teardown$1(this.instance, function () { return runloop.promise(); }); }\n    }\n  };\n\n  Component__proto__.unrender = function unrender$1 (shouldDestroy) {\n    this.shouldDestroy = shouldDestroy;\n\n    if (this.isAnchor) {\n      if (this.item) { unrenderItem(this, this.item); }\n      this.target = null;\n      if (!checking.length) {\n        checking.push(this.ractive);\n        runloop.scheduleTask(checkAnchors, true);\n      }\n    } else {\n      this.instance.unrender();\n      this.instance.el = this.instance.target = null;\n      this.attributes.forEach(unrender);\n      this.eventHandlers.forEach(unrender);\n    }\n\n    this.rendered = false;\n  };\n\n  Component__proto__.update = function update$2 () {\n    this.dirty = false;\n    if (this.instance) {\n      this.instance.fragment.update();\n      this.attributes.forEach(update);\n      this.eventHandlers.forEach(update);\n    }\n  };\n\n  return Component;\n}(Item));\n\nfunction addChild(meta) {\n  if (this.item) { this.removeChild(this.item); }\n\n  var child = meta.instance;\n  meta.anchor = this;\n\n  meta.up = this.up;\n  meta.name = meta.nameOption || this.name;\n  this.name = meta.name;\n\n  if (!child.isolated) { child.viewmodel.attached(this.up); }\n\n  // render as necessary\n  if (this.rendered) {\n    renderItem(this, meta);\n  }\n}\n\nfunction removeChild(meta) {\n  // unrender as necessary\n  if (this.item === meta) {\n    unrenderItem(this, meta);\n    this.name = this.template.n;\n  }\n}\n\nfunction renderItem(anchor, meta) {\n  if (!anchor.rendered) { return; }\n\n  meta.shouldDestroy = false;\n  meta.up = anchor.up;\n\n  anchor.item = meta;\n  anchor.instance = meta.instance;\n  var nextNode = anchor.up.findNextNode(anchor);\n\n  if (meta.instance.fragment.rendered) {\n    meta.instance.unrender();\n  }\n\n  meta.partials = meta.instance.partials;\n  meta.instance.partials = assign(create(meta.partials), meta.partials, anchor._partials);\n\n  meta.instance.fragment.unbind(true);\n  meta.instance.fragment.componentParent = anchor.up;\n  meta.instance.fragment.bind(meta.instance.viewmodel);\n\n  anchor.attributes.forEach(bind$1);\n  anchor.eventHandlers.forEach(bind$1);\n  anchor.attributes.forEach(render);\n  anchor.eventHandlers.forEach(render);\n\n  var target = anchor.up.findParentNode();\n  render$1(meta.instance, target, target.contains(nextNode) ? nextNode : null, anchor.occupants);\n\n  if (meta.lastBound !== anchor) {\n    meta.lastBound = anchor;\n  }\n}\n\nfunction unrenderItem(anchor, meta) {\n  if (!anchor.rendered) { return; }\n\n  meta.shouldDestroy = true;\n  meta.instance.unrender();\n\n  anchor.eventHandlers.forEach(unrender);\n  anchor.attributes.forEach(unrender);\n  anchor.eventHandlers.forEach(unbind);\n  anchor.attributes.forEach(unbind);\n\n  meta.instance.el = meta.instance.anchor = null;\n  meta.instance.fragment.componentParent = null;\n  meta.up = null;\n  meta.anchor = null;\n  anchor.item = null;\n  anchor.instance = null;\n}\n\nvar checking = [];\nfunction checkAnchors() {\n  var list = checking;\n  checking = [];\n\n  list.forEach(updateAnchors);\n}\n\nvar ComputationChild = (function (Model) {\n  function ComputationChild(parent, key) {\n    Model.call(this, parent, key);\n\n    this.isReadonly = !this.root.ractive.syncComputedChildren;\n    this.dirty = true;\n    this.isComputed = true;\n  }\n\n  if ( Model ) ComputationChild.__proto__ = Model;\n  var ComputationChild__proto__ = ComputationChild.prototype = Object.create( Model && Model.prototype );\n  ComputationChild__proto__.constructor = ComputationChild;\n\n  var prototypeAccessors$1 = { setRoot: {} };\n\n  prototypeAccessors$1.setRoot.get = function () {\n    return this.parent.setRoot;\n  };\n\n  ComputationChild__proto__.applyValue = function applyValue (value) {\n    Model.prototype.applyValue.call(this, value);\n\n    if (!this.isReadonly) {\n      var source = this.parent;\n      // computed models don't have a shuffle method\n      while (source && source.shuffle) {\n        source = source.parent;\n      }\n\n      if (source) {\n        source.dependencies.forEach(mark);\n      }\n    }\n\n    if (this.setRoot) {\n      this.setRoot.set(this.setRoot.value);\n    }\n  };\n\n  ComputationChild__proto__.get = function get (shouldCapture, opts) {\n    if (shouldCapture) { capture(this); }\n\n    if (this.dirty) {\n      var parentValue = this.parent.get();\n      this.value = parentValue ? parentValue[this.key] : undefined;\n      if (this.wrapper) { this.newWrapperValue = this.value; }\n      this.adapt();\n    }\n\n    this.dirty = false;\n\n    return (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture) && this.wrapper\n      ? this.wrapperValue\n      : this.value;\n  };\n\n  ComputationChild__proto__.handleChange = function handleChange$2 () {\n    if (this.dirty) {\n      this.deps.forEach(handleChange);\n      return;\n    }\n\n    this.dirty = true;\n\n    if (this.boundValue) { this.boundValue = null; }\n\n    this.links.forEach(marked);\n    this.deps.forEach(handleChange);\n    this.children.forEach(handleChange);\n  };\n\n  ComputationChild__proto__.joinKey = function joinKey (key) {\n    if (isUndefined(key) || key === '') { return this; }\n\n    if (!hasOwn(this.childByKey, key)) {\n      var child = new ComputationChild(this, key);\n      this.children.push(child);\n      this.childByKey[key] = child;\n    }\n\n    return this.childByKey[key];\n  };\n\n  Object.defineProperties( ComputationChild__proto__, prototypeAccessors$1 );\n\n  return ComputationChild;\n}(Model));\n\n/* global console */\n/* eslint no-console:\"off\" */\n\nvar Computation = (function (Model) {\n  function Computation(parent, signature, key) {\n    Model.call(this, parent, key);\n\n    this.signature = signature;\n\n    this.isReadonly = !this.signature.setter;\n    this.isComputed = true;\n\n    this.dependencies = [];\n\n    this.children = [];\n    this.childByKey = {};\n\n    this.deps = [];\n\n    this.dirty = true;\n\n    // TODO: is there a less hackish way to do this?\n    this.shuffle = undefined;\n  }\n\n  if ( Model ) Computation.__proto__ = Model;\n  var Computation__proto__ = Computation.prototype = Object.create( Model && Model.prototype );\n  Computation__proto__.constructor = Computation;\n\n  var prototypeAccessors$2 = { setRoot: {} };\n\n  prototypeAccessors$2.setRoot.get = function () {\n    if (this.signature.setter) { return this; }\n  };\n\n  Computation__proto__.get = function get (shouldCapture, opts) {\n    if (shouldCapture) { capture(this); }\n\n    if (this.dirty) {\n      var old = this.value;\n      this.value = this.getValue();\n      // this may cause a view somewhere to update, so it must be in a runloop\n      if (!runloop.active()) {\n        runloop.start();\n        if (!isEqual(old, this.value)) { this.notifyUpstream(); }\n        runloop.end();\n      } else {\n        if (!isEqual(old, this.value)) { this.notifyUpstream(); }\n      }\n      if (this.wrapper) { this.newWrapperValue = this.value; }\n      this.adapt();\n      this.dirty = false;\n    }\n\n    // if capturing, this value needs to be unwrapped because it's for external use\n    return maybeBind(\n      this,\n      // if unwrap is supplied, it overrides capture\n      this.wrapper && (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture)\n        ? this.wrapperValue\n        : this.value,\n      !opts || opts.shouldBind !== false\n    );\n  };\n\n  Computation__proto__.getContext = function getContext () {\n    return this.parent.isRoot ? this.root.ractive : this.parent.get(false, noVirtual);\n  };\n\n  Computation__proto__.getValue = function getValue () {\n    startCapturing();\n    var result;\n\n    try {\n      result = this.signature.getter.call(this.root.ractive, this.getContext(), this.getKeypath());\n    } catch (err) {\n      warnIfDebug((\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)));\n\n      // TODO this is all well and good in Chrome, but...\n      // ...also, should encapsulate this stuff better, and only\n      // show it if Ractive.DEBUG\n      if (hasConsole) {\n        if (console.groupCollapsed)\n          { console.groupCollapsed(\n            '%cshow details',\n            'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'\n          ); }\n        var sig = this.signature;\n        console.error(\n          ((err.name) + \": \" + (err.message) + \"\\n\\n\" + (sig.getterString) + (sig.getterUseStack ? '\\n\\n' + err.stack : ''))\n        );\n        if (console.groupCollapsed) { console.groupEnd(); }\n      }\n    }\n\n    var dependencies = stopCapturing();\n    if (this.parent.keypath && !~dependencies.indexOf(this.parent)) { dependencies.push(this.parent); }\n    this.setDependencies(dependencies);\n\n    return result;\n  };\n\n  Computation__proto__.mark = function mark () {\n    this.handleChange();\n  };\n\n  Computation__proto__.rebind = function rebind (next, previous) {\n    // computations will grab all of their deps again automagically\n    if (next !== previous) { this.handleChange(); }\n  };\n\n  Computation__proto__.set = function set (value) {\n    if (this.isReadonly) {\n      throw new Error((\"Cannot set read-only computed value '\" + (this.key) + \"'\"));\n    }\n\n    this.signature.setter(value, this.getContext(), this.getKeypath());\n    this.mark();\n  };\n\n  Computation__proto__.setDependencies = function setDependencies (dependencies) {\n    var this$1 = this;\n\n    // unregister any soft dependencies we no longer have\n    var i = this.dependencies.length;\n    while (i--) {\n      var model = this$1.dependencies[i];\n      if (!~dependencies.indexOf(model)) { model.unregister(this$1); }\n    }\n\n    // and add any new ones\n    i = dependencies.length;\n    while (i--) {\n      var model$1 = dependencies[i];\n      if (!~this$1.dependencies.indexOf(model$1)) { model$1.register(this$1); }\n    }\n\n    this.dependencies = dependencies;\n  };\n\n  Computation__proto__.teardown = function teardown () {\n    var this$1 = this;\n\n    var i = this.dependencies.length;\n    while (i--) {\n      if (this$1.dependencies[i]) { this$1.dependencies[i].unregister(this$1); }\n    }\n    if (this.parent.computed[this.key] === this) { delete this.parent.computed[this.key]; }\n    Model.prototype.teardown.call(this);\n  };\n\n  Object.defineProperties( Computation__proto__, prototypeAccessors$2 );\n\n  return Computation;\n}(Model));\n\nvar prototype = Computation.prototype;\nvar child = ComputationChild.prototype;\nprototype.handleChange = child.handleChange;\nprototype.joinKey = child.joinKey;\n\nshared$1.Computation = Computation;\n\nvar ExpressionProxy = (function (Model) {\n  function ExpressionProxy(fragment, template) {\n    var this$1 = this;\n\n    Model.call(this, fragment.ractive.viewmodel, null);\n\n    this.fragment = fragment;\n    this.template = template;\n\n    this.isReadonly = true;\n    this.isComputed = true;\n    this.dirty = true;\n\n    this.fn =\n      fragment.ractive.allowExpressions === false\n        ? noop\n        : getFunction(template.s, template.r.length);\n\n    this.models = this.template.r.map(function (ref) {\n      return resolveReference(this$1.fragment, ref);\n    });\n    this.dependencies = [];\n\n    this.shuffle = undefined;\n\n    this.bubble();\n  }\n\n  if ( Model ) ExpressionProxy.__proto__ = Model;\n  var ExpressionProxy__proto__ = ExpressionProxy.prototype = Object.create( Model && Model.prototype );\n  ExpressionProxy__proto__.constructor = ExpressionProxy;\n\n  ExpressionProxy__proto__.bubble = function bubble (actuallyChanged) {\n    if ( actuallyChanged === void 0 ) actuallyChanged = true;\n\n    // refresh the keypath\n    this.keypath = undefined;\n\n    if (actuallyChanged) {\n      this.handleChange();\n    }\n  };\n\n  ExpressionProxy__proto__.getKeypath = function getKeypath () {\n    var this$1 = this;\n\n    if (!this.template) { return '@undefined'; }\n    if (!this.keypath) {\n      this.keypath =\n        '@' +\n        this.template.s.replace(/_(\\d+)/g, function (match, i) {\n          if (i >= this$1.models.length) { return match; }\n\n          var model = this$1.models[i];\n          return model ? model.getKeypath() : '@undefined';\n        });\n    }\n\n    return this.keypath;\n  };\n\n  ExpressionProxy__proto__.getValue = function getValue () {\n    var this$1 = this;\n\n    startCapturing();\n    var result;\n\n    try {\n      var params = this.models.map(function (m) { return (m ? m.get(true) : undefined); });\n      result = this.fn.apply(this.fragment.ractive, params);\n    } catch (err) {\n      warnIfDebug((\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)));\n    }\n\n    var dependencies = stopCapturing();\n    // remove missing deps\n    this.dependencies\n      .filter(function (d) { return !~dependencies.indexOf(d); })\n      .forEach(function (d) {\n        d.unregister(this$1);\n        removeFromArray(this$1.dependencies, d);\n      });\n    // register new deps\n    dependencies\n      .filter(function (d) { return !~this$1.dependencies.indexOf(d); })\n      .forEach(function (d) {\n        d.register(this$1);\n        this$1.dependencies.push(d);\n      });\n\n    return result;\n  };\n\n  ExpressionProxy__proto__.notifyUpstream = function notifyUpstream () {};\n\n  ExpressionProxy__proto__.rebind = function rebind (next, previous, safe) {\n    var idx = this.models.indexOf(previous);\n\n    if (~idx) {\n      next = rebindMatch(this.template.r[idx], next, previous);\n      if (next !== previous) {\n        previous.unregister(this);\n        this.models.splice(idx, 1, next);\n        if (next) { next.addShuffleRegister(this, 'mark'); }\n      }\n    }\n    this.bubble(!safe);\n  };\n\n  ExpressionProxy__proto__.rebound = function rebound (update) {\n    var this$1 = this;\n\n    this.models = this.template.r.map(function (ref) { return resolveReference(this$1.fragment, ref); });\n    if (update) { this.bubble(true); }\n  };\n\n  ExpressionProxy__proto__.retrieve = function retrieve () {\n    return this.get();\n  };\n\n  ExpressionProxy__proto__.teardown = function teardown () {\n    var this$1 = this;\n\n    this.fragment = undefined;\n    if (this.dependencies) { this.dependencies.forEach(function (d) { return d.unregister(this$1); }); }\n    Model.prototype.teardown.call(this);\n  };\n\n  ExpressionProxy__proto__.unreference = function unreference () {\n    Model.prototype.unreference.call(this);\n    collect(this);\n  };\n\n  ExpressionProxy__proto__.unregister = function unregister (dep) {\n    Model.prototype.unregister.call(this, dep);\n    collect(this);\n  };\n\n  ExpressionProxy__proto__.unregisterLink = function unregisterLink (link) {\n    Model.prototype.unregisterLink.call(this, link);\n    collect(this);\n  };\n\n  return ExpressionProxy;\n}(Model));\n\nvar prototype$1 = ExpressionProxy.prototype;\nvar computation = Computation.prototype;\nprototype$1.get = computation.get;\nprototype$1.handleChange = computation.handleChange;\nprototype$1.joinKey = computation.joinKey;\nprototype$1.mark = computation.mark;\nprototype$1.unbind = noop;\n\nfunction collect(model) {\n  if (!model.deps.length && !model.refs && !model.links.length) { model.teardown(); }\n}\n\nfunction setupArgsFn(item, template, fragment, opts) {\n  if ( opts === void 0 ) opts = {};\n\n  if (template && template.f && template.f.s) {\n    if (opts.register) {\n      item.model = new ExpressionProxy(fragment, template.f);\n      item.model.register(item);\n    } else {\n      item.fn = getFunction(template.f.s, template.f.r.length);\n    }\n  }\n}\n\nfunction resolveArgs(item, template, fragment, opts) {\n  if ( opts === void 0 ) opts = {};\n\n  return template.f.r.map(function (ref, i) {\n    var model;\n\n    if (opts.specialRef && (model = opts.specialRef(ref, i))) { return model; }\n\n    model = resolveReference(fragment, ref);\n\n    return model;\n  });\n}\n\nfunction teardownArgsFn(item) {\n  if (item.model) { item.model.unregister(item); }\n}\n\nvar missingDecorator = {\n  update: noop,\n  teardown: noop\n};\n\nvar Decorator = function Decorator(options) {\n  this.owner = options.owner || options.up.owner || findElement(options.up);\n  this.element = this.owner.attributeByName ? this.owner : findElement(options.up);\n  this.up = options.up || this.owner.up;\n  this.ractive = this.up.ractive || this.owner.ractive;\n  var template = (this.template = options.template);\n\n  this.name = template.n;\n\n  this.node = null;\n  this.handle = null;\n\n  this.element.decorators.push(this);\n};\nvar Decorator__proto__ = Decorator.prototype;\n\nDecorator__proto__.bind = function bind () {\n  // if the owner is the elment, make sure the context includes the element\n  var frag = this.element === this.owner ? new Fragment({ owner: this.owner }) : this.up;\n  setupArgsFn(this, this.template, frag, { register: true });\n};\n\nDecorator__proto__.bubble = function bubble () {\n  if (!this.dirty) {\n    this.dirty = true;\n    // decorators may be owned directly by an element or by a fragment if conditional\n    this.owner.bubble();\n    this.up.bubble();\n  }\n};\n\nDecorator__proto__.destroyed = function destroyed () {\n  if (this.handle) {\n    this.handle.teardown();\n    this.handle = null;\n  }\n  this.shouldDestroy = true;\n};\n\nDecorator__proto__.handleChange = function handleChange () {\n  this.bubble();\n};\n\nDecorator__proto__.rebound = function rebound (update) {\n  if (this.model) { this.model.rebound(update); }\n};\n\nDecorator__proto__.render = function render () {\n    var this$1 = this;\n\n  this.shouldDestroy = false;\n  if (this.handle) { this.unrender(); }\n  var ractive = this.ractive;\n  runloop.scheduleTask(function () {\n    // bail if the host element has managed to become unrendered\n    if (!this$1.element.rendered) { return; }\n\n    var fn = findInViewHierarchy('decorators', ractive, this$1.name);\n\n    if (!fn) {\n      warnOnce(missingPlugin(this$1.name, 'decorator'));\n      this$1.handle = missingDecorator;\n      return;\n    }\n\n    this$1.node = this$1.element.node;\n\n    var args = this$1.model ? this$1.model.get() : [];\n    localFragment.f = this$1.up;\n    this$1.handle = fn.apply(ractive, [this$1.node].concat(args));\n    localFragment.f = null;\n\n    if (!this$1.handle || !this$1.handle.teardown) {\n      throw new Error(\n        (\"The '\" + (this$1.name) + \"' decorator must return an object with a teardown method\")\n      );\n    }\n\n    // watch out for decorators that cause their host element to be unrendered\n    if (this$1.shouldDestroy) { this$1.destroyed(); }\n  }, true);\n};\n\nDecorator__proto__.shuffled = function shuffled () {\n  if (this.handle && this.handle.shuffled) { this.handle.shuffled(); }\n};\n\nDecorator__proto__.toString = function toString () {\n  return '';\n};\n\nDecorator__proto__.unbind = function unbind () {\n  teardownArgsFn(this, this.template);\n};\n\nDecorator__proto__.unrender = function unrender (shouldDestroy) {\n  if ((!shouldDestroy || this.element.rendered) && this.handle) {\n    this.handle.teardown();\n    this.handle = null;\n  }\n};\n\nDecorator__proto__.update = function update () {\n  var instance = this.handle;\n\n  if (!this.dirty) {\n    if (instance && instance.invalidate) {\n      runloop.scheduleTask(function () { return instance.invalidate(); }, true);\n    }\n    return;\n  }\n\n  this.dirty = false;\n\n  if (instance) {\n    if (!instance.update) {\n      this.unrender();\n      this.render();\n    } else {\n      var args = this.model ? this.model.get() : [];\n      instance.update.apply(this.ractive, args);\n    }\n  }\n};\n\nDecorator.prototype.firstNode = noop;\n\nvar Doctype = (function (Item) {\n  function Doctype () {\n    Item.apply(this, arguments);\n  }\n\n  if ( Item ) Doctype.__proto__ = Item;\n  var Doctype__proto__ = Doctype.prototype = Object.create( Item && Item.prototype );\n  Doctype__proto__.constructor = Doctype;\n\n  Doctype__proto__.toString = function toString () {\n    return '<!DOCTYPE' + this.template.a + '>';\n  };\n\n  return Doctype;\n}(Item));\n\nvar proto$2 = Doctype.prototype;\nproto$2.bind = proto$2.render = proto$2.teardown = proto$2.unbind = proto$2.unrender = proto$2.update = noop;\n\nvar Binding = function Binding(element, name) {\n  if ( name === void 0 ) name = 'value';\n\n  this.element = element;\n  this.ractive = element.ractive;\n  this.attribute = element.attributeByName[name];\n\n  var interpolator = this.attribute.interpolator;\n  interpolator.twowayBinding = this;\n\n  var model = interpolator.model;\n\n  if (model.isReadonly && !model.setRoot) {\n    var keypath = model.getKeypath().replace(/^@/, '');\n    warnOnceIfDebug(\n      (\"Cannot use two-way binding on <\" + (element.name) + \"> element: \" + keypath + \" is read-only. To suppress this warning use <\" + (element.name) + \" twoway='false'...>\"),\n      { ractive: this.ractive }\n    );\n    return false;\n  }\n\n  this.attribute.isTwoway = true;\n  this.model = model;\n\n  // initialise value, if it's undefined\n  var value = model.get();\n  this.wasUndefined = isUndefined(value);\n\n  if (isUndefined(value) && this.getInitialValue) {\n    value = this.getInitialValue();\n    model.set(value);\n  }\n  this.lastVal(true, value);\n\n  var parentForm = findElement(this.element, false, 'form');\n  if (parentForm) {\n    this.resetValue = value;\n    parentForm.formBindings.push(this);\n  }\n};\nvar Binding__proto__ = Binding.prototype;\n\nBinding__proto__.bind = function bind () {\n  this.model.registerTwowayBinding(this);\n};\n\nBinding__proto__.handleChange = function handleChange () {\n    var this$1 = this;\n\n  var value = this.getValue();\n  if (this.lastVal() === value) { return; }\n\n  runloop.start();\n  this.attribute.locked = true;\n  this.model.set(value);\n  this.lastVal(true, value);\n\n  // if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up\n  if (this.model.get() !== value) { this.attribute.locked = false; }\n  else { runloop.scheduleTask(function () { return (this$1.attribute.locked = false); }); }\n\n  runloop.end();\n};\n\nBinding__proto__.lastVal = function lastVal (setting, value) {\n  if (setting) { this.lastValue = value; }\n  else { return this.lastValue; }\n};\n\nBinding__proto__.rebind = function rebind (next, previous) {\n    var this$1 = this;\n\n  if (this.model && this.model === previous) { previous.unregisterTwowayBinding(this); }\n  if (next) {\n    this.model = next;\n    runloop.scheduleTask(function () { return next.registerTwowayBinding(this$1); });\n  }\n};\n\nBinding__proto__.rebound = function rebound () {\n  if (this.model) { this.model.unregisterTwowayBinding(this); }\n  this.model = this.attribute.interpolator.model;\n  this.model && this.model.registerTwowayBinding(this);\n};\n\nBinding__proto__.render = function render () {\n  this.node = this.element.node;\n  this.node._ractive.binding = this;\n  this.rendered = true; // TODO is this used anywhere?\n};\n\nBinding__proto__.setFromNode = function setFromNode (node) {\n  this.model.set(node.value);\n};\n\nBinding__proto__.unbind = function unbind () {\n  this.model && this.model.unregisterTwowayBinding(this);\n};\n\nBinding.prototype.unrender = noop;\n\n// This is the handler for DOM events that would lead to a change in the model\n// (i.e. change, sometimes, input, and occasionally click and keyup)\nfunction handleDomEvent() {\n  this._ractive.binding.handleChange();\n}\n\nvar CheckboxBinding = (function (Binding) {\n  function CheckboxBinding(element) {\n    Binding.call(this, element, 'checked');\n  }\n\n  if ( Binding ) CheckboxBinding.__proto__ = Binding;\n  var CheckboxBinding__proto__ = CheckboxBinding.prototype = Object.create( Binding && Binding.prototype );\n  CheckboxBinding__proto__.constructor = CheckboxBinding;\n\n  CheckboxBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    this.element.on('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  CheckboxBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.off('click', handleDomEvent);\n    }\n  };\n\n  CheckboxBinding__proto__.getInitialValue = function getInitialValue () {\n    return !!this.element.getAttribute('checked');\n  };\n\n  CheckboxBinding__proto__.getValue = function getValue () {\n    return this.node.checked;\n  };\n\n  CheckboxBinding__proto__.setFromNode = function setFromNode (node) {\n    this.model.set(node.checked);\n  };\n\n  return CheckboxBinding;\n}(Binding));\n\nfunction getBindingGroup(group, model, getValue) {\n  var hash = group + \"-bindingGroup\";\n  return model[hash] || (model[hash] = new BindingGroup(hash, model, getValue));\n}\n\nvar BindingGroup = function BindingGroup(hash, model, getValue) {\n  var this$1 = this;\n\n  this.model = model;\n  this.hash = hash;\n  this.getValue = function () {\n    this$1.value = getValue.call(this$1);\n    return this$1.value;\n  };\n\n  this.bindings = [];\n};\nvar BindingGroup__proto__ = BindingGroup.prototype;\n\nBindingGroup__proto__.add = function add (binding) {\n  this.bindings.push(binding);\n};\n\nBindingGroup__proto__.bind = function bind () {\n    var this$1 = this;\n\n  this.value = this.model.get();\n  this.bindings.forEach(function (b) { return b.lastVal(true, this$1.value); });\n  this.model.registerTwowayBinding(this);\n  this.bound = true;\n};\n\nBindingGroup__proto__.remove = function remove (binding) {\n  removeFromArray(this.bindings, binding);\n  if (!this.bindings.length) {\n    this.unbind();\n  }\n};\n\nBindingGroup__proto__.unbind = function unbind () {\n  this.model.unregisterTwowayBinding(this);\n  this.bound = false;\n  delete this.model[this.hash];\n};\n\nBindingGroup.prototype.rebind = Binding.prototype.rebind;\n\nvar push$1 = [].push;\n\nfunction getValue() {\n  var this$1 = this;\n\n  var all = this.bindings\n    .filter(function (b) { return b.node && b.node.checked; })\n    .map(function (b) { return b.element.getAttribute('value'); });\n  var res = [];\n  all.forEach(function (v) {\n    if (!this$1.bindings[0].arrayContains(res, v)) { res.push(v); }\n  });\n  return res;\n}\n\nvar CheckboxNameBinding = (function (Binding) {\n  function CheckboxNameBinding(element) {\n    Binding.call(this, element, 'name');\n\n    this.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n    // Each input has a reference to an array containing it and its\n    // group, as two-way binding depends on being able to ascertain\n    // the status of all inputs within the group\n    this.group = getBindingGroup('checkboxes', this.model, getValue);\n    this.group.add(this);\n\n    if (this.noInitialValue) {\n      this.group.noInitialValue = true;\n    }\n\n    // If no initial value was set, and this input is checked, we\n    // update the model\n    if (this.group.noInitialValue && this.element.getAttribute('checked')) {\n      var existingValue = this.model.get();\n      var bindingValue = this.element.getAttribute('value');\n\n      if (!this.arrayContains(existingValue, bindingValue)) {\n        push$1.call(existingValue, bindingValue); // to avoid triggering runloop with array adaptor\n      }\n    }\n  }\n\n  if ( Binding ) CheckboxNameBinding.__proto__ = Binding;\n  var CheckboxNameBinding__proto__ = CheckboxNameBinding.prototype = Object.create( Binding && Binding.prototype );\n  CheckboxNameBinding__proto__.constructor = CheckboxNameBinding;\n\n  CheckboxNameBinding__proto__.bind = function bind () {\n    if (!this.group.bound) {\n      this.group.bind();\n    }\n  };\n\n  CheckboxNameBinding__proto__.getInitialValue = function getInitialValue () {\n    // This only gets called once per group (of inputs that\n    // share a name), because it only gets called if there\n    // isn't an initial value. By the same token, we can make\n    // a note of that fact that there was no initial value,\n    // and populate it using any `checked` attributes that\n    // exist (which users should avoid, but which we should\n    // support anyway to avoid breaking expectations)\n    this.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?\n    return [];\n  };\n\n  CheckboxNameBinding__proto__.getValue = function getValue () {\n    return this.group.value;\n  };\n\n  CheckboxNameBinding__proto__.handleChange = function handleChange () {\n    this.isChecked = this.element.node.checked;\n    var mval = this.model.get();\n    this.group.value = mval === undefined ? [] : mval.slice();\n    var value = this.element.getAttribute('value');\n    if (this.isChecked && !this.arrayContains(this.group.value, value)) {\n      this.group.value.push(value);\n    } else if (!this.isChecked && this.arrayContains(this.group.value, value)) {\n      this.removeFromArray(this.group.value, value);\n    }\n    // make sure super knows there's a change\n    this.lastValue = null;\n    Binding.prototype.handleChange.call(this);\n  };\n\n  CheckboxNameBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    var node = this.node;\n\n    var existingValue = this.model.get();\n    var bindingValue = this.element.getAttribute('value');\n\n    if (isArray(existingValue)) {\n      this.isChecked = this.arrayContains(existingValue, bindingValue);\n    } else {\n      this.isChecked = this.element.compare(existingValue, bindingValue);\n    }\n    node.name = '{{' + this.model.getKeypath() + '}}';\n    node.checked = this.isChecked;\n\n    this.element.on('change', handleDomEvent);\n\n    // in case of IE emergency, bind to click event as well\n    if (this.node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  CheckboxNameBinding__proto__.setFromNode = function setFromNode (node) {\n    this.group.bindings.forEach(function (binding) { return (binding.wasUndefined = true); });\n\n    if (node.checked) {\n      var valueSoFar = this.group.getValue();\n      valueSoFar.push(this.element.getAttribute('value'));\n\n      this.group.model.set(valueSoFar);\n    }\n  };\n\n  CheckboxNameBinding__proto__.unbind = function unbind () {\n    this.group.remove(this);\n  };\n\n  CheckboxNameBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n\n    el.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      el.off('click', handleDomEvent);\n    }\n  };\n\n  CheckboxNameBinding__proto__.arrayContains = function arrayContains (selectValue, optionValue) {\n    var this$1 = this;\n\n    var i = selectValue.length;\n    while (i--) {\n      if (this$1.element.compare(optionValue, selectValue[i])) { return true; }\n    }\n    return false;\n  };\n\n  CheckboxNameBinding__proto__.removeFromArray = function removeFromArray (array, item) {\n    var this$1 = this;\n\n    if (!array) { return; }\n    var i = array.length;\n    while (i--) {\n      if (this$1.element.compare(item, array[i])) {\n        array.splice(i, 1);\n      }\n    }\n  };\n\n  return CheckboxNameBinding;\n}(Binding));\n\nvar ContentEditableBinding = (function (Binding) {\n  function ContentEditableBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) ContentEditableBinding.__proto__ = Binding;\n  var ContentEditableBinding__proto__ = ContentEditableBinding.prototype = Object.create( Binding && Binding.prototype );\n  ContentEditableBinding__proto__.constructor = ContentEditableBinding;\n\n  ContentEditableBinding__proto__.getInitialValue = function getInitialValue () {\n    return this.element.fragment ? this.element.fragment.toString() : '';\n  };\n\n  ContentEditableBinding__proto__.getValue = function getValue () {\n    return this.element.node.innerHTML;\n  };\n\n  ContentEditableBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    var el = this.element;\n\n    el.on('change', handleDomEvent);\n    el.on('blur', handleDomEvent);\n\n    if (!this.ractive.lazy) {\n      el.on('input', handleDomEvent);\n\n      if (this.node.attachEvent) {\n        el.on('keyup', handleDomEvent);\n      }\n    }\n  };\n\n  ContentEditableBinding__proto__.setFromNode = function setFromNode (node) {\n    this.model.set(node.innerHTML);\n  };\n\n  ContentEditableBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n\n    el.off('blur', handleDomEvent);\n    el.off('change', handleDomEvent);\n    el.off('input', handleDomEvent);\n    el.off('keyup', handleDomEvent);\n  };\n\n  return ContentEditableBinding;\n}(Binding));\n\nfunction handleBlur() {\n  handleDomEvent.call(this);\n\n  var value = this._ractive.binding.model.get();\n  this.value = value == undefined ? '' : value;\n}\n\nfunction handleDelay(delay) {\n  var timeout;\n\n  return function() {\n    var this$1 = this;\n\n    if (timeout) { clearTimeout(timeout); }\n\n    timeout = setTimeout(function () {\n      var binding = this$1._ractive.binding;\n      if (binding.rendered) { handleDomEvent.call(this$1); }\n      timeout = null;\n    }, delay);\n  };\n}\n\nvar GenericBinding = (function (Binding) {\n  function GenericBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) GenericBinding.__proto__ = Binding;\n  var GenericBinding__proto__ = GenericBinding.prototype = Object.create( Binding && Binding.prototype );\n  GenericBinding__proto__.constructor = GenericBinding;\n\n  GenericBinding__proto__.getInitialValue = function getInitialValue () {\n    return '';\n  };\n\n  GenericBinding__proto__.getValue = function getValue () {\n    return this.node.value;\n  };\n\n  GenericBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    // any lazy setting for this element overrides the root\n    // if the value is a number, it's a timeout\n    var lazy = this.ractive.lazy;\n    var timeout = false;\n    var el = this.element;\n\n    if ('lazy' in this.element) {\n      lazy = this.element.lazy;\n    }\n\n    if (isNumeric(lazy)) {\n      timeout = +lazy;\n      lazy = false;\n    }\n\n    this.handler = timeout ? handleDelay(timeout) : handleDomEvent;\n\n    var node = this.node;\n\n    el.on('change', handleDomEvent);\n\n    if (node.type !== 'file') {\n      if (!lazy) {\n        el.on('input', this.handler);\n\n        // IE is a special snowflake\n        if (node.attachEvent) {\n          el.on('keyup', this.handler);\n        }\n      }\n\n      el.on('blur', handleBlur);\n    }\n  };\n\n  GenericBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n    this.rendered = false;\n\n    el.off('change', handleDomEvent);\n    el.off('input', this.handler);\n    el.off('keyup', this.handler);\n    el.off('blur', handleBlur);\n  };\n\n  return GenericBinding;\n}(Binding));\n\nvar FileBinding = (function (GenericBinding) {\n  function FileBinding () {\n    GenericBinding.apply(this, arguments);\n  }\n\n  if ( GenericBinding ) FileBinding.__proto__ = GenericBinding;\n  var FileBinding__proto__ = FileBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n  FileBinding__proto__.constructor = FileBinding;\n\n  FileBinding__proto__.getInitialValue = function getInitialValue () {\n    /* istanbul ignore next */\n    return undefined;\n  };\n\n  FileBinding__proto__.getValue = function getValue () {\n    /* istanbul ignore next */\n    return this.node.files;\n  };\n\n  FileBinding__proto__.render = function render () {\n    /* istanbul ignore next */\n    this.element.lazy = false;\n    /* istanbul ignore next */\n    GenericBinding.prototype.render.call(this);\n  };\n\n  FileBinding__proto__.setFromNode = function setFromNode (node) {\n    /* istanbul ignore next */\n    this.model.set(node.files);\n  };\n\n  return FileBinding;\n}(GenericBinding));\n\nfunction getSelectedOptions(select) {\n  /* istanbul ignore next */\n  return select.selectedOptions\n    ? toArray(select.selectedOptions)\n    : select.options\n    ? toArray(select.options).filter(function (option) { return option.selected; })\n    : [];\n}\n\nvar MultipleSelectBinding = (function (Binding) {\n  function MultipleSelectBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) MultipleSelectBinding.__proto__ = Binding;\n  var MultipleSelectBinding__proto__ = MultipleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n  MultipleSelectBinding__proto__.constructor = MultipleSelectBinding;\n\n  MultipleSelectBinding__proto__.getInitialValue = function getInitialValue () {\n    return this.element.options\n      .filter(function (option) { return option.getAttribute('selected'); })\n      .map(function (option) { return option.getAttribute('value'); });\n  };\n\n  MultipleSelectBinding__proto__.getValue = function getValue () {\n    var options = this.element.node.options;\n    var len = options.length;\n\n    var selectedValues = [];\n\n    for (var i = 0; i < len; i += 1) {\n      var option = options[i];\n\n      if (option.selected) {\n        var optionValue = option._ractive ? option._ractive.value : option.value;\n        selectedValues.push(optionValue);\n      }\n    }\n\n    return selectedValues;\n  };\n\n  MultipleSelectBinding__proto__.handleChange = function handleChange () {\n    var attribute = this.attribute;\n    var previousValue = attribute.getValue();\n\n    var value = this.getValue();\n\n    if (isUndefined(previousValue) || !arrayContentsMatch(value, previousValue)) {\n      Binding.prototype.handleChange.call(this);\n    }\n\n    return this;\n  };\n\n  MultipleSelectBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    this.element.on('change', handleDomEvent);\n\n    if (isUndefined(this.model.get())) {\n      // get value from DOM, if possible\n      this.handleChange();\n    }\n  };\n\n  MultipleSelectBinding__proto__.setFromNode = function setFromNode (node) {\n    var selectedOptions = getSelectedOptions(node);\n    var i = selectedOptions.length;\n    var result = new Array(i);\n\n    while (i--) {\n      var option = selectedOptions[i];\n      result[i] = option._ractive ? option._ractive.value : option.value;\n    }\n\n    this.model.set(result);\n  };\n\n  MultipleSelectBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n  };\n\n  return MultipleSelectBinding;\n}(Binding));\n\nvar NumericBinding = (function (GenericBinding) {\n  function NumericBinding () {\n    GenericBinding.apply(this, arguments);\n  }\n\n  if ( GenericBinding ) NumericBinding.__proto__ = GenericBinding;\n  var NumericBinding__proto__ = NumericBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n  NumericBinding__proto__.constructor = NumericBinding;\n\n  NumericBinding__proto__.getInitialValue = function getInitialValue () {\n    return undefined;\n  };\n\n  NumericBinding__proto__.getValue = function getValue () {\n    var value = parseFloat(this.node.value);\n    return isNaN(value) ? undefined : value;\n  };\n\n  NumericBinding__proto__.setFromNode = function setFromNode (node) {\n    var value = parseFloat(node.value);\n    if (!isNaN(value)) { this.model.set(value); }\n  };\n\n  return NumericBinding;\n}(GenericBinding));\n\nvar siblings = {};\n\nfunction getSiblings(hash) {\n  return siblings[hash] || (siblings[hash] = []);\n}\n\nvar RadioBinding = (function (Binding) {\n  function RadioBinding(element) {\n    Binding.call(this, element, 'checked');\n\n    this.siblings = getSiblings(this.ractive._guid + this.element.getAttribute('name'));\n    this.siblings.push(this);\n  }\n\n  if ( Binding ) RadioBinding.__proto__ = Binding;\n  var RadioBinding__proto__ = RadioBinding.prototype = Object.create( Binding && Binding.prototype );\n  RadioBinding__proto__.constructor = RadioBinding;\n\n  RadioBinding__proto__.getValue = function getValue () {\n    return this.node.checked;\n  };\n\n  RadioBinding__proto__.handleChange = function handleChange () {\n    runloop.start();\n\n    this.siblings.forEach(function (binding) {\n      binding.model.set(binding.getValue());\n    });\n\n    runloop.end();\n  };\n\n  RadioBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    this.element.on('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  RadioBinding__proto__.setFromNode = function setFromNode (node) {\n    this.model.set(node.checked);\n  };\n\n  RadioBinding__proto__.unbind = function unbind () {\n    removeFromArray(this.siblings, this);\n  };\n\n  RadioBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.off('click', handleDomEvent);\n    }\n  };\n\n  return RadioBinding;\n}(Binding));\n\nfunction getValue$1() {\n  var checked = this.bindings.filter(function (b) { return b.node.checked; });\n  if (checked.length > 0) {\n    return checked[0].element.getAttribute('value');\n  }\n}\n\nvar RadioNameBinding = (function (Binding) {\n  function RadioNameBinding(element) {\n    var this$1 = this;\n\n    Binding.call(this, element, 'name');\n\n    this.group = getBindingGroup('radioname', this.model, getValue$1);\n    this.group.add(this);\n\n    if (element.checked) {\n      this.group.value = this.getValue();\n    }\n\n    this.attribute.interpolator.pathChanged = function () { return this$1.updateName(); };\n  }\n\n  if ( Binding ) RadioNameBinding.__proto__ = Binding;\n  var RadioNameBinding__proto__ = RadioNameBinding.prototype = Object.create( Binding && Binding.prototype );\n  RadioNameBinding__proto__.constructor = RadioNameBinding;\n\n  RadioNameBinding__proto__.bind = function bind () {\n    if (!this.group.bound) {\n      this.group.bind();\n    }\n  };\n\n  RadioNameBinding__proto__.getInitialValue = function getInitialValue () {\n    if (this.element.getAttribute('checked')) {\n      return this.element.getAttribute('value');\n    }\n  };\n\n  RadioNameBinding__proto__.getValue = function getValue () {\n    return this.element.getAttribute('value');\n  };\n\n  RadioNameBinding__proto__.handleChange = function handleChange () {\n    // If this <input> is the one that's checked, then the value of its\n    // `name` model gets set to its value\n    if (this.node.checked) {\n      this.group.value = this.getValue();\n      Binding.prototype.handleChange.call(this);\n    }\n\n    this.updateName();\n  };\n\n  RadioNameBinding__proto__.lastVal = function lastVal (setting, value) {\n    if (!this.group) { return; }\n    if (setting) { this.group.lastValue = value; }\n    else { return this.group.lastValue; }\n  };\n\n  RadioNameBinding__proto__.rebind = function rebind (next, previous) {\n    Binding.prototype.rebind.call(this, next, previous);\n    this.updateName();\n  };\n\n  RadioNameBinding__proto__.rebound = function rebound (update) {\n    Binding.prototype.rebound.call(this, update);\n    this.updateName();\n  };\n\n  RadioNameBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    var node = this.node;\n\n    this.updateName();\n    node.checked = this.element.compare(this.model.get(), this.element.getAttribute('value'));\n\n    this.element.on('change', handleDomEvent);\n\n    if (node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  RadioNameBinding__proto__.setFromNode = function setFromNode (node) {\n    if (node.checked) {\n      this.group.model.set(this.element.getAttribute('value'));\n    }\n  };\n\n  RadioNameBinding__proto__.unbind = function unbind () {\n    this.group.remove(this);\n  };\n\n  RadioNameBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n\n    el.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      el.off('click', handleDomEvent);\n    }\n  };\n\n  RadioNameBinding__proto__.updateName = function updateName () {\n    if (this.node) { this.node.name = \"{{\" + (this.model.getKeypath()) + \"}}\"; }\n  };\n\n  return RadioNameBinding;\n}(Binding));\n\nvar SingleSelectBinding = (function (Binding) {\n  function SingleSelectBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) SingleSelectBinding.__proto__ = Binding;\n  var SingleSelectBinding__proto__ = SingleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n  SingleSelectBinding__proto__.constructor = SingleSelectBinding;\n\n  SingleSelectBinding__proto__.forceUpdate = function forceUpdate () {\n    var this$1 = this;\n\n    var value = this.getValue();\n\n    if (value !== undefined) {\n      this.attribute.locked = true;\n      runloop.scheduleTask(function () { return (this$1.attribute.locked = false); });\n      this.model.set(value);\n    }\n  };\n\n  SingleSelectBinding__proto__.getInitialValue = function getInitialValue () {\n    if (this.element.getAttribute('value') !== undefined) {\n      return;\n    }\n\n    var options = this.element.options;\n    var len = options.length;\n\n    if (!len) { return; }\n\n    var value;\n    var optionWasSelected;\n    var i = len;\n\n    // take the final selected option...\n    while (i--) {\n      var option = options[i];\n\n      if (option.getAttribute('selected')) {\n        if (!option.getAttribute('disabled')) {\n          value = option.getAttribute('value');\n        }\n\n        optionWasSelected = true;\n        break;\n      }\n    }\n\n    // or the first non-disabled option, if none are selected\n    if (!optionWasSelected) {\n      while (++i < len) {\n        if (!options[i].getAttribute('disabled')) {\n          value = options[i].getAttribute('value');\n          break;\n        }\n      }\n    }\n\n    // This is an optimisation (aka hack) that allows us to forgo some\n    // other more expensive work\n    // TODO does it still work? seems at odds with new architecture\n    if (value !== undefined) {\n      this.element.attributeByName.value.value = value;\n    }\n\n    return value;\n  };\n\n  SingleSelectBinding__proto__.getValue = function getValue () {\n    var options = this.node.options;\n    var len = options.length;\n\n    var i;\n    for (i = 0; i < len; i += 1) {\n      var option = options[i];\n\n      if (options[i].selected && !options[i].disabled) {\n        return option._ractive ? option._ractive.value : option.value;\n      }\n    }\n  };\n\n  SingleSelectBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n    this.element.on('change', handleDomEvent);\n  };\n\n  SingleSelectBinding__proto__.setFromNode = function setFromNode (node) {\n    var option = getSelectedOptions(node)[0];\n    this.model.set(option._ractive ? option._ractive.value : option.value);\n  };\n\n  SingleSelectBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n  };\n\n  return SingleSelectBinding;\n}(Binding));\n\nfunction isBindable(attribute) {\n  // The fragment must be a single non-string fragment\n  if (\n    !attribute ||\n    !attribute.template.f ||\n    attribute.template.f.length !== 1 ||\n    attribute.template.f[0].s\n  )\n    { return false; }\n\n  // A binding is an interpolator `{{ }}`, yey.\n  if (attribute.template.f[0].t === INTERPOLATOR) { return true; }\n\n  // The above is probably the only true case. For the rest, show an appropriate\n  // warning before returning false.\n\n  // You can't bind a triple curly. HTML values on an attribute makes no sense.\n  if (attribute.template.f[0].t === TRIPLE)\n    { warnIfDebug('It is not possible create a binding using a triple mustache.'); }\n\n  return false;\n}\n\nfunction selectBinding(element) {\n  var name = element.name;\n  var attributes = element.attributeByName;\n  if (name !== 'input' && name !== 'textarea' && name !== 'select' && !attributes.contenteditable)\n    { return; }\n  var isBindableByValue = isBindable(attributes.value);\n  var isBindableByContentEditable = isBindable(attributes.contenteditable);\n  var isContentEditable = element.getAttribute('contenteditable');\n\n  // contenteditable\n  // Bind if the contenteditable is true or a binding that may become true.\n  if ((isContentEditable || isBindableByContentEditable) && isBindableByValue)\n    { return ContentEditableBinding; }\n\n  // <input>\n  if (name === 'input') {\n    var type = element.getAttribute('type');\n\n    if (type === 'radio') {\n      var isBindableByName = isBindable(attributes.name);\n      var isBindableByChecked = isBindable(attributes.checked);\n\n      // For radios we can either bind the name or checked, but not both.\n      // Name binding is handed instead.\n      if (isBindableByName && isBindableByChecked) {\n        warnIfDebug(\n          'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',\n          { ractive: element.root }\n        );\n        return RadioNameBinding;\n      }\n\n      if (isBindableByName) { return RadioNameBinding; }\n\n      if (isBindableByChecked) { return RadioBinding; }\n\n      // Dead end. Unknown binding on radio input.\n      return null;\n    }\n\n    if (type === 'checkbox') {\n      var isBindableByName$1 = isBindable(attributes.name);\n      var isBindableByChecked$1 = isBindable(attributes.checked);\n\n      // A checkbox with bindings for both name and checked. Checked treated as\n      // the checkbox value, name is treated as a regular binding.\n      //\n      // See https://github.com/ractivejs/ractive/issues/1749\n      if (isBindableByName$1 && isBindableByChecked$1) { return CheckboxBinding; }\n\n      if (isBindableByName$1) { return CheckboxNameBinding; }\n\n      if (isBindableByChecked$1) { return CheckboxBinding; }\n\n      // Dead end. Unknown binding on checkbox input.\n      return null;\n    }\n\n    if (type === 'file' && isBindableByValue) { return FileBinding; }\n\n    if (type === 'number' && isBindableByValue) { return NumericBinding; }\n\n    if (type === 'range' && isBindableByValue) { return NumericBinding; }\n\n    // Some input of unknown type (browser usually falls back to text).\n    if (isBindableByValue) { return GenericBinding; }\n\n    // Dead end. Some unknown input and an unbindable.\n    return null;\n  }\n\n  // <select>\n  if (name === 'select' && isBindableByValue) {\n    return element.getAttribute('multiple') ? MultipleSelectBinding : SingleSelectBinding;\n  }\n\n  // <textarea>\n  if (name === 'textarea' && isBindableByValue) { return GenericBinding; }\n\n  // Dead end. Some unbindable element.\n  return null;\n}\n\nvar endsWithSemi = /;\\s*$/;\n\nvar Element = (function (ContainerItem) {\n  function Element(options) {\n    var this$1 = this;\n\n    ContainerItem.call(this, options);\n\n    this.name = options.template.e.toLowerCase();\n\n    // find parent element\n    this.parent = findElement(this.up, false);\n\n    if (this.parent && this.parent.name === 'option') {\n      throw new Error(\n        (\"An <option> element cannot contain other elements (encountered <\" + (this.name) + \">)\")\n      );\n    }\n\n    this.decorators = [];\n\n    // create attributes\n    this.attributeByName = {};\n\n    var attrs;\n    var n, attr, val, cls, name, template, leftovers;\n\n    var m = this.template.m;\n    var len = (m && m.length) || 0;\n\n    for (var i = 0; i < len; i++) {\n      template = m[i];\n      if (template.g) {\n        (this$1.statics || (this$1.statics = {}))[template.n] = isString(template.f)\n          ? template.f\n          : template.n;\n      } else {\n        switch (template.t) {\n          case ATTRIBUTE:\n          case BINDING_FLAG:\n          case DECORATOR:\n          case EVENT:\n          case TRANSITION:\n            attr = createItem({\n              owner: this$1,\n              up: this$1.up,\n              template: template\n            });\n\n            n = template.n;\n\n            attrs = attrs || (attrs = this$1.attributes = []);\n\n            if (n === 'value') { val = attr; }\n            else if (n === 'name') { name = attr; }\n            else if (n === 'class') { cls = attr; }\n            else { attrs.push(attr); }\n\n            break;\n\n          case DELEGATE_FLAG:\n            this$1.delegate = false;\n            break;\n\n          default:\n            (leftovers || (leftovers = [])).push(template);\n            break;\n        }\n      }\n    }\n\n    if (val) { attrs.push(val); }\n    if (name) { attrs.push(name); }\n    if (cls) { attrs.unshift(cls); }\n\n    if (leftovers) {\n      (attrs || (this.attributes = [])).push(\n        new ConditionalAttribute({\n          owner: this,\n          up: this.up,\n          template: leftovers\n        })\n      );\n\n      // empty leftovers array\n      leftovers = [];\n    }\n\n    // create children\n    if (options.template.f && !options.deferContent) {\n      this.fragment = new Fragment({\n        template: options.template.f,\n        owner: this,\n        cssIds: null\n      });\n    }\n\n    this.binding = null; // filled in later\n  }\n\n  if ( ContainerItem ) Element.__proto__ = ContainerItem;\n  var Element__proto__ = Element.prototype = Object.create( ContainerItem && ContainerItem.prototype );\n  Element__proto__.constructor = Element;\n\n  Element__proto__.bind = function bind () {\n    var attrs = this.attributes;\n    if (attrs) {\n      attrs.binding = true;\n      var len = attrs.length;\n      for (var i = 0; i < len; i++) { attrs[i].bind(); }\n      attrs.binding = false;\n    }\n\n    if (this.fragment) { this.fragment.bind(); }\n\n    // create two-way binding if necessary\n    if (!this.binding) { this.recreateTwowayBinding(); }\n    else { this.binding.bind(); }\n  };\n\n  Element__proto__.createTwowayBinding = function createTwowayBinding () {\n    if ('twoway' in this ? this.twoway : this.ractive.twoway) {\n      var Binding = selectBinding(this);\n      if (Binding) {\n        var binding = new Binding(this);\n        if (binding && binding.model) { return binding; }\n      }\n    }\n  };\n\n  Element__proto__.destroyed = function destroyed$1 () {\n    if (this.attributes) { this.attributes.forEach(destroyed); }\n    if (this.fragment) { this.fragment.destroyed(); }\n  };\n\n  Element__proto__.detach = function detach () {\n    // if this element is no longer rendered, the transitions are complete and the attributes can be torn down\n    if (!this.rendered) { this.destroyed(); }\n\n    return detachNode(this.node);\n  };\n\n  Element__proto__.find = function find (selector, options) {\n    if (this.node && matches(this.node, selector)) { return this.node; }\n    if (this.fragment) {\n      return this.fragment.find(selector, options);\n    }\n  };\n\n  Element__proto__.findAll = function findAll (selector, options) {\n    var result = options.result;\n\n    if (matches(this.node, selector)) {\n      result.push(this.node);\n    }\n\n    if (this.fragment) {\n      this.fragment.findAll(selector, options);\n    }\n  };\n\n  Element__proto__.findNextNode = function findNextNode () {\n    return null;\n  };\n\n  Element__proto__.firstNode = function firstNode () {\n    return this.node;\n  };\n\n  Element__proto__.getAttribute = function getAttribute (name) {\n    if (this.statics && name in this.statics) { return this.statics[name]; }\n    var attribute = this.attributeByName[name];\n    return attribute ? attribute.getValue() : undefined;\n  };\n\n  Element__proto__.getContext = function getContext () {\n    var assigns = [], len = arguments.length;\n    while ( len-- ) assigns[ len ] = arguments[ len ];\n\n    if (this.fragment) { return (ref = this.fragment).getContext.apply(ref, assigns); }\n\n    if (!this.ctx) { this.ctx = new Context(this.up, this); }\n    assigns.unshift(create(this.ctx));\n    return assign.apply(null, assigns);\n    // removed by dead control flow\n{ var ref; }\n  };\n\n  Element__proto__.off = function off (event, callback, capture) {\n    if ( capture === void 0 ) capture = false;\n\n    var delegate = this.up.delegate;\n    var ref = this.listeners && this.listeners[event];\n\n    if (!ref) { return; }\n    removeFromArray(ref, callback);\n\n    if (delegate) {\n      var listeners =\n        (delegate.listeners || (delegate.listeners = [])) &&\n        (delegate.listeners[event] || (delegate.listeners[event] = []));\n      if (listeners.refs && !--listeners.refs) { delegate.off(event, delegateHandler, true); }\n    } else if (this.rendered) {\n      var n = this.node;\n      var add = n.addEventListener;\n      var rem = n.removeEventListener;\n\n      if (!ref.length) {\n        rem.call(n, event, handler, capture);\n      } else if (ref.length && !ref.refs && capture) {\n        rem.call(n, event, handler, true);\n        add.call(n, event, handler, false);\n      }\n    }\n  };\n\n  Element__proto__.on = function on (event, callback, capture) {\n    if ( capture === void 0 ) capture = false;\n\n    var delegate = this.up.delegate;\n    var ref = (this.listeners || (this.listeners = {}))[event] || (this.listeners[event] = []);\n\n    if (delegate) {\n      var listeners =\n        ((delegate.listeners || (delegate.listeners = [])) && delegate.listeners[event]) ||\n        (delegate.listeners[event] = []);\n      if (!listeners.refs) {\n        listeners.refs = 0;\n        delegate.on(event, delegateHandler, true);\n        listeners.refs++;\n      } else {\n        listeners.refs++;\n      }\n    } else if (this.rendered) {\n      var n = this.node;\n      var add = n.addEventListener;\n      var rem = n.removeEventListener;\n\n      if (!ref.length) {\n        add.call(n, event, handler, capture);\n      } else if (ref.length && !ref.refs && capture) {\n        rem.call(n, event, handler, false);\n        add.call(n, event, handler, true);\n      }\n    }\n\n    addToArray(this.listeners[event], callback);\n  };\n\n  Element__proto__.recreateTwowayBinding = function recreateTwowayBinding () {\n    if (this.binding) {\n      this.binding.unbind();\n      this.binding.unrender();\n    }\n\n    if ((this.binding = this.createTwowayBinding())) {\n      this.binding.bind();\n      if (this.rendered) { this.binding.render(); }\n    }\n  };\n\n  Element__proto__.rebound = function rebound (update$$1) {\n    ContainerItem.prototype.rebound.call(this, update$$1);\n    if (this.attributes) { this.attributes.forEach(function (x) { return x.rebound(update$$1); }); }\n    if (this.binding) { this.binding.rebound(update$$1); }\n  };\n\n  Element__proto__.render = function render (target, occupants) {\n    var this$1 = this;\n\n    // TODO determine correct namespace\n    this.namespace = getNamespace(this);\n\n    var node;\n    var existing = false;\n\n    if (occupants) {\n      var n;\n      while ((n = occupants.shift())) {\n        if (\n          n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() &&\n          n.namespaceURI === this$1.namespace\n        ) {\n          this$1.node = node = n;\n          existing = true;\n          break;\n        } else {\n          detachNode(n);\n        }\n      }\n    }\n\n    if (!existing && this.node) {\n      node = this.node;\n      target.appendChild(node);\n      existing = true;\n    }\n\n    if (!node) {\n      var name = this.template.e;\n      node = createElement(\n        this.namespace === html ? name.toLowerCase() : name,\n        this.namespace,\n        this.getAttribute('is')\n      );\n      this.node = node;\n    }\n\n    // tie the node to this vdom element\n    defineProperty(node, '_ractive', {\n      value: {\n        proxy: this\n      },\n      configurable: true\n    });\n\n    if (this.statics) {\n      keys(this.statics).forEach(function (k) {\n        node.setAttribute(k, this$1.statics[k]);\n      });\n    }\n\n    if (existing && this.foundNode) { this.foundNode(node); }\n\n    // register intro before rendering content so children can find the intro\n    var intro = this.intro;\n    if (intro && intro.shouldFire('intro')) {\n      intro.isIntro = true;\n      intro.isOutro = false;\n      runloop.registerTransition(intro);\n    }\n\n    if (this.fragment) {\n      var children = existing ? toArray(node.childNodes) : undefined;\n\n      this.fragment.render(node, children);\n\n      // clean up leftover children\n      if (children) {\n        children.forEach(detachNode);\n      }\n    }\n\n    if (existing) {\n      // store initial values for two-way binding\n      if (this.binding && this.binding.wasUndefined) { this.binding.setFromNode(node); }\n      // remove unused attributes\n      var i = node.attributes.length;\n      while (i--) {\n        var name$1 = node.attributes[i].name;\n        if (!(name$1 in this$1.attributeByName) && (!this$1.statics || !(name$1 in this$1.statics)))\n          { node.removeAttribute(name$1); }\n      }\n    }\n\n    // Is this a top-level node of a component? If so, we may need to add\n    // a data-ractive-css attribute, for CSS encapsulation\n    if (this.up.cssIds) {\n      node.setAttribute('data-ractive-css', this.up.cssIds.map(function (x) { return (\"{\" + x + \"}\"); }).join(' '));\n    }\n\n    if (this.attributes) {\n      var len = this.attributes.length;\n      for (var i$1 = 0; i$1 < len; i$1++) { this$1.attributes[i$1].render(); }\n    }\n    if (this.binding) { this.binding.render(); }\n\n    if (!this.up.delegate && this.listeners) {\n      var ls = this.listeners;\n      for (var k in ls) {\n        if (ls[k] && ls[k].length) { this$1.node.addEventListener(k, handler, !!ls[k].refs); }\n      }\n    }\n\n    if (!existing) {\n      target.appendChild(node);\n    }\n\n    this.rendered = true;\n  };\n\n  Element__proto__.shuffled = function shuffled$1 () {\n    ContainerItem.prototype.shuffled.call(this);\n    this.decorators.forEach(shuffled);\n  };\n\n  Element__proto__.toString = function toString () {\n    var this$1 = this;\n\n    var tagName = this.template.e;\n\n    var attrs = (this.attributes && this.attributes.map(stringifyAttribute).join('')) || '';\n\n    if (this.statics)\n      { keys(this.statics).forEach(\n        function (k) { return k !== 'class' &&\n          k !== 'style' &&\n          (attrs = \" \" + k + \"=\\\"\" + (safeAttributeString(this$1.statics[k])) + \"\\\"\" + attrs); }\n      ); }\n\n    // Special case - selected options\n    if (this.name === 'option' && this.isSelected()) {\n      attrs += ' selected';\n    }\n\n    // Special case - two-way radio name bindings\n    if (this.name === 'input' && inputIsCheckedRadio(this)) {\n      attrs += ' checked';\n    }\n\n    // Special case style and class attributes and directives\n    var style = this.statics ? this.statics.style : undefined;\n    var cls = this.statics ? this.statics.class : undefined;\n    this.attributes &&\n      this.attributes.forEach(function (attr) {\n        if (attr.name === 'class') {\n          cls = (cls || '') + (cls ? ' ' : '') + safeAttributeString(attr.getString());\n        } else if (attr.name === 'style') {\n          style = (style || '') + (style ? ' ' : '') + safeAttributeString(attr.getString());\n          if (style && !endsWithSemi.test(style)) { style += ';'; }\n        } else if (attr.style) {\n          style =\n            (style || '') +\n            (style ? ' ' : '') +\n            (attr.style) + \": \" + (safeAttributeString(attr.getString())) + \";\";\n        } else if (attr.inlineClass && attr.getValue()) {\n          cls = (cls || '') + (cls ? ' ' : '') + attr.inlineClass;\n        }\n      });\n    // put classes first, then inline style\n    if (style !== undefined) { attrs = ' style' + (style ? (\"=\\\"\" + style + \"\\\"\") : '') + attrs; }\n    if (cls !== undefined) { attrs = ' class' + (cls ? (\"=\\\"\" + cls + \"\\\"\") : '') + attrs; }\n\n    if (this.up.cssIds) {\n      attrs += \" data-ractive-css=\\\"\" + (this.up.cssIds.map(function (x) { return (\"{\" + x + \"}\"); }).join(' ')) + \"\\\"\";\n    }\n\n    var str = \"<\" + tagName + attrs + \">\";\n\n    if (voidElements[this.name.toLowerCase()]) { return str; }\n\n    // Special case - textarea\n    if (this.name === 'textarea' && this.getAttribute('value') !== undefined) {\n      str += escapeHtml(this.getAttribute('value'));\n    } else if (this.getAttribute('contenteditable') !== undefined) {\n      // Special case - contenteditable\n      str += this.getAttribute('value') || '';\n    }\n\n    if (this.fragment) {\n      str += this.fragment.toString(!/^(?:script|style)$/i.test(this.template.e)); // escape text unless script/style\n    }\n\n    str += \"</\" + tagName + \">\";\n    return str;\n  };\n\n  Element__proto__.unbind = function unbind (view) {\n    var attrs = this.attributes;\n    if (attrs) {\n      attrs.unbinding = true;\n      var len = attrs.length;\n      for (var i = 0; i < len; i++) { attrs[i].unbind(view); }\n      attrs.unbinding = false;\n    }\n\n    if (this.binding) { this.binding.unbind(view); }\n    if (this.fragment) { this.fragment.unbind(view); }\n  };\n\n  Element__proto__.unrender = function unrender (shouldDestroy) {\n    if (!this.rendered) { return; }\n    this.rendered = false;\n\n    // unrendering before intro completed? complete it now\n    // TODO should be an API for aborting transitions\n    var transition = this.intro;\n    if (transition && transition.complete) { transition.complete(); }\n\n    // Detach as soon as we can\n    if (this.name === 'option') {\n      // <option> elements detach immediately, so that\n      // their parent <select> element syncs correctly, and\n      // since option elements can't have transitions anyway\n      this.detach();\n    } else if (shouldDestroy) {\n      runloop.detachWhenReady(this);\n    }\n\n    // outro transition\n    var outro = this.outro;\n    if (outro && outro.shouldFire('outro')) {\n      outro.isIntro = false;\n      outro.isOutro = true;\n      runloop.registerTransition(outro);\n    }\n\n    if (this.fragment) { this.fragment.unrender(); }\n\n    if (this.binding) { this.binding.unrender(); }\n  };\n\n  Element__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n\n      var attrs = this.attributes;\n      if (attrs) {\n        var len = attrs.length;\n        for (var i = 0; i < len; i++) { attrs[i].update(); }\n      }\n\n      if (this.fragment) { this.fragment.update(); }\n    }\n  };\n\n  return Element;\n}(ContainerItem));\n\nfunction inputIsCheckedRadio(element) {\n  var nameAttr = element.attributeByName.name;\n  return (\n    element.getAttribute('type') === 'radio' &&\n    (nameAttr || {}).interpolator &&\n    element.getAttribute('value') === nameAttr.interpolator.model.get()\n  );\n}\n\nfunction stringifyAttribute(attribute) {\n  var str = attribute.toString();\n  return str ? ' ' + str : '';\n}\n\nfunction getNamespace(element) {\n  // Use specified namespace...\n  var xmlns$$1 = element.getAttribute('xmlns');\n  if (xmlns$$1) { return xmlns$$1; }\n\n  // ...or SVG namespace, if this is an <svg> element\n  if (element.name === 'svg') { return svg$1; }\n\n  var parent = element.parent;\n\n  if (parent) {\n    // ...or HTML, if the parent is a <foreignObject>\n    if (parent.name === 'foreignobject') { return html; }\n\n    // ...or inherit from the parent node\n    return parent.node.namespaceURI;\n  }\n\n  return element.ractive.el.namespaceURI;\n}\n\nvar stop = false;\nfunction stopPropagation() {\n  stop = true;\n}\nvar immediate$1 = false;\nfunction stopImmediatePropagation() {\n  immediate$1 = true;\n}\nvar prevent = false;\nfunction preventDefault() {\n  prevent = true;\n}\n\nfunction delegateHandler(ev) {\n  var name = ev.type;\n  var end = ev.currentTarget;\n  var endEl = end._ractive && end._ractive.proxy;\n  var node = ev.target;\n  var bubble = true;\n  var listeners;\n  var prevented = false;\n\n  stop = immediate$1 = prevent = false;\n  var oldStop = ev.stopPropagation;\n  var oldImmediate = ev.stopImmediatePropagation;\n  var oldPrevent = ev.preventDefault;\n  ev.stopPropagation = stopPropagation;\n  ev.stopImmediatePropagation = stopImmediatePropagation;\n  ev.preventDefault = preventDefault;\n\n  // starting with the origin node, walk up the DOM looking for ractive nodes with a matching event listener\n  while (bubble && node && node !== end) {\n    var proxy = node._ractive && node._ractive.proxy;\n    if (proxy && proxy.up.delegate === endEl && shouldFire(ev, node, end)) {\n      listeners = proxy.listeners && proxy.listeners[name];\n\n      if (listeners) {\n        var len = listeners.length;\n        for (var i = 0; i < len; i++) {\n          bubble = listeners[i].call(node, ev) !== false && bubble;\n          if (immediate$1) {\n            bubble = false;\n            break;\n          }\n          if (stop) { bubble = false; }\n          if (prevent && !prevented) {\n            prevented = true;\n            oldPrevent.call(ev);\n          }\n        }\n      }\n    }\n\n    node = node.parentNode || node.correspondingUseElement; // SVG with a <use> element in certain environments\n  }\n\n  if (bubble) { bubble = !stop && !immediate$1; }\n\n  if (stop) { oldStop.call(ev); }\n  if (immediate$1) { oldImmediate.call(ev); }\n\n  ev.stopPropagation = oldStop;\n  ev.stopImmediaitePropagation = oldImmediate;\n  ev.preventDefault = oldPrevent;\n\n  return bubble;\n}\n\nvar UIEvent = win !== null ? win.UIEvent : null;\nfunction shouldFire(event, start, end) {\n  if (UIEvent && event instanceof UIEvent) {\n    var node = start;\n    while (node && node !== end) {\n      if (node.disabled) { return false; }\n      node = node.parentNode || node.correspondingUseElement;\n    }\n  }\n\n  return true;\n}\n\nfunction handler(ev) {\n  var this$1 = this;\n\n  var el = this._ractive.proxy;\n  var listeners;\n  if (el.listeners && (listeners = el.listeners[ev.type])) {\n    var len = listeners.length;\n    for (var i = 0; i < len; i++) { listeners[i] && listeners[i].call(this$1, ev); }\n  }\n}\n\nvar Form = (function (Element) {\n  function Form(options) {\n    Element.call(this, options);\n    this.formBindings = [];\n  }\n\n  if ( Element ) Form.__proto__ = Element;\n  var Form__proto__ = Form.prototype = Object.create( Element && Element.prototype );\n  Form__proto__.constructor = Form;\n\n  Form__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n    this.on('reset', handleReset);\n  };\n\n  Form__proto__.unrender = function unrender (shouldDestroy) {\n    this.off('reset', handleReset);\n    Element.prototype.unrender.call(this, shouldDestroy);\n  };\n\n  return Form;\n}(Element));\n\nfunction handleReset() {\n  var element = this._ractive.proxy;\n\n  runloop.start();\n  element.formBindings.forEach(updateModel);\n  runloop.end();\n}\n\nfunction updateModel(binding) {\n  binding.model.set(binding.resetValue);\n}\n\nvar DOMEvent = function DOMEvent(name, owner) {\n  if (name.indexOf('*') !== -1) {\n    fatal(\n      (\"Only component proxy-events may contain \\\"*\\\" wildcards, <\" + (owner.name) + \" on-\" + name + \"=\\\"...\\\"/> is not valid\")\n    );\n  }\n\n  this.name = name;\n  this.owner = owner;\n  this.handler = null;\n};\nvar DOMEvent__proto__ = DOMEvent.prototype;\n\nDOMEvent__proto__.bind = function bind () {};\n\nDOMEvent__proto__.render = function render (directive) {\n    var this$1 = this;\n\n  var name = this.name;\n\n  var register = function () {\n    var node = this$1.owner.node;\n\n    this$1.owner.on(\n      name,\n      (this$1.handler = function (event) {\n        return directive.fire({\n          node: node,\n          original: event,\n          event: event,\n          name: name\n        });\n      })\n    );\n  };\n\n  if (name !== 'load') {\n    // schedule events so that they take place after twoway binding\n    runloop.scheduleTask(register, true);\n  } else {\n    // unless its a load event\n    register();\n  }\n};\n\nDOMEvent__proto__.unbind = function unbind () {};\n\nDOMEvent__proto__.unrender = function unrender () {\n  if (this.handler) { this.owner.off(this.name, this.handler); }\n};\n\nvar CustomEvent = function CustomEvent(eventPlugin, owner, name, args) {\n  this.eventPlugin = eventPlugin;\n  this.owner = owner;\n  this.name = name;\n  this.handler = null;\n  this.args = args;\n};\nvar CustomEvent__proto__ = CustomEvent.prototype;\n\nCustomEvent__proto__.bind = function bind () {};\n\nCustomEvent__proto__.render = function render (directive) {\n    var this$1 = this;\n\n  runloop.scheduleTask(function () {\n    var node = this$1.owner.node;\n\n    localFragment.f = directive.up;\n    this$1.handler = this$1.eventPlugin.apply(\n      this$1.owner.ractive,\n      [\n        node,\n        function (event) {\n            if ( event === void 0 ) event = {};\n\n          if (event.original) { event.event = event.original; }\n          else { event.original = event.event; }\n\n          event.name = this$1.name;\n          event.node = event.node || node;\n          return directive.fire(event);\n        }\n      ].concat(this$1.args || [])\n    );\n    localFragment.f = null;\n  });\n};\n\nCustomEvent__proto__.unbind = function unbind () {};\n\nCustomEvent__proto__.unrender = function unrender () {\n    var this$1 = this;\n\n  if (this.handler) { this.handler.teardown(); }\n  else { runloop.scheduleTask(function () { return this$1.handler && this$1.handler.teardown(); }); }\n};\n\nvar RactiveEvent = function RactiveEvent(component, name) {\n  this.component = component;\n  this.name = name;\n  this.handler = null;\n};\nvar RactiveEvent__proto__ = RactiveEvent.prototype;\n\nRactiveEvent__proto__.bind = function bind (directive) {\n  var ractive = this.component.instance;\n\n  this.handler = ractive.on(this.name, function () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n    // watch for reproxy\n    if (args[0] instanceof Context) {\n      var ctx = args.shift();\n      ctx.component = ractive;\n      directive.fire(ctx, args);\n    } else {\n      directive.fire({}, args);\n    }\n\n    // cancel bubbling\n    return false;\n  });\n};\n\nRactiveEvent__proto__.render = function render () {};\n\nRactiveEvent__proto__.unbind = function unbind () {\n  this.handler.cancel();\n};\n\nRactiveEvent__proto__.unrender = function unrender () {};\n\nvar specialPattern = /^(event|arguments|@node|@event|@context)(\\..+)?$/;\nvar dollarArgsPattern = /^\\$(\\d+)(\\..+)?$/;\n\nvar EventDirective = function EventDirective(options) {\n  this.owner = options.owner || options.up.owner || findElement(options.up);\n  this.element = this.owner.attributeByName ? this.owner : findElement(options.up, true);\n  this.template = options.template;\n  this.up = options.up;\n  this.ractive = options.up.ractive;\n  this.events = [];\n};\nvar EventDirective__proto__ = EventDirective.prototype;\n\nEventDirective__proto__.bind = function bind () {\n    var this$1 = this;\n\n  // sometimes anchors will cause an unbind without unrender\n  if (this.events.length) {\n    this.events.forEach(function (e) { return e.unrender(); });\n    this.events = [];\n  }\n\n  if (this.element.type === COMPONENT || this.element.type === ANCHOR) {\n    this.template.n.forEach(function (n) {\n      this$1.events.push(new RactiveEvent(this$1.element, n));\n    });\n  } else {\n    var args;\n    if ((args = this.template.a)) {\n      var rs = args.r.map(function (r) {\n        var model = resolveReference(this$1.up, r);\n        return model ? model.get() : undefined;\n      });\n      try {\n        args = getFunction(args.s, rs.length).apply(null, rs);\n      } catch (err) {\n        args = null;\n        warnIfDebug(\n          (\"Failed to compute args for event on-\" + (this.template.n.join('- ')) + \": \" + (err.message ||\n            err))\n        );\n      }\n    }\n\n    this.template.n.forEach(function (n) {\n      var fn = findInViewHierarchy('events', this$1.ractive, n);\n      if (fn) {\n        this$1.events.push(new CustomEvent(fn, this$1.element, n, args));\n      } else {\n        this$1.events.push(new DOMEvent(n, this$1.element));\n      }\n    });\n  }\n\n  // method calls\n  this.models = null;\n\n  addToArray(this.element.events || (this.element.events = []), this);\n\n  setupArgsFn(this, this.template);\n  if (!this.fn) { this.action = this.template.f; }\n\n  this.events.forEach(function (e) { return e.bind(this$1); });\n};\n\nEventDirective__proto__.destroyed = function destroyed () {\n  this.events.forEach(function (e) { return e.unrender(); });\n};\n\nEventDirective__proto__.fire = function fire (event, args) {\n    var this$1 = this;\n    if ( args === void 0 ) args = [];\n\n  var context =\n    event instanceof Context && event.refire ? event : this.element.getContext(event);\n\n  if (this.fn) {\n    var values = [];\n\n    var models = resolveArgs(this, this.template, this.up, {\n      specialRef: function specialRef(ref) {\n        var specialMatch = specialPattern.exec(ref);\n        if (specialMatch) {\n          // on-click=\"foo(event.node)\"\n          return {\n            special: specialMatch[1],\n            keys: specialMatch[2] ? splitKeypath(specialMatch[2].substr(1)) : []\n          };\n        }\n\n        var dollarMatch = dollarArgsPattern.exec(ref);\n        if (dollarMatch) {\n          // on-click=\"foo($1)\"\n          return {\n            special: 'arguments',\n            keys: [dollarMatch[1] - 1].concat(\n              dollarMatch[2] ? splitKeypath(dollarMatch[2].substr(1)) : []\n            )\n          };\n        }\n      }\n    });\n\n    if (models) {\n      models.forEach(function (model) {\n        if (!model) { return values.push(undefined); }\n\n        if (model.special) {\n          var which = model.special;\n          var obj;\n\n          if (which === '@node') {\n            obj = this$1.element.node;\n          } else if (which === '@event') {\n            obj = event && event.event;\n          } else if (which === 'event') {\n            warnOnceIfDebug(\n              \"The event reference available to event directives is deprecated and should be replaced with @context and @event\"\n            );\n            obj = context;\n          } else if (which === '@context') {\n            obj = context;\n          } else {\n            obj = args;\n          }\n\n          var keys = model.keys.slice();\n\n          while (obj && keys.length) { obj = obj[keys.shift()]; }\n          return values.push(obj);\n        }\n\n        if (model.wrapper) {\n          return values.push(model.wrapperValue);\n        }\n\n        values.push(model.get());\n      });\n    }\n\n    // make event available as `this.event`\n    var ractive = this.ractive;\n    var oldEvent = ractive.event;\n\n    ractive.event = context;\n    var returned = this.fn.apply(ractive, values);\n    var result = returned.pop();\n\n    // Auto prevent and stop if return is explicitly false\n    if (result === false) {\n      var original = event ? event.original : undefined;\n      if (original) {\n        original.preventDefault && original.preventDefault();\n        original.stopPropagation && original.stopPropagation();\n      } else {\n        warnOnceIfDebug(\n          (\"handler '\" + (this.template.n.join(\n            ' '\n          )) + \"' returned false, but there is no event available to cancel\")\n        );\n      }\n    } else if (!returned.length && isArray(result) && isString(result[0])) {\n      // watch for proxy events\n      result = fireEvent(this.ractive, result.shift(), context, result);\n    }\n\n    ractive.event = oldEvent;\n\n    return result;\n  } else {\n    return fireEvent(this.ractive, this.action, context, args);\n  }\n};\n\nEventDirective__proto__.handleChange = function handleChange () {};\n\nEventDirective__proto__.render = function render () {\n    var this$1 = this;\n\n  this.events.forEach(function (e) { return e.render(this$1); });\n};\n\nEventDirective__proto__.toString = function toString () {\n  return '';\n};\n\nEventDirective__proto__.unbind = function unbind (view) {\n  removeFromArray(this.element.events, this);\n  this.events.forEach(function (e) { return e.unbind(view); });\n};\n\nEventDirective__proto__.unrender = function unrender () {\n  this.events.forEach(function (e) { return e.unrender(); });\n};\n\nvar proto$3 = EventDirective.prototype;\nproto$3.firstNode = proto$3.rebound = proto$3.update = noop;\n\nfunction progressiveText(item, target, occupants, text) {\n  if (occupants) {\n    var n = occupants[0];\n    if (n && n.nodeType === 3) {\n      var idx = n.nodeValue.indexOf(text);\n      occupants.shift();\n\n      if (idx === 0) {\n        if (n.nodeValue.length !== text.length) {\n          occupants.unshift(n.splitText(text.length));\n        }\n      } else {\n        n.nodeValue = text;\n      }\n    } else {\n      n = item.node = doc.createTextNode(text);\n      if (occupants[0]) {\n        target.insertBefore(n, occupants[0]);\n      } else {\n        target.appendChild(n);\n      }\n    }\n\n    item.node = n;\n  } else {\n    if (!item.node) { item.node = doc.createTextNode(text); }\n    target.appendChild(item.node);\n  }\n}\n\nvar ReferenceExpressionProxy = (function (LinkModel) {\n  function ReferenceExpressionProxy(fragment, template) {\n    LinkModel.call(this, null, null, null, '@undefined');\n    this.root = fragment.ractive.viewmodel;\n    this.template = template;\n    this.rootLink = true;\n    this.template = template;\n    this.fragment = fragment;\n\n    this.rebound();\n  }\n\n  if ( LinkModel ) ReferenceExpressionProxy.__proto__ = LinkModel;\n  var ReferenceExpressionProxy__proto__ = ReferenceExpressionProxy.prototype = Object.create( LinkModel && LinkModel.prototype );\n  ReferenceExpressionProxy__proto__.constructor = ReferenceExpressionProxy;\n\n  ReferenceExpressionProxy__proto__.getKeypath = function getKeypath () {\n    return this.model ? this.model.getKeypath() : '@undefined';\n  };\n\n  ReferenceExpressionProxy__proto__.rebound = function rebound () {\n    var this$1 = this;\n\n    var fragment = this.fragment;\n    var template = this.template;\n\n    var base = (this.base = resolve(fragment, template));\n    var idx;\n\n    if (this.proxy) {\n      teardown$2(this);\n    }\n\n    var proxy = (this.proxy = {\n      rebind: function (next, previous) {\n        if (previous === base) {\n          next = rebindMatch(template, next, previous);\n          if (next !== base) {\n            this$1.base = base = next;\n          }\n        } else if (~(idx = members.indexOf(previous))) {\n          next = rebindMatch(template.m[idx].n, next, previous);\n          if (next !== members[idx]) {\n            members.splice(idx, 1, next || Missing);\n          }\n        }\n\n        if (next !== previous) {\n          previous.unregister(proxy);\n          if (next) { next.addShuffleTask(function () { return next.register(proxy); }); }\n        }\n      },\n      handleChange: function () {\n        pathChanged();\n      }\n    });\n\n    base.register(proxy);\n\n    var members = (this.members = template.m.map(function (tpl) {\n      if (isString(tpl)) {\n        return { get: function () { return tpl; } };\n      }\n\n      var model;\n\n      if (tpl.t === REFERENCE) {\n        model = resolveReference(fragment, tpl.n);\n        model.register(proxy);\n\n        return model;\n      }\n\n      model = new ExpressionProxy(fragment, tpl);\n      model.register(proxy);\n      return model;\n    }));\n\n    var pathChanged = function () {\n      var model =\n        base &&\n        base.joinAll(\n          members.reduce(function (list, m) {\n            var k = m.get();\n            if (isArray(k)) { return list.concat(k); }\n            else { list.push(escapeKey(String(k))); }\n            return list;\n          }, [])\n        );\n\n      if (model !== this$1.model) {\n        this$1.model = model;\n        this$1.relinking(model);\n        fireShuffleTasks();\n        refreshPathDeps(this$1);\n        this$1.fragment.shuffled();\n      }\n    };\n\n    pathChanged();\n  };\n\n  ReferenceExpressionProxy__proto__.teardown = function teardown () {\n    teardown$2(this);\n    LinkModel.prototype.teardown.call(this);\n  };\n\n  ReferenceExpressionProxy__proto__.unreference = function unreference () {\n    LinkModel.prototype.unreference.call(this);\n    if (!this.deps.length && !this.refs) { this.teardown(); }\n  };\n\n  ReferenceExpressionProxy__proto__.unregister = function unregister (dep) {\n    LinkModel.prototype.unregister.call(this, dep);\n    if (!this.deps.length && !this.refs) { this.teardown(); }\n  };\n\n  return ReferenceExpressionProxy;\n}(LinkModel));\n\nfunction teardown$2(proxy) {\n  if (proxy.base) { proxy.base.unregister(proxy.proxy); }\n  if (proxy.models) {\n    proxy.models.forEach(function (m) {\n      if (m.unregister) { m.unregister(proxy); }\n    });\n  }\n}\n\nfunction refreshPathDeps(proxy) {\n  var len = proxy.deps.length;\n  var i, v;\n\n  for (i = 0; i < len; i++) {\n    v = proxy.deps[i];\n    if (v.pathChanged) { v.pathChanged(); }\n    if (v.fragment && v.fragment.pathModel) { v.fragment.pathModel.applyValue(proxy.getKeypath()); }\n  }\n\n  len = proxy.children.length;\n  for (i = 0; i < len; i++) {\n    refreshPathDeps(proxy.children[i]);\n  }\n}\n\nvar eproto = ExpressionProxy.prototype;\nvar proto$4 = ReferenceExpressionProxy.prototype;\n\nproto$4.unreference = eproto.unreference;\nproto$4.unregister = eproto.unregister;\nproto$4.unregisterLink = eproto.unregisterLink;\n\nfunction resolve(fragment, template) {\n  if (template.r) {\n    return resolveReference(fragment, template.r);\n  } else if (template.x) {\n    return new ExpressionProxy(fragment, template.x);\n  } else if (template.rx) {\n    return new ReferenceExpressionProxy(fragment, template.rx);\n  }\n}\n\nvar Mustache = (function (Item) {\n  function Mustache(options) {\n    Item.call(this, options);\n\n    if (options.owner) { this.parent = options.owner; }\n\n    this.isStatic = !!options.template.s;\n\n    this.model = null;\n    this.dirty = false;\n  }\n\n  if ( Item ) Mustache.__proto__ = Item;\n  var Mustache__proto__ = Mustache.prototype = Object.create( Item && Item.prototype );\n  Mustache__proto__.constructor = Mustache;\n\n  Mustache__proto__.bind = function bind (pre) {\n    // yield mustaches and inner contexts should resolve in container context\n    var start = this.template.y\n      ? this.template.y.containerFragment\n      : this.containerFragment || this.up;\n    // try to find a model for this view\n    var model = pre || resolve(start, this.template);\n\n    if (model) {\n      var value = model.get();\n\n      if (this.isStatic) {\n        this.model = { get: function () { return value; } };\n        model.unreference();\n        return;\n      }\n\n      model.register(this);\n      this.model = model;\n    }\n  };\n\n  Mustache__proto__.handleChange = function handleChange () {\n    this.bubble();\n  };\n\n  Mustache__proto__.rebind = function rebind (next, previous, safe) {\n    if (this.isStatic) { return; }\n\n    next = rebindMatch(this.template, next, previous, this.up);\n    if (next === this.model) { return false; }\n\n    if (this.model) {\n      this.model.unregister(this);\n    }\n    if (next) { next.addShuffleRegister(this, 'mark'); }\n    this.model = next;\n    if (!safe) { this.handleChange(); }\n    return true;\n  };\n\n  Mustache__proto__.rebound = function rebound (update) {\n    if (this.model) {\n      if (this.model.rebound) { this.model.rebound(update); }\n      else {\n        // check to see if the model actually changed...\n        // yield mustaches and inner contexts should resolve in container context\n        var start = this.template.y\n          ? this.template.y.containerFragment\n          : this.containerFragment || this.up;\n        // try to find a model for this view\n        var model = resolve(start, this.template);\n        if (model !== this.model) {\n          this.model.unregister(this);\n          this.bind(model);\n        }\n      }\n\n      if (update) { this.bubble(); }\n    }\n    if (this.fragment) { this.fragment.rebound(update); }\n  };\n\n  Mustache__proto__.unbind = function unbind () {\n    if (!this.isStatic) {\n      this.model && this.model.unregister(this);\n      this.model = undefined;\n    }\n  };\n\n  return Mustache;\n}(Item));\n\nfunction MustacheContainer(options) {\n  Mustache.call(this, options);\n}\n\nvar proto$5 = (MustacheContainer.prototype = Object.create(ContainerItem.prototype));\n\nassign(proto$5, Mustache.prototype, { constructor: MustacheContainer });\n\nvar Interpolator = (function (Mustache) {\n  function Interpolator () {\n    Mustache.apply(this, arguments);\n  }\n\n  if ( Mustache ) Interpolator.__proto__ = Mustache;\n  var Interpolator__proto__ = Interpolator.prototype = Object.create( Mustache && Mustache.prototype );\n  Interpolator__proto__.constructor = Interpolator;\n\n  Interpolator__proto__.bubble = function bubble () {\n    if (this.owner) { this.owner.bubble(); }\n    Mustache.prototype.bubble.call(this);\n  };\n\n  Interpolator__proto__.detach = function detach () {\n    return detachNode(this.node);\n  };\n\n  Interpolator__proto__.firstNode = function firstNode () {\n    return this.node;\n  };\n\n  Interpolator__proto__.getString = function getString () {\n    return this.model ? safeToStringValue(this.model.get()) : '';\n  };\n\n  Interpolator__proto__.render = function render (target, occupants) {\n    if (inAttributes()) { return; }\n    var value = (this.value = this.getString());\n\n    this.rendered = true;\n\n    progressiveText(this, target, occupants, value);\n  };\n\n  Interpolator__proto__.toString = function toString (escape) {\n    var string = this.getString();\n    return escape ? escapeHtml(string) : string;\n  };\n\n  Interpolator__proto__.unrender = function unrender (shouldDestroy) {\n    if (shouldDestroy) { this.detach(); }\n    this.rendered = false;\n  };\n\n  Interpolator__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n      if (this.rendered) {\n        var value = this.getString();\n        if (value !== this.value) { this.node.data = this.value = value; }\n      }\n    }\n  };\n\n  Interpolator__proto__.valueOf = function valueOf () {\n    return this.model ? this.model.get() : undefined;\n  };\n\n  return Interpolator;\n}(Mustache));\n\nvar Input = (function (Element) {\n  function Input () {\n    Element.apply(this, arguments);\n  }\n\n  if ( Element ) Input.__proto__ = Element;\n  var Input__proto__ = Input.prototype = Object.create( Element && Element.prototype );\n  Input__proto__.constructor = Input;\n\n  Input__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n    this.node.defaultValue = this.node.value;\n  };\n  Input__proto__.compare = function compare (value, attrValue) {\n    var comparator = this.getAttribute('value-comparator');\n    if (comparator) {\n      if (isFunction(comparator)) {\n        return comparator(value, attrValue);\n      }\n      if (value && attrValue) {\n        return value[comparator] == attrValue[comparator];\n      }\n    }\n    return value == attrValue;\n  };\n\n  return Input;\n}(Element));\n\n// simple JSON parser, without the restrictions of JSON parse\n// (i.e. having to double-quote keys).\n//\n// If passed a hash of values as the second argument, ${placeholders}\n// will be replaced with those values\n\nvar specials$1 = {\n  true: true,\n  false: false,\n  null: null,\n  undefined: undefined\n};\n\nvar specialsPattern = new RegExp('^(?:' + keys(specials$1).join('|') + ')');\nvar numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\nvar placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\nvar placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\nvar onlyWhitespace$1 = /^\\s*$/;\n\nvar JsonParser = Parser.extend({\n  init: function init(str, options) {\n    this.values = options.values;\n    this.sp();\n  },\n\n  postProcess: function postProcess(result) {\n    if (result.length !== 1 || !onlyWhitespace$1.test(this.leftover)) {\n      return null;\n    }\n\n    return { value: result[0].v };\n  },\n\n  converters: [\n    function getPlaceholder(parser) {\n      if (!parser.values) { return null; }\n\n      var placeholder = parser.matchPattern(placeholderAtStartPattern);\n\n      if (placeholder && hasOwn(parser.values, placeholder)) {\n        return { v: parser.values[placeholder] };\n      }\n    },\n\n    function getSpecial(parser) {\n      var special = parser.matchPattern(specialsPattern);\n      if (special) { return { v: specials$1[special] }; }\n    },\n\n    function getNumber(parser) {\n      var number = parser.matchPattern(numberPattern$1);\n      if (number) { return { v: +number }; }\n    },\n\n    function getString(parser) {\n      var stringLiteral = readStringLiteral(parser);\n      var values = parser.values;\n\n      if (stringLiteral && values) {\n        return {\n          v: stringLiteral.v.replace(placeholderPattern, function (match, $1) { return $1 in values ? values[$1] : $1; }\n          )\n        };\n      }\n\n      return stringLiteral;\n    },\n\n    function getObject(parser) {\n      if (!parser.matchString('{')) { return null; }\n\n      var result = {};\n\n      parser.sp();\n\n      if (parser.matchString('}')) {\n        return { v: result };\n      }\n\n      var pair;\n      while ((pair = getKeyValuePair(parser))) {\n        result[pair.key] = pair.value;\n\n        parser.sp();\n\n        if (parser.matchString('}')) {\n          return { v: result };\n        }\n\n        if (!parser.matchString(',')) {\n          return null;\n        }\n      }\n\n      return null;\n    },\n\n    function getArray(parser) {\n      if (!parser.matchString('[')) { return null; }\n\n      var result = [];\n\n      parser.sp();\n\n      if (parser.matchString(']')) {\n        return { v: result };\n      }\n\n      var valueToken;\n      while ((valueToken = parser.read())) {\n        result.push(valueToken.v);\n\n        parser.sp();\n\n        if (parser.matchString(']')) {\n          return { v: result };\n        }\n\n        if (!parser.matchString(',')) {\n          return null;\n        }\n\n        parser.sp();\n      }\n\n      return null;\n    }\n  ]\n});\n\nfunction getKeyValuePair(parser) {\n  parser.sp();\n\n  var key = readKey(parser);\n\n  if (!key) { return null; }\n\n  var pair = { key: key };\n\n  parser.sp();\n  if (!parser.matchString(':')) {\n    return null;\n  }\n  parser.sp();\n\n  var valueToken = parser.read();\n\n  if (!valueToken) { return null; }\n\n  pair.value = valueToken.v;\n  return pair;\n}\n\nfunction parseJSON(str, values) {\n  var parser = new JsonParser(str, { values: values });\n  return parser.result;\n}\n\nvar Mapping = (function (Item) {\n  function Mapping(options) {\n    Item.call(this, options);\n\n    this.name = options.template.n;\n\n    this.owner = options.owner || options.up.owner || options.element || findElement(options.up);\n    this.element =\n      options.element || (this.owner.attributeByName ? this.owner : findElement(options.up));\n    this.up = this.element.up; // shared\n    this.ractive = this.up.ractive;\n\n    this.element.attributeByName[this.name] = this;\n\n    this.value = options.template.f;\n  }\n\n  if ( Item ) Mapping.__proto__ = Item;\n  var Mapping__proto__ = Mapping.prototype = Object.create( Item && Item.prototype );\n  Mapping__proto__.constructor = Mapping;\n\n  Mapping__proto__.bind = function bind () {\n    var template = this.template.f;\n    var viewmodel = this.element.instance.viewmodel;\n\n    if (template === 0) {\n      // empty attributes are `true`\n      viewmodel.joinKey(this.name).set(true);\n    } else if (isString(template)) {\n      var parsed = parseJSON(template);\n      viewmodel.joinKey(this.name).set(parsed ? parsed.value : template);\n    } else if (isArray(template)) {\n      createMapping(this, true);\n    }\n  };\n\n  Mapping__proto__.rebound = function rebound (update) {\n    if (this.boundFragment) { this.boundFragment.rebound(update); }\n    if (this.link) {\n      this.model = resolve(this.up, this.template.f[0]);\n      var model = this.element.instance.viewmodel.joinAll(splitKeypath(this.name));\n      model.link(this.model, this.name, { mapping: true });\n    }\n  };\n\n  Mapping__proto__.render = function render () {};\n\n  Mapping__proto__.unbind = function unbind (view) {\n    if (this.model) { this.model.unregister(this); }\n    if (this.boundFragment) { this.boundFragment.unbind(view); }\n\n    if (this.element.bound) {\n      if (this.link.target === this.model) { this.link.owner.unlink(); }\n    }\n  };\n\n  Mapping__proto__.unrender = function unrender () {};\n\n  Mapping__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n      if (this.boundFragment) { this.boundFragment.update(); }\n    }\n  };\n\n  return Mapping;\n}(Item));\n\nfunction createMapping(item) {\n  var template = item.template.f;\n  var viewmodel = item.element.instance.viewmodel;\n  var childData = viewmodel.value;\n\n  if (template.length === 1 && template[0].t === INTERPOLATOR) {\n    var model = resolve(item.up, template[0]);\n    var val = model.get(false);\n\n    // if the interpolator is not static\n    if (!template[0].s) {\n      item.model = model;\n      item.link = viewmodel.createLink(item.name, model, template[0].r, {\n        mapping: true\n      });\n\n      // initialize parent side of the mapping from child data\n      if (isUndefined(val) && !model.isReadonly && item.name in childData) {\n        model.set(childData[item.name]);\n      }\n    } else if (!isObjectType(val) || template[0].x) {\n      // copy non-object, non-computed vals through\n      viewmodel.joinKey(splitKeypath(item.name)).set(val);\n    } else {\n      // warn about trying to copy an object\n      warnIfDebug((\"Cannot copy non-computed object value from static mapping '\" + (item.name) + \"'\"));\n    }\n\n    // if the item isn't going to manage the model, give it a change to tear down if it's computed\n    if (model !== item.model) { model.unregister(); }\n  } else {\n    item.boundFragment = new Fragment({\n      owner: item,\n      template: template\n    }).bind();\n\n    item.model = viewmodel.joinKey(splitKeypath(item.name));\n    item.model.set(item.boundFragment.valueOf());\n\n    // item is a *bit* of a hack\n    item.boundFragment.bubble = function () {\n      Fragment.prototype.bubble.call(item.boundFragment);\n      // defer this to avoid mucking around model deps if there happens to be an expression involved\n      runloop.scheduleTask(function () {\n        item.boundFragment.update();\n        item.model.set(item.boundFragment.valueOf());\n      });\n    };\n  }\n}\n\nvar Option = (function (Element) {\n  function Option(options) {\n    var template = options.template;\n    if (!template.a) { template.a = {}; }\n\n    // If the value attribute is missing, use the element's content,\n    // as long as it isn't disabled\n    if (isUndefined(template.a.value) && !('disabled' in template.a)) {\n      template.a.value = template.f || '';\n    }\n\n    Element.call(this, options);\n\n    this.select = findElement(this.parent || this.up, false, 'select');\n  }\n\n  if ( Element ) Option.__proto__ = Element;\n  var Option__proto__ = Option.prototype = Object.create( Element && Element.prototype );\n  Option__proto__.constructor = Option;\n\n  Option__proto__.bind = function bind () {\n    if (!this.select) {\n      Element.prototype.bind.call(this);\n      return;\n    }\n\n    // If the select has a value, it overrides the `selected` attribute on\n    // this option - so we delete the attribute\n    var selectedAttribute = this.attributeByName.selected;\n    if (selectedAttribute && this.select.getAttribute('value') !== undefined) {\n      var index = this.attributes.indexOf(selectedAttribute);\n      this.attributes.splice(index, 1);\n      delete this.attributeByName.selected;\n    }\n\n    Element.prototype.bind.call(this);\n    this.select.options.push(this);\n  };\n\n  Option__proto__.bubble = function bubble () {\n    // if we're using content as value, may need to update here\n    var value = this.getAttribute('value');\n    if (this.node && this.node.value !== value) {\n      this.node._ractive.value = value;\n    }\n    Element.prototype.bubble.call(this);\n  };\n\n  Option__proto__.getAttribute = function getAttribute (name) {\n    var attribute = this.attributeByName[name];\n    return attribute\n      ? attribute.getValue()\n      : name === 'value' && this.fragment\n      ? this.fragment.valueOf()\n      : undefined;\n  };\n\n  Option__proto__.isSelected = function isSelected () {\n    var this$1 = this;\n\n    var optionValue = this.getAttribute('value');\n\n    if (isUndefined(optionValue) || !this.select) {\n      return false;\n    }\n\n    var selectValue = this.select.getAttribute('value');\n\n    if (this.select.compare(selectValue, optionValue)) {\n      return true;\n    }\n\n    if (this.select.getAttribute('multiple') && isArray(selectValue)) {\n      var i = selectValue.length;\n      while (i--) {\n        if (this$1.select.compare(selectValue[i], optionValue)) {\n          return true;\n        }\n      }\n    }\n  };\n\n  Option__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n\n    if (!this.attributeByName.value) {\n      this.node._ractive.value = this.getAttribute('value');\n    }\n  };\n\n  Option__proto__.unbind = function unbind (view) {\n    Element.prototype.unbind.call(this, view);\n\n    if (this.select) {\n      removeFromArray(this.select.options, this);\n    }\n  };\n\n  return Option;\n}(Element));\n\nfunction getPartialTemplate(ractive, name, up) {\n  // If the partial in instance or view heirarchy instances, great\n  var partial = getPartialFromRegistry(ractive, name, up || {});\n  if (partial) { return partial; }\n\n  // Does it exist on the page as a script tag?\n  partial = parser.fromId(name, { noThrow: true });\n  if (partial) {\n    // parse and register to this ractive instance\n    var parsed = parser.parseFor(partial, ractive);\n\n    // register extra partials on the ractive instance if they don't already exist\n    if (parsed.p) { fillGaps(ractive.partials, parsed.p); }\n\n    // register (and return main partial if there are others in the template)\n    return (ractive.partials[name] = parsed.t);\n  }\n}\n\nfunction getPartialFromRegistry(ractive, name, up) {\n  // if there was an instance up-hierarchy, cool\n  var partial = findParentPartial(name, up.owner);\n  if (partial) { return partial; }\n\n  // find first instance in the ractive or view hierarchy that has this partial\n  var instance = findInstance('partials', ractive, name);\n\n  if (!instance) {\n    return;\n  }\n\n  partial = instance.partials[name];\n\n  // partial is a function?\n  var fn;\n  if (isFunction(partial)) {\n    fn = partial;\n    // super partial\n    if (fn.styleSet) { return fn; }\n\n    fn = partial.bind(instance);\n    fn.isOwner = hasOwn(instance.partials, name);\n    partial = fn.call(ractive, parser);\n  }\n\n  if (!partial && partial !== '') {\n    warnIfDebug(noRegistryFunctionReturn, name, 'partial', 'partial', {\n      ractive: ractive\n    });\n    return;\n  }\n\n  // If this was added manually to the registry,\n  // but hasn't been parsed, parse it now\n  if (!parser.isParsed(partial)) {\n    // use the parseOptions of the ractive instance on which it was found\n    var parsed = parser.parseFor(partial, instance);\n\n    // Partials cannot contain nested partials!\n    // TODO add a test for this\n    if (parsed.p) {\n      warnIfDebug('Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });\n    }\n\n    // if fn, use instance to store result, otherwise needs to go\n    // in the correct point in prototype chain on instance or constructor\n    var target = fn ? instance : findOwner(instance, name);\n\n    // may be a template with partials, which need to be registered and main template extracted\n    target.partials[name] = partial = parsed.t;\n  }\n\n  // store for reset\n  if (fn) { partial._fn = fn; }\n\n  // if the partial is a pre-parsed template object, import any expressions and update the registry\n  if (partial.v) {\n    addFunctions(partial);\n    return (instance.partials[name] = partial.t);\n  } else {\n    return partial;\n  }\n}\n\nfunction findOwner(ractive, key) {\n  return hasOwn(ractive.partials, key) ? ractive : findConstructor(ractive.constructor, key);\n}\n\nfunction findConstructor(constructor, key) {\n  if (!constructor) {\n    return;\n  }\n  return hasOwn(constructor.partials, key) ? constructor : findConstructor(constructor.Parent, key);\n}\n\nfunction findParentPartial(name, parent) {\n  if (parent) {\n    if (\n      parent.template &&\n      parent.template.p &&\n      !isArray(parent.template.p) &&\n      hasOwn(parent.template.p, name)\n    ) {\n      return parent.template.p[name];\n    } else if (parent.up && parent.up.owner) {\n      return findParentPartial(name, parent.up.owner);\n    }\n  }\n}\n\nfunction Partial(options) {\n  MustacheContainer.call(this, options);\n\n  var tpl = options.template;\n\n  // yielder is a special form of partial that will later require special handling\n  if (tpl.t === YIELDER) {\n    this.yielder = 1;\n  } else if (tpl.t === ELEMENT) {\n    // this is a macro partial, complete with macro constructor\n    // leaving this as an element will confuse up-template searches\n    this.type = PARTIAL;\n    this.macro = options.macro;\n  }\n}\n\nvar proto$6 = (Partial.prototype = create(MustacheContainer.prototype));\n\nassign(proto$6, {\n  constructor: Partial,\n\n  bind: function bind() {\n    var template = this.template;\n\n    if (this.yielder) {\n      // the container is the instance that owns this node\n      this.container = this.up.ractive;\n      this.component = this.container.component;\n      this.containerFragment = this.up;\n\n      // normal component\n      if (this.component) {\n        // yields skip the owning instance and go straight to the surrounding context\n        this.up = this.component.up;\n\n        // {{yield}} is equivalent to {{yield content}}\n        if (!template.r && !template.x && !template.rx) { this.refName = 'content'; }\n      } else {\n        // plain-ish instance that may be attached to a parent later\n        this.fragment = new Fragment({\n          owner: this,\n          template: []\n        });\n        this.fragment.bind();\n        return;\n      }\n    }\n\n    // this is a macro/super partial\n    if (this.macro) {\n      this.fn = this.macro;\n    } else {\n      // this is a plain partial or yielder\n      if (!this.refName) { this.refName = template.r; }\n\n      // if the refName exists as a partial, this is a plain old partial reference where no model binding will happen\n      if (this.refName) {\n        partialFromValue(this, this.refName);\n      }\n\n      // this is a dynamic/inline partial\n      if (!this.partial && !this.fn) {\n        MustacheContainer.prototype.bind.call(this);\n        if (this.model) { partialFromValue(this, this.model.get()); }\n      }\n    }\n\n    if (!this.partial && !this.fn) {\n      warnOnceIfDebug((\"Could not find template for partial '\" + (this.name) + \"'\"));\n    }\n\n    createFragment(this, this.partial || []);\n\n    // macro/super partial\n    if (this.fn) { initMacro(this); }\n\n    this.fragment.bind();\n  },\n\n  bubble: function bubble() {\n    if (!this.dirty) {\n      this.dirty = true;\n\n      if (this.yielder) {\n        this.containerFragment.bubble();\n      } else {\n        this.up.bubble();\n      }\n    }\n  },\n\n  findNextNode: function findNextNode() {\n    return (this.containerFragment || this.up).findNextNode(this);\n  },\n\n  handleChange: function handleChange() {\n    this.dirtyTemplate = true;\n    this.externalChange = true;\n    this.bubble();\n  },\n\n  rebound: function rebound(update) {\n    var this$1 = this;\n\n    if (this._attrs) {\n      keys(this._attrs).forEach(function (k) { return this$1._attrs[k].rebound(update); });\n    }\n    MustacheContainer.prototype.rebound.call(this, update);\n  },\n\n  refreshAttrs: function refreshAttrs() {\n    var this$1 = this;\n\n    keys(this._attrs).forEach(function (k) {\n      this$1.handle.attributes[k] = !this$1._attrs[k].items.length || this$1._attrs[k].valueOf();\n    });\n  },\n\n  resetTemplate: function resetTemplate() {\n    var this$1 = this;\n\n    if (this.fn && this.proxy) {\n      this.last = 0;\n      if (this.externalChange) {\n        if (isFunction(this.proxy.teardown)) { this.proxy.teardown(); }\n        this.fn = this.proxy = null;\n      } else {\n        this.partial = this.fnTemplate;\n        return true;\n      }\n    }\n\n    this.partial = null;\n\n    if (this.refName) {\n      this.partial = getPartialTemplate(this.ractive, this.refName, this.up);\n    }\n\n    if (!this.partial && this.model) {\n      partialFromValue(this, this.model.get());\n    }\n\n    if (!this.fn) {\n      if (this.last && this.partial === this.last) { return false; }\n      else if (this.partial) {\n        this.last = this.partial;\n        contextifyTemplate(this);\n      }\n    }\n\n    this.unbindAttrs();\n\n    if (this.fn) {\n      initMacro(this);\n      if (isFunction(this.proxy.render)) { runloop.scheduleTask(function () { return this$1.proxy.render(); }); }\n    } else if (!this.partial) {\n      warnOnceIfDebug((\"Could not find template for partial '\" + (this.name) + \"'\"));\n    }\n\n    return true;\n  },\n\n  render: function render(target, occupants) {\n    if (this.fn && this.fn._cssDef && !this.fn._cssDef.applied) { applyCSS(); }\n\n    this.fragment.render(target, occupants);\n\n    if (this.proxy && isFunction(this.proxy.render)) { this.proxy.render(); }\n  },\n\n  unbind: function unbind(view) {\n    this.fragment.unbind(view);\n\n    this.unbindAttrs(view);\n\n    MustacheContainer.prototype.unbind.call(this, view);\n  },\n\n  unbindAttrs: function unbindAttrs(view) {\n    var this$1 = this;\n\n    if (this._attrs) {\n      keys(this._attrs).forEach(function (k) {\n        this$1._attrs[k].unbind(view);\n      });\n    }\n  },\n\n  unrender: function unrender(shouldDestroy) {\n    if (this.proxy && isFunction(this.proxy.teardown)) { this.proxy.teardown(); }\n\n    this.fragment.unrender(shouldDestroy);\n  },\n\n  update: function update() {\n    var this$1 = this;\n\n    var proxy = this.proxy;\n    this.updating = 1;\n\n    if (this.dirtyAttrs) {\n      this.dirtyAttrs = false;\n      keys(this._attrs).forEach(function (k) { return this$1._attrs[k].update(); });\n      this.refreshAttrs();\n      if (isFunction(proxy.update)) { proxy.update(this.handle.attributes); }\n    }\n\n    if (this.dirtyTemplate) {\n      this.dirtyTemplate = false;\n      this.resetTemplate() && this.fragment.resetTemplate(this.partial || []);\n    }\n\n    if (this.dirty) {\n      this.dirty = false;\n      if (proxy && isFunction(proxy.invalidate)) { proxy.invalidate(); }\n      this.fragment.update();\n    }\n\n    this.externalChange = false;\n    this.updating = 0;\n  }\n});\n\nfunction createFragment(self, partial) {\n  self.partial = self.last = partial;\n  contextifyTemplate(self);\n\n  var options = {\n    owner: self,\n    template: self.partial\n  };\n\n  if (self.yielder) { options.ractive = self.container.parent; }\n\n  if (self.fn) { options.cssIds = self.fn._cssIds; }\n\n  self.fragment = new Fragment(options);\n}\n\nfunction contextifyTemplate(self) {\n  if (self.template.c) {\n    self.partial = [{ t: SECTION, n: SECTION_WITH, f: self.partial }];\n    assign(self.partial[0], self.template.c);\n    if (self.yielder) { self.partial[0].y = self; }\n    else { self.partial[0].z = self.template.z; }\n  }\n}\n\nfunction partialFromValue(self, value, okToParse) {\n  var tpl = value;\n\n  if (isArray(tpl)) {\n    self.partial = tpl;\n  } else if (tpl && isObjectType(tpl)) {\n    if (isArray(tpl.t)) { self.partial = tpl.t; }\n    else if (isString(tpl.template))\n      { self.partial = parsePartial(tpl.template, tpl.template, self.ractive).t; }\n  } else if (isFunction(tpl) && tpl.styleSet) {\n    self.fn = tpl;\n    if (self.fragment) { self.fragment.cssIds = tpl._cssIds; }\n  } else if (tpl != null) {\n    tpl = getPartialTemplate(self.ractive, '' + tpl, self.containerFragment || self.up);\n    if (tpl) {\n      self.name = value;\n      if (tpl.styleSet) {\n        self.fn = tpl;\n        if (self.fragment) { self.fragment.cssIds = tpl._cssIds; }\n      } else { self.partial = tpl; }\n    } else if (okToParse) {\n      self.partial = parsePartial('' + value, '' + value, self.ractive).t;\n    } else {\n      self.name = value;\n    }\n  }\n\n  return self.partial;\n}\n\nfunction setTemplate(template) {\n  partialFromValue(this, template, true);\n\n  if (!this.initing) {\n    this.dirtyTemplate = true;\n    this.fnTemplate = this.partial;\n\n    if (this.updating) {\n      this.bubble();\n      runloop.promise();\n    } else {\n      var promise = runloop.start();\n\n      this.bubble();\n      runloop.end();\n\n      return promise;\n    }\n  }\n}\n\nfunction aliasLocal(ref, name) {\n  var aliases = this.fragment.aliases || (this.fragment.aliases = {});\n  if (!name) {\n    aliases[ref] = this._data;\n  } else {\n    aliases[name] = this._data.joinAll(splitKeypath(ref));\n  }\n}\n\nvar extras = 'extra-attributes';\n\nfunction initMacro(self) {\n  var fn = self.fn;\n  var fragment = self.fragment;\n\n  // defensively copy the template in case it changes\n  var template = (self.template = assign({}, self.template));\n  var handle = (self.handle = fragment.getContext({\n    proxy: self,\n    aliasLocal: aliasLocal,\n    name: self.template.e || self.name,\n    attributes: {},\n    setTemplate: setTemplate.bind(self),\n    template: template,\n    macro: fn\n  }));\n\n  if (!template.p) { template.p = {}; }\n  template.p = handle.partials = assign({}, template.p);\n  if (!hasOwn(template.p, 'content')) { template.p.content = template.f || []; }\n\n  if (isArray(fn.attributes)) {\n    self._attrs = {};\n\n    var invalidate = function() {\n      this.dirty = true;\n      self.dirtyAttrs = true;\n      self.bubble();\n    };\n\n    if (isArray(template.m)) {\n      var attrs = template.m;\n      template.p[extras] = template.m = attrs.filter(function (a) { return !~fn.attributes.indexOf(a.n); });\n      attrs\n        .filter(function (a) { return ~fn.attributes.indexOf(a.n); })\n        .forEach(function (a) {\n          var fragment = new Fragment({\n            template: a.f,\n            owner: self\n          });\n          fragment.bubble = invalidate;\n          fragment.findFirstNode = noop;\n          self._attrs[a.n] = fragment;\n        });\n    } else {\n      template.p[extras] = [];\n    }\n  } else {\n    template.p[extras] = template.m;\n  }\n\n  if (self._attrs) {\n    keys(self._attrs).forEach(function (k) {\n      self._attrs[k].bind();\n    });\n    self.refreshAttrs();\n  }\n\n  self.initing = 1;\n  self.proxy = fn.call(self.ractive, handle, handle.attributes) || {};\n  if (!self.partial) { self.partial = []; }\n  self.fnTemplate = self.partial;\n  self.initing = 0;\n\n  contextifyTemplate(self);\n  fragment.resetTemplate(self.partial);\n}\n\nfunction parsePartial(name, partial, ractive) {\n  var parsed;\n\n  try {\n    parsed = parser.parse(partial, parser.getParseOptions(ractive));\n  } catch (e) {\n    warnIfDebug((\"Could not parse partial from expression '\" + name + \"'\\n\" + (e.message)));\n  }\n\n  return parsed || { t: [] };\n}\n\nvar KeyModel = function KeyModel(value, context, instance) {\n  this.value = this.key = value;\n  this.context = context;\n  this.isReadonly = this.isKey = true;\n  this.deps = [];\n  this.links = [];\n  this.children = [];\n  this.instance = instance;\n};\nvar KeyModel__proto__ = KeyModel.prototype;\n\nKeyModel__proto__.applyValue = function applyValue (value) {\n  if (value !== this.value) {\n    this.value = this.key = value;\n    this.deps.forEach(handleChange);\n    this.links.forEach(handleChange);\n    this.children.forEach(function (c) {\n      c.applyValue(c.context.getKeypath(c.instance));\n    });\n  }\n};\n\nKeyModel__proto__.destroyed = function destroyed () {\n  if (this.upstream) { this.upstream.unregisterChild(this); }\n};\n\nKeyModel__proto__.get = function get (shouldCapture) {\n  if (shouldCapture) { capture(this); }\n  return unescapeKey(this.value);\n};\n\nKeyModel__proto__.getKeypath = function getKeypath () {\n  return unescapeKey(this.value);\n};\n\nKeyModel__proto__.has = function has () {\n  return false;\n};\n\nKeyModel__proto__.rebind = function rebind (next, previous) {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) { this$1.deps[i].rebind(next, previous, false); }\n\n  i = this.links.length;\n  while (i--) { this$1.links[i].relinking(next, false); }\n};\n\nKeyModel__proto__.register = function register (dependant) {\n  this.deps.push(dependant);\n};\n\nKeyModel__proto__.registerChild = function registerChild (child) {\n  addToArray(this.children, child);\n  child.upstream = this;\n};\n\nKeyModel__proto__.registerLink = function registerLink (link) {\n  addToArray(this.links, link);\n};\n\nKeyModel__proto__.unregister = function unregister (dependant) {\n  removeFromArray(this.deps, dependant);\n};\n\nKeyModel__proto__.unregisterChild = function unregisterChild (child) {\n  removeFromArray(this.children, child);\n};\n\nKeyModel__proto__.unregisterLink = function unregisterLink (link) {\n  removeFromArray(this.links, link);\n};\n\nKeyModel.prototype.reference = noop;\nKeyModel.prototype.unreference = noop;\n\nvar keypathString = /^\"(\\\\\"|[^\"])+\"$/;\n\nvar RepeatedFragment = function RepeatedFragment(options) {\n  this.parent = options.owner.up;\n\n  // bit of a hack, so reference resolution works without another\n  // layer of indirection\n  this.up = this;\n  this.owner = options.owner;\n  this.ractive = this.parent.ractive;\n  this.delegate =\n    this.ractive.delegate !== false && (this.parent.delegate || findDelegate(this.parent));\n  // delegation disabled by directive\n  if (this.delegate && this.delegate.delegate === false) { this.delegate = false; }\n  // let the element know it's a delegate handler\n  if (this.delegate) { this.delegate.delegate = this.delegate; }\n\n  // encapsulated styles should be inherited until they get applied by an element\n  this.cssIds = 'cssIds' in options ? options.cssIds : this.parent ? this.parent.cssIds : null;\n\n  this.context = null;\n  this.rendered = false;\n  this.iterations = [];\n\n  this.template = options.template;\n\n  this.indexRef = options.indexRef;\n  this.keyRef = options.keyRef;\n\n  this.pendingNewIndices = null;\n  this.previousIterations = null;\n\n  // track array versus object so updates of type rest\n  this.isArray = false;\n};\nvar RepeatedFragment__proto__ = RepeatedFragment.prototype;\n\nRepeatedFragment__proto__.bind = function bind (context) {\n    var this$1 = this;\n\n  this.context = context;\n  this.bound = true;\n  var value = context.get();\n\n  var aliases = (this.aliases = this.owner.template.z && this.owner.template.z.slice());\n\n  var shuffler = aliases && aliases.find(function (a) { return a.n === 'shuffle'; });\n  if (shuffler && shuffler.x && shuffler.x.x) {\n    if (shuffler.x.x.s === 'true') { this.shuffler = true; }\n    else if (keypathString.test(shuffler.x.x.s))\n      { this.shuffler = splitKeypath(shuffler.x.x.s.slice(1, -1)); }\n  }\n\n  if (this.shuffler) { this.values = shuffleValues(this, this.shuffler); }\n\n  if (this.source) { this.source.model.unbind(this.source); }\n  var source = context.isComputed && aliases && aliases.find(function (a) { return a.n === 'source'; });\n  if (source && source.x && source.x.r) {\n    var model = resolve(this, source.x);\n    this.source = {\n      handleChange: function handleChange() {},\n      rebind: function rebind(next) {\n        this.model.unregister(this);\n        this.model = next;\n        next.register(this);\n      }\n    };\n    this.source.model = model;\n    model.register(this.source);\n  }\n\n  // {{#each array}}...\n  if ((this.isArray = isArray(value))) {\n    // we can't use map, because of sparse arrays\n    this.iterations = [];\n    var max = (this.length = value.length);\n    for (var i = 0; i < max; i += 1) {\n      this$1.iterations[i] = this$1.createIteration(i, i);\n    }\n  } else if (isObject(value)) {\n    // {{#each object}}...\n    this.isArray = false;\n\n    // TODO this is a dreadful hack. There must be a neater way\n    if (this.indexRef) {\n      var refs = this.indexRef.split(',');\n      this.keyRef = refs[0];\n      this.indexRef = refs[1];\n    }\n\n    var ks = keys(value);\n    this.length = ks.length;\n\n    this.iterations = ks.map(function (key, index) {\n      return this$1.createIteration(key, index);\n    });\n  }\n\n  return this;\n};\n\nRepeatedFragment__proto__.bubble = function bubble (index) {\n  if (!this.bubbled) { this.bubbled = []; }\n  this.bubbled.push(index);\n\n  if (!this.rebounding) { this.owner.bubble(); }\n};\n\nRepeatedFragment__proto__.createIteration = function createIteration (key, index) {\n  var fragment = new Fragment({\n    owner: this,\n    template: this.template\n  });\n\n  fragment.isIteration = true;\n  fragment.delegate = this.delegate;\n\n  if (this.aliases) { fragment.aliases = {}; }\n  swizzleFragment(this, fragment, key, index);\n\n  return fragment.bind(fragment.context);\n};\n\nRepeatedFragment__proto__.destroyed = function destroyed () {\n    var this$1 = this;\n\n  var len = this.iterations.length;\n  for (var i = 0; i < len; i++) { this$1.iterations[i].destroyed(); }\n  if (this.pathModel) { this.pathModel.destroyed(); }\n  if (this.rootModel) { this.rootModel.destroyed(); }\n};\n\nRepeatedFragment__proto__.detach = function detach () {\n  var docFrag = createDocumentFragment();\n  this.iterations.forEach(function (fragment) { return docFrag.appendChild(fragment.detach()); });\n  return docFrag;\n};\n\nRepeatedFragment__proto__.find = function find (selector, options) {\n  return findMap(this.iterations, function (i) { return i.find(selector, options); });\n};\n\nRepeatedFragment__proto__.findAll = function findAll (selector, options) {\n  return this.iterations.forEach(function (i) { return i.findAll(selector, options); });\n};\n\nRepeatedFragment__proto__.findAllComponents = function findAllComponents (name, options) {\n  return this.iterations.forEach(function (i) { return i.findAllComponents(name, options); });\n};\n\nRepeatedFragment__proto__.findComponent = function findComponent (name, options) {\n  return findMap(this.iterations, function (i) { return i.findComponent(name, options); });\n};\n\nRepeatedFragment__proto__.findContext = function findContext () {\n  return this.context;\n};\n\nRepeatedFragment__proto__.findNextNode = function findNextNode (iteration) {\n    var this$1 = this;\n\n  if (iteration.index < this.iterations.length - 1) {\n    for (var i = iteration.index + 1; i < this.iterations.length; i++) {\n      var node = this$1.iterations[i].firstNode(true);\n      if (node) { return node; }\n    }\n  }\n\n  return this.owner.findNextNode();\n};\n\nRepeatedFragment__proto__.firstNode = function firstNode (skipParent) {\n  return this.iterations[0] ? this.iterations[0].firstNode(skipParent) : null;\n};\n\nRepeatedFragment__proto__.getLast = function getLast () {\n  return this.lastModel || (this.lastModel = new KeyModel(this.length - 1));\n};\n\nRepeatedFragment__proto__.rebind = function rebind (next) {\n    var this$1 = this;\n\n  this.context = next;\n  if (this.source) { return; }\n  if (next) {\n    this.iterations.forEach(function (fragment) {\n      swizzleFragment(this$1, fragment, fragment.key, fragment.index);\n    });\n  }\n};\n\nRepeatedFragment__proto__.rebound = function rebound (update$$1) {\n    var this$1 = this;\n\n  this.context = this.owner.model;\n  this.iterations.forEach(function (f, i) {\n    f.context = contextFor(this$1, f, i);\n    f.rebound(update$$1);\n  });\n};\n\nRepeatedFragment__proto__.render = function render (target, occupants) {\n  var xs = this.iterations;\n  if (xs) {\n    var len = xs.length;\n    for (var i = 0; i < len; i++) {\n      xs[i].render(target, occupants);\n    }\n  }\n\n  this.rendered = true;\n};\n\nRepeatedFragment__proto__.shuffle = function shuffle (newIndices, merge) {\n    var this$1 = this;\n\n  if (!this.pendingNewIndices) { this.previousIterations = this.iterations.slice(); }\n\n  if (!this.pendingNewIndices) { this.pendingNewIndices = []; }\n\n  this.pendingNewIndices.push(newIndices);\n\n  var iterations = [];\n\n  newIndices.forEach(function (newIndex, oldIndex) {\n    if (newIndex === -1) { return; }\n\n    var fragment = this$1.iterations[oldIndex];\n    iterations[newIndex] = fragment;\n\n    if (newIndex !== oldIndex && fragment) {\n      fragment.dirty = true;\n      if (merge) { fragment.shouldRebind = 1; }\n    }\n  });\n\n  this.iterations = iterations;\n\n  // if merging, we're in the midst of an update already\n  if (!merge) { this.bubble(); }\n};\n\nRepeatedFragment__proto__.shuffled = function shuffled$2 () {\n  this.iterations.forEach(shuffled);\n};\n\nRepeatedFragment__proto__.toString = function toString (escape) {\n  return this.iterations ? this.iterations.map(escape ? toEscapedString : toString$1).join('') : '';\n};\n\nRepeatedFragment__proto__.unbind = function unbind (view) {\n  this.bound = false;\n  if (this.source) { this.source.model.unregister(this.source); }\n  var iterations = this.pendingNewIndices ? this.previousIterations : this.iterations;\n  var len = iterations.length;\n  for (var i = 0; i < len; i++) { iterations[i].unbind(view); }\n  return this;\n};\n\nRepeatedFragment__proto__.unrender = function unrender (shouldDestroy) {\n    var this$1 = this;\n\n  var len = this.iterations.length;\n  for (var i = 0; i < len; i++) { this$1.iterations[i].unrender(shouldDestroy); }\n  if (this.pendingNewIndices && this.previousIterations) {\n    len = this.previousIterations.length;\n    for (var i$1 = 0; i$1 < len; i$1++) { this$1.previousIterations[i$1].unrender(shouldDestroy); }\n  }\n  this.rendered = false;\n};\n\nRepeatedFragment__proto__.update = function update$3 () {\n    var this$1 = this;\n\n  if (this.pendingNewIndices) {\n    this.bubbled.length = 0;\n    this.updatePostShuffle();\n    return;\n  }\n\n  if (this.updating) { return; }\n  this.updating = true;\n\n  if (this.shuffler) {\n    var values = shuffleValues(this, this.shuffler);\n    var newIndices = buildNewIndices(this.values, values);\n    if (!newIndices.same) {\n      this.shuffle(newIndices, true);\n      this.updatePostShuffle();\n    } else {\n      this.iterations.forEach(update);\n    }\n  } else {\n    var len = this.iterations.length;\n    for (var i = 0; i < len; i++) {\n      var f = this$1.iterations[i];\n      f && f.idxModel && f.idxModel.applyValue(i);\n    }\n\n    var value = this.context.get();\n    var wasArray = this.isArray;\n\n    var toRemove;\n    var oldKeys;\n    var reset = true;\n    var i$1;\n\n    if ((this.isArray = isArray(value))) {\n      // if there's a source to map back to, make sure everything stays bound correctly\n      if (this.source) {\n        this.rebounding = 1;\n        var source = this.source.model.get();\n        this.iterations.forEach(function (f, c) {\n          if (c < value.length && f.lastValue !== value[c] && ~(i$1 = source.indexOf(value[c]))) {\n            swizzleFragment(this$1, f, c, c);\n            f.rebound(true);\n          }\n        });\n        this.rebounding = 0;\n      }\n\n      if (wasArray) {\n        reset = false;\n        if (this.iterations.length > value.length) {\n          toRemove = this.iterations.splice(value.length);\n        }\n      }\n    } else if (isObject(value) && !wasArray) {\n      reset = false;\n      toRemove = [];\n      oldKeys = {};\n      i$1 = this.iterations.length;\n\n      while (i$1--) {\n        var fragment = this$1.iterations[i$1];\n        if (fragment.key in value) {\n          oldKeys[fragment.key] = true;\n        } else {\n          this$1.iterations.splice(i$1, 1);\n          toRemove.push(fragment);\n        }\n      }\n    }\n\n    var newLength = isArray(value) ? value.length : isObject(value) ? keys(value).length : 0;\n    this.length = newLength;\n    this.updateLast();\n\n    if (reset) {\n      toRemove = this.iterations;\n      this.iterations = [];\n    }\n\n    if (toRemove) {\n      len = toRemove.length;\n      for (var i$2 = 0; i$2 < len; i$2++) { toRemove[i$2].unbind().unrender(true); }\n    }\n\n    // update the remaining ones\n    if (!reset && this.isArray && this.bubbled && this.bubbled.length) {\n      var bubbled = this.bubbled;\n      this.bubbled = [];\n      len = bubbled.length;\n      for (var i$3 = 0; i$3 < len; i$3++)\n        { this$1.iterations[bubbled[i$3]] && this$1.iterations[bubbled[i$3]].update(); }\n    } else {\n      len = this.iterations.length;\n      for (var i$4 = 0; i$4 < len; i$4++) { this$1.iterations[i$4].update(); }\n    }\n\n    // add new iterations\n    var docFrag;\n    var fragment$1;\n\n    if (newLength > this.iterations.length) {\n      docFrag = this.rendered ? createDocumentFragment() : null;\n      i$1 = this.iterations.length;\n\n      if (isArray(value)) {\n        while (i$1 < value.length) {\n          fragment$1 = this$1.createIteration(i$1, i$1);\n\n          this$1.iterations.push(fragment$1);\n          if (this$1.rendered) { fragment$1.render(docFrag); }\n\n          i$1 += 1;\n        }\n      } else if (isObject(value)) {\n        // TODO this is a dreadful hack. There must be a neater way\n        if (this.indexRef && !this.keyRef) {\n          var refs = this.indexRef.split(',');\n          this.keyRef = refs[0];\n          this.indexRef = refs[1];\n        }\n\n        keys(value).forEach(function (key) {\n          if (!oldKeys || !(key in oldKeys)) {\n            fragment$1 = this$1.createIteration(key, i$1);\n\n            this$1.iterations.push(fragment$1);\n            if (this$1.rendered) { fragment$1.render(docFrag); }\n\n            i$1 += 1;\n          }\n        });\n      }\n\n      if (this.rendered) {\n        var parentNode = this.parent.findParentNode();\n        var anchor = this.parent.findNextNode(this.owner);\n\n        parentNode.insertBefore(docFrag, anchor);\n      }\n    }\n  }\n\n  this.updating = false;\n};\n\nRepeatedFragment__proto__.updateLast = function updateLast () {\n  if (this.lastModel) { this.lastModel.applyValue(this.length - 1); }\n};\n\nRepeatedFragment__proto__.updatePostShuffle = function updatePostShuffle () {\n    var this$1 = this;\n\n  var newIndices = this.pendingNewIndices[0];\n  var parentNode = this.rendered ? this.parent.findParentNode() : null;\n  var nextNode = parentNode && this.owner.findNextNode();\n  var docFrag = parentNode ? createDocumentFragment() : null;\n\n  // map first shuffle through\n  this.pendingNewIndices.slice(1).forEach(function (indices) {\n    newIndices.forEach(function (newIndex, oldIndex) {\n      newIndices[oldIndex] = indices[newIndex];\n    });\n  });\n\n  var len = (this.length = this.context.get().length);\n  var prev = this.previousIterations;\n  var iters = this.iterations;\n  var value = this.context.get();\n  var stash = {};\n  var idx, dest, pos, next, anchor, rebound;\n\n  var map = new Array(newIndices.length);\n  newIndices.forEach(function (e, i) { return (map[e] = i); });\n\n  this.updateLast();\n\n  idx = pos = 0;\n  while (idx < len) {\n    // if there's not an existing thing to shuffle, handle that\n    if (isUndefined(map[idx])) {\n      next = iters[idx] = this$1.createIteration(idx, idx);\n      if (parentNode) {\n        anchor = prev[pos];\n        anchor = (anchor && parentNode && anchor.firstNode()) || nextNode;\n\n        next.render(docFrag);\n        parentNode.insertBefore(docFrag, anchor);\n      }\n\n      idx++;\n    } else {\n      dest = newIndices[pos];\n\n      if (dest === -1) {\n        // if it needs to be dropped, drop it\n        prev[pos] && prev[pos].unbind().unrender(true);\n        prev[pos++] = 0;\n      } else if (dest > idx) {\n        // if it needs to move down, stash it\n        stash[dest] = prev[pos];\n        prev[pos++] = null;\n      } else {\n        // get the fragment that goes for this idx\n        iters[idx] = next = iters[idx] || stash[idx] || this$1.createIteration(idx, idx);\n\n        // if it's an existing fragment, swizzle\n        if (stash[idx] || pos !== idx) {\n          rebound = this$1.source && next.lastValue !== value[idx];\n          swizzleFragment(this$1, next, idx, idx);\n        }\n\n        // does next need to be moved?\n        if (parentNode && (stash[idx] || !prev[pos])) {\n          anchor = prev[pos + 1];\n          anchor = (anchor && parentNode && anchor.firstNode()) || nextNode;\n\n          if (stash[idx]) {\n            parentNode.insertBefore(next.detach(), anchor);\n          } else {\n            next.render(docFrag);\n            parentNode.insertBefore(docFrag, anchor);\n          }\n        }\n\n        prev[pos++] = 0;\n        idx++;\n      }\n\n      if (next && isObjectType(next)) {\n        if (next.shouldRebind || rebound) {\n          next.rebound(rebound);\n          next.shouldRebind = 0;\n        }\n        next.update();\n        next.shuffled();\n      }\n    }\n  }\n\n  // clean up any stragglers\n  var plen = prev.length;\n  for (var i = 0; i < plen; i++) { prev[i] && prev[i].unbind().unrender(true); }\n\n  if (this.shuffler) { this.values = shuffleValues(this, this.shuffler); }\n\n  this.pendingNewIndices = null;\n  this.previousIterations = null;\n};\n\nRepeatedFragment.prototype.getContext = getContext;\nRepeatedFragment.prototype.getKeypath = getKeypath;\n\n// find the topmost delegate\nfunction findDelegate(start) {\n  var frag = start;\n  var delegate, el;\n\n  out: while (frag) {\n    // find next element\n    el = 0;\n    while (!el && frag) {\n      if (frag.owner.type === ELEMENT) { el = frag.owner; }\n      if (frag.owner.ractive && frag.owner.ractive.delegate === false) { break out; }\n      frag = frag.parent || frag.componentParent;\n    }\n\n    if (el.delegate === false) { break out; }\n    delegate = el.delegate || el;\n\n    // find next repeated fragment\n    while (frag) {\n      if (frag.iterations) { break; }\n      if (frag.owner.ractive && frag.owner.ractive.delegate === false) { break out; }\n      frag = frag.parent || frag.componentParent;\n    }\n  }\n\n  return delegate;\n}\n\nfunction swizzleFragment(section, fragment, key, idx) {\n  var model = section.context ? contextFor(section, fragment, key) : undefined;\n\n  fragment.key = key;\n  fragment.index = idx;\n  fragment.context = model;\n  if (section.source) { fragment.lastValue = model && model.get(); }\n\n  if (fragment.idxModel) { fragment.idxModel.applyValue(idx); }\n  if (fragment.keyModel) { fragment.keyModel.applyValue(key); }\n  if (fragment.pathModel) {\n    fragment.pathModel.context = model;\n    fragment.pathModel.applyValue(model.getKeypath());\n  }\n  if (fragment.rootModel) {\n    fragment.rootModel.context = model;\n    fragment.rootModel.applyValue(model.getKeypath(fragment.ractive.root));\n  }\n\n  // handle any aliases\n  var aliases = fragment.aliases;\n  section.aliases &&\n    section.aliases.forEach(function (a) {\n      if (a.x.r === '.') { aliases[a.n] = model; }\n      else if (a.x.r === '@index') { aliases[a.n] = fragment.getIndex(); }\n      else if (a.x.r === '@key') { aliases[a.n] = fragment.getKey(); }\n      else if (a.x.r === '@keypath') { aliases[a.n] = fragment.getKeypath(); }\n      else if (a.x.r === '@rootpath') { aliases[a.n] = fragment.getKeypath(true); }\n    });\n}\n\nfunction shuffleValues(section, shuffler) {\n  var array = section.context.get() || [];\n  if (shuffler === true) {\n    return array.slice();\n  } else {\n    return array.map(function (v) { return shuffler.reduce(function (a, c) { return a && a[c]; }, v); });\n  }\n}\n\nfunction contextFor(section, fragment, key) {\n  if (section.source) {\n    var idx;\n    var source = section.source.model.get();\n    if (source.indexOf && ~(idx = source.indexOf(section.context.joinKey(key).get())))\n      { return section.source.model.joinKey(idx); }\n  }\n\n  return section.context.joinKey(key);\n}\n\nfunction isEmpty(value) {\n  return (\n    !value ||\n    (isArray(value) && value.length === 0) ||\n    (isObject(value) && keys(value).length === 0)\n  );\n}\n\nfunction getType(value, hasIndexRef) {\n  if (hasIndexRef || isArray(value)) { return SECTION_EACH; }\n  if (isObjectLike(value)) { return SECTION_IF_WITH; }\n  if (isUndefined(value)) { return null; }\n  return SECTION_IF;\n}\n\nvar Section = (function (MustacheContainer) {\n  function Section(options) {\n    MustacheContainer.call(this, options);\n\n    this.isAlias = options.template.t === ALIAS;\n    this.sectionType = options.template.n || (this.isAlias && SECTION_WITH) || null;\n    this.templateSectionType = this.sectionType;\n    this.subordinate = options.template.l === 1;\n    this.fragment = null;\n  }\n\n  if ( MustacheContainer ) Section.__proto__ = MustacheContainer;\n  var Section__proto__ = Section.prototype = Object.create( MustacheContainer && MustacheContainer.prototype );\n  Section__proto__.constructor = Section;\n\n  Section__proto__.bind = function bind () {\n    MustacheContainer.prototype.bind.call(this);\n\n    if (this.subordinate) {\n      this.sibling = this.up.items[this.up.items.indexOf(this) - 1];\n      this.sibling.nextSibling = this;\n    }\n\n    // if we managed to bind, we need to create children\n    if (this.model || this.isAlias) {\n      this.dirty = true;\n      this.update();\n    } else if (\n      this.sectionType &&\n      this.sectionType === SECTION_UNLESS &&\n      (!this.sibling || !this.sibling.isTruthy())\n    ) {\n      this.fragment = new Fragment({\n        owner: this,\n        template: this.template.f\n      }).bind();\n    }\n  };\n\n  Section__proto__.bubble = function bubble () {\n    if (!this.dirty && this.yield) {\n      this.dirty = true;\n      this.containerFragment.bubble();\n    } else { MustacheContainer.prototype.bubble.call(this); }\n  };\n\n  Section__proto__.detach = function detach () {\n    var frag = this.fragment || this.detached;\n    return frag ? frag.detach() : MustacheContainer.prototype.detach.call(this);\n  };\n\n  Section__proto__.findNextNode = function findNextNode () {\n    return (this.containerFragment || this.up).findNextNode(this);\n  };\n\n  Section__proto__.isTruthy = function isTruthy () {\n    if (this.subordinate && this.sibling.isTruthy()) { return true; }\n    var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n    return !!value && (this.templateSectionType === SECTION_IF_WITH || !isEmpty(value));\n  };\n\n  Section__proto__.rebind = function rebind (next, previous, safe) {\n    if (MustacheContainer.prototype.rebind.call(this, next, previous, safe)) {\n      if (this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS) {\n        this.fragment.rebind(next);\n      }\n    }\n  };\n\n  Section__proto__.rebound = function rebound (update) {\n    if (this.model) {\n      if (this.model.rebound) { this.model.rebound(update); }\n      else {\n        MustacheContainer.prototype.unbind.call(this);\n        MustacheContainer.prototype.bind.call(this);\n        if (\n          this.sectionType === SECTION_WITH ||\n          this.sectionType === SECTION_IF_WITH ||\n          this.sectionType === SECTION_EACH\n        ) {\n          if (this.fragment) { this.fragment.rebind(this.model); }\n        }\n\n        if (update) { this.bubble(); }\n      }\n    }\n    if (this.fragment) { this.fragment.rebound(update); }\n  };\n\n  Section__proto__.render = function render (target, occupants) {\n    this.rendered = true;\n    if (this.fragment) { this.fragment.render(target, occupants); }\n  };\n\n  Section__proto__.shuffle = function shuffle (newIndices) {\n    if (this.fragment && this.sectionType === SECTION_EACH) {\n      this.fragment.shuffle(newIndices);\n    }\n  };\n\n  Section__proto__.unbind = function unbind (view) {\n    MustacheContainer.prototype.unbind.call(this, view);\n    if (this.fragment) { this.fragment.unbind(view); }\n  };\n\n  Section__proto__.unrender = function unrender (shouldDestroy) {\n    if (this.rendered && this.fragment) { this.fragment.unrender(shouldDestroy); }\n    this.rendered = false;\n  };\n\n  Section__proto__.update = function update () {\n    var this$1 = this;\n\n    if (!this.dirty) { return; }\n\n    if (this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS) {\n      this.fragment.context = this.model;\n    }\n\n    if (!this.model && this.sectionType !== SECTION_UNLESS && !this.isAlias) { return; }\n\n    this.dirty = false;\n\n    var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n    var siblingFalsey = !this.subordinate || !this.sibling.isTruthy();\n    var lastType = this.sectionType;\n\n    if (this.yield && this.yield !== value) {\n      this.up = this.containerFragment;\n      this.container = null;\n      this.yield = null;\n      if (this.rendered) { this.fragment.unbind().unrender(true); }\n      this.fragment = null;\n    } else if (this.rendered && !this.yield && value instanceof Context) {\n      if (this.rendered && this.fragment) { this.fragment.unbind().unrender(true); }\n      this.fragment = null;\n    }\n\n    // watch for switching section types\n    if (this.sectionType === null || this.templateSectionType === null)\n      { this.sectionType = getType(value, this.template.i); }\n    if (lastType && lastType !== this.sectionType && this.fragment) {\n      if (this.rendered) {\n        this.fragment.unbind().unrender(true);\n      }\n\n      this.fragment = null;\n    }\n\n    var newFragment;\n\n    var fragmentShouldExist =\n      this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations\n      this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment\n      (siblingFalsey &&\n        (this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy())) || // if, unless, and if-with depend on siblings and the condition\n      this.isAlias;\n\n    if (fragmentShouldExist) {\n      if (!this.fragment) { this.fragment = this.detached; }\n\n      if (this.fragment) {\n        // check for detached fragment\n        if (this.detached) {\n          attach(this, this.fragment);\n          this.detached = false;\n          this.rendered = true;\n        }\n\n        if (!this.fragment.bound) { this.fragment.bind(this.model); }\n        this.fragment.update();\n      } else {\n        if (this.sectionType === SECTION_EACH) {\n          newFragment = new RepeatedFragment({\n            owner: this,\n            template: this.template.f,\n            indexRef: this.template.i\n          }).bind(this.model);\n        } else {\n          // only with and if-with provide context - if and unless do not\n          var context =\n            this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS\n              ? this.model\n              : null;\n\n          if (value instanceof Context) {\n            this.yield = value;\n            this.containerFragment = this.up;\n            this.up = value.fragment;\n            this.container = value.ractive;\n            context = undefined;\n          }\n\n          newFragment = new Fragment({\n            owner: this,\n            template: this.template.f\n          }).bind(context);\n        }\n      }\n    } else {\n      if (this.fragment && this.rendered) {\n        if (keep !== true) {\n          this.fragment.unbind().unrender(true);\n        } else {\n          this.unrender(false);\n          this.detached = this.fragment;\n          runloop.promise().then(function () {\n            if (this$1.detached) { this$1.detach(); }\n          });\n        }\n      } else if (this.fragment) {\n        this.fragment.unbind();\n      }\n\n      this.fragment = null;\n    }\n\n    if (newFragment) {\n      if (this.rendered) {\n        attach(this, newFragment);\n      }\n\n      this.fragment = newFragment;\n    }\n\n    if (this.nextSibling) {\n      this.nextSibling.dirty = true;\n      this.nextSibling.update();\n    }\n  };\n\n  return Section;\n}(MustacheContainer));\n\nfunction attach(section, fragment) {\n  var anchor = (section.containerFragment || section.up).findNextNode(section);\n\n  if (anchor) {\n    var docFrag = createDocumentFragment();\n    fragment.render(docFrag);\n\n    anchor.parentNode.insertBefore(docFrag, anchor);\n  } else {\n    fragment.render(section.up.findParentNode());\n  }\n}\n\nvar Select = (function (Element) {\n  function Select(options) {\n    Element.call(this, options);\n    this.options = [];\n  }\n\n  if ( Element ) Select.__proto__ = Element;\n  var Select__proto__ = Select.prototype = Object.create( Element && Element.prototype );\n  Select__proto__.constructor = Select;\n\n  Select__proto__.foundNode = function foundNode (node) {\n    if (this.binding) {\n      var selectedOptions = getSelectedOptions(node);\n\n      if (selectedOptions.length > 0) {\n        this.selectedOptions = selectedOptions;\n      }\n    }\n  };\n\n  Select__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n    this.sync();\n\n    var node = this.node;\n\n    var i = node.options.length;\n    while (i--) {\n      node.options[i].defaultSelected = node.options[i].selected;\n    }\n\n    this.rendered = true;\n  };\n\n  Select__proto__.sync = function sync () {\n    var this$1 = this;\n\n    var selectNode = this.node;\n\n    if (!selectNode) { return; }\n\n    var options = toArray(selectNode.options);\n\n    if (this.selectedOptions) {\n      options.forEach(function (o) {\n        if (this$1.selectedOptions.indexOf(o) >= 0) { o.selected = true; }\n        else { o.selected = false; }\n      });\n      this.binding.setFromNode(selectNode);\n      delete this.selectedOptions;\n      return;\n    }\n\n    var selectValue = this.getAttribute('value');\n    var isMultiple = this.getAttribute('multiple');\n    var array = isMultiple && isArray(selectValue);\n\n    // If the <select> has a specified value, that should override\n    // these options\n    if (selectValue !== undefined) {\n      var optionWasSelected;\n\n      options.forEach(function (o) {\n        var optionValue = o._ractive ? o._ractive.value : o.value;\n        var shouldSelect = isMultiple\n          ? array && this$1.valueContains(selectValue, optionValue)\n          : this$1.compare(selectValue, optionValue);\n\n        if (shouldSelect) {\n          optionWasSelected = true;\n        }\n\n        o.selected = shouldSelect;\n      });\n\n      if (!optionWasSelected && !isMultiple) {\n        if (this.binding) {\n          this.binding.forceUpdate();\n        }\n      }\n    } else if (this.binding && this.binding.forceUpdate) {\n      // Otherwise the value should be initialised according to which\n      // <option> element is selected, if twoway binding is in effect\n      this.binding.forceUpdate();\n    }\n  };\n  Select__proto__.valueContains = function valueContains (selectValue, optionValue) {\n    var this$1 = this;\n\n    var i = selectValue.length;\n    while (i--) {\n      if (this$1.compare(optionValue, selectValue[i])) { return true; }\n    }\n  };\n  Select__proto__.compare = function compare (optionValue, selectValue) {\n    var comparator = this.getAttribute('value-comparator');\n    if (comparator) {\n      if (isFunction(comparator)) {\n        return comparator(selectValue, optionValue);\n      }\n      if (selectValue && optionValue) {\n        return selectValue[comparator] == optionValue[comparator];\n      }\n    }\n    return selectValue == optionValue;\n  };\n  Select__proto__.update = function update () {\n    var dirty = this.dirty;\n    Element.prototype.update.call(this);\n    if (dirty) {\n      this.sync();\n    }\n  };\n\n  return Select;\n}(Element));\n\nvar Textarea = (function (Input) {\n  function Textarea(options) {\n    var template = options.template;\n\n    options.deferContent = true;\n\n    Input.call(this, options);\n\n    // check for single interpolator binding\n    if (!this.attributeByName.value) {\n      if (template.f && isBindable({ template: template })) {\n        (this.attributes || (this.attributes = [])).push(\n          createItem({\n            owner: this,\n            template: { t: ATTRIBUTE, f: template.f, n: 'value' },\n            up: this.up\n          })\n        );\n      } else {\n        this.fragment = new Fragment({\n          owner: this,\n          cssIds: null,\n          template: template.f\n        });\n      }\n    }\n  }\n\n  if ( Input ) Textarea.__proto__ = Input;\n  var Textarea__proto__ = Textarea.prototype = Object.create( Input && Input.prototype );\n  Textarea__proto__.constructor = Textarea;\n\n  Textarea__proto__.bubble = function bubble () {\n    var this$1 = this;\n\n    if (!this.dirty) {\n      this.dirty = true;\n\n      if (this.rendered && !this.binding && this.fragment) {\n        runloop.scheduleTask(function () {\n          this$1.dirty = false;\n          this$1.node.value = this$1.fragment.toString();\n        });\n      }\n\n      this.up.bubble(); // default behaviour\n    }\n  };\n\n  return Textarea;\n}(Input));\n\nvar Text = (function (Item) {\n  function Text(options) {\n    Item.call(this, options);\n    this.type = TEXT;\n  }\n\n  if ( Item ) Text.__proto__ = Item;\n  var Text__proto__ = Text.prototype = Object.create( Item && Item.prototype );\n  Text__proto__.constructor = Text;\n\n  Text__proto__.detach = function detach () {\n    return detachNode(this.node);\n  };\n\n  Text__proto__.firstNode = function firstNode () {\n    return this.node;\n  };\n\n  Text__proto__.render = function render (target, occupants) {\n    if (inAttributes()) { return; }\n    this.rendered = true;\n\n    progressiveText(this, target, occupants, this.template);\n  };\n\n  Text__proto__.toString = function toString (escape) {\n    return escape ? escapeHtml(this.template) : this.template;\n  };\n\n  Text__proto__.unrender = function unrender (shouldDestroy) {\n    if (this.rendered && shouldDestroy) { this.detach(); }\n    this.rendered = false;\n  };\n\n  Text__proto__.valueOf = function valueOf () {\n    return this.template;\n  };\n\n  return Text;\n}(Item));\n\nvar proto$7 = Text.prototype;\nproto$7.bind = proto$7.unbind = proto$7.update = noop;\n\nvar visible;\nvar hidden = 'hidden';\n\nif (doc) {\n  var prefix$2;\n\n  /* istanbul ignore next */\n  if (hidden in doc) {\n    prefix$2 = '';\n  } else {\n    var i$1 = vendors.length;\n    while (i$1--) {\n      var vendor = vendors[i$1];\n      hidden = vendor + 'Hidden';\n\n      if (hidden in doc) {\n        prefix$2 = vendor;\n        break;\n      }\n    }\n  }\n\n  /* istanbul ignore else */\n  if (prefix$2 !== undefined) {\n    doc.addEventListener(prefix$2 + 'visibilitychange', onChange);\n    onChange();\n  } else {\n    // gah, we're in an old browser\n    if ('onfocusout' in doc) {\n      doc.addEventListener('focusout', onHide);\n      doc.addEventListener('focusin', onShow);\n    } else {\n      win.addEventListener('pagehide', onHide);\n      win.addEventListener('blur', onHide);\n\n      win.addEventListener('pageshow', onShow);\n      win.addEventListener('focus', onShow);\n    }\n\n    visible = true; // until proven otherwise. Not ideal but hey\n  }\n}\n\nfunction onChange() {\n  visible = !doc[hidden];\n}\n\n/* istanbul ignore next */\nfunction onHide() {\n  visible = false;\n}\n\n/* istanbul ignore next */\nfunction onShow() {\n  visible = true;\n}\n\nvar prefix;\n\n/* istanbul ignore next */\nif (!isClient) {\n  prefix = null;\n} else {\n  var prefixCache = {};\n  var testStyle = createElement('div').style;\n\n  // technically this also normalizes on hyphenated styles as well\n  prefix = function(prop) {\n    if (!prefixCache[prop]) {\n      var name = hyphenateCamel(prop);\n\n      if (testStyle[prop] !== undefined) {\n        prefixCache[prop] = name;\n      } else {\n        /* istanbul ignore next */\n        // test vendors...\n        var i = vendors.length;\n        while (i--) {\n          var vendor = \"-\" + (vendors[i]) + \"-\" + name;\n          if (testStyle[vendor] !== undefined) {\n            prefixCache[prop] = vendor;\n            break;\n          }\n        }\n      }\n    }\n\n    return prefixCache[prop];\n  };\n}\n\nvar prefix$1 = prefix;\n\nvar vendorPattern = new RegExp('^(?:' + vendors.join('|') + ')([A-Z])');\n\nfunction hyphenate(str) {\n  /* istanbul ignore next */\n  if (!str) { return ''; } // edge case\n\n  /* istanbul ignore next */\n  if (vendorPattern.test(str)) { str = '-' + str; }\n\n  return str.replace(/[A-Z]/g, function (match) { return '-' + match.toLowerCase(); });\n}\n\nvar createTransitions;\n\nif (!isClient) {\n  createTransitions = null;\n} else {\n  var testStyle$1 = createElement('div').style;\n  var linear$1 = function (x) { return x; };\n\n  var canUseCssTransitions = {};\n  var cannotUseCssTransitions = {};\n\n  // determine some facts about our environment\n  var TRANSITION$1;\n  var TRANSITIONEND;\n  var CSS_TRANSITIONS_ENABLED;\n  var TRANSITION_DURATION;\n  var TRANSITION_PROPERTY;\n  var TRANSITION_TIMING_FUNCTION;\n\n  if (testStyle$1.transition !== undefined) {\n    TRANSITION$1 = 'transition';\n    TRANSITIONEND = 'transitionend';\n    CSS_TRANSITIONS_ENABLED = true;\n  } else if (testStyle$1.webkitTransition !== undefined) {\n    TRANSITION$1 = 'webkitTransition';\n    TRANSITIONEND = 'webkitTransitionEnd';\n    CSS_TRANSITIONS_ENABLED = true;\n  } else {\n    CSS_TRANSITIONS_ENABLED = false;\n  }\n\n  if (TRANSITION$1) {\n    TRANSITION_DURATION = TRANSITION$1 + 'Duration';\n    TRANSITION_PROPERTY = TRANSITION$1 + 'Property';\n    TRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';\n  }\n\n  createTransitions = function(t, to, options, changedProperties, resolve) {\n    // Wait a beat (otherwise the target styles will be applied immediately)\n    // TODO use a fastdom-style mechanism?\n    setTimeout(function () {\n      var jsTransitionsComplete;\n      var cssTransitionsComplete;\n      var cssTimeout; // eslint-disable-line prefer-const\n\n      function transitionDone() {\n        clearTimeout(cssTimeout);\n      }\n\n      function checkComplete() {\n        if (jsTransitionsComplete && cssTransitionsComplete) {\n          t.unregisterCompleteHandler(transitionDone);\n          // will changes to events and fire have an unexpected consequence here?\n          t.ractive.fire(t.name + ':end', t.node, t.isIntro);\n          resolve();\n        }\n      }\n\n      // this is used to keep track of which elements can use CSS to animate\n      // which properties\n      var hashPrefix = (t.node.namespaceURI || '') + t.node.tagName;\n\n      // need to reset transition properties\n      var style = t.node.style;\n      var previous = {\n        property: style[TRANSITION_PROPERTY],\n        timing: style[TRANSITION_TIMING_FUNCTION],\n        duration: style[TRANSITION_DURATION]\n      };\n\n      function transitionEndHandler(event) {\n        if (event.target !== t.node) { return; }\n        var index = changedProperties.indexOf(event.propertyName);\n\n        if (index !== -1) {\n          changedProperties.splice(index, 1);\n        }\n\n        if (changedProperties.length) {\n          // still transitioning...\n          return;\n        }\n\n        clearTimeout(cssTimeout);\n        cssTransitionsDone();\n      }\n\n      function cssTransitionsDone() {\n        style[TRANSITION_PROPERTY] = previous.property;\n        style[TRANSITION_TIMING_FUNCTION] = previous.duration;\n        style[TRANSITION_DURATION] = previous.timing;\n\n        t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n        cssTransitionsComplete = true;\n        checkComplete();\n      }\n\n      t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n      // safety net in case transitionend never fires\n      cssTimeout = setTimeout(function () {\n        changedProperties = [];\n        cssTransitionsDone();\n      }, options.duration + (options.delay || 0) + 50);\n      t.registerCompleteHandler(transitionDone);\n\n      style[TRANSITION_PROPERTY] = changedProperties.join(',');\n      var easingName = hyphenate(options.easing || 'linear');\n      style[TRANSITION_TIMING_FUNCTION] = easingName;\n      var cssTiming = style[TRANSITION_TIMING_FUNCTION] === easingName;\n      style[TRANSITION_DURATION] = options.duration / 1000 + 's';\n\n      setTimeout(function () {\n        var i = changedProperties.length;\n        var hash;\n        var originalValue = null;\n        var index;\n        var propertiesToTransitionInJs = [];\n        var prop;\n        var suffix;\n        var interpolator;\n\n        while (i--) {\n          prop = changedProperties[i];\n          hash = hashPrefix + prop;\n\n          if (cssTiming && CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {\n            var initial = style[prop];\n            style[prop] = to[prop];\n\n            // If we're not sure if CSS transitions are supported for\n            // this tag/property combo, find out now\n            if (!(hash in canUseCssTransitions)) {\n              originalValue = t.getStyle(prop);\n\n              // if this property is transitionable in this browser,\n              // the current style will be different from the target style\n              canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];\n              cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];\n\n              // Reset, if we're going to use timers after all\n              if (cannotUseCssTransitions[hash]) {\n                style[prop] = initial;\n              }\n            }\n          }\n\n          if (!cssTiming || !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {\n            // we need to fall back to timer-based stuff\n            if (originalValue === null) { originalValue = t.getStyle(prop); }\n\n            // need to remove this from changedProperties, otherwise transitionEndHandler\n            // will get confused\n            index = changedProperties.indexOf(prop);\n            if (index === -1) {\n              warnIfDebug(\n                'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!',\n                { node: t.node }\n              );\n            } else {\n              changedProperties.splice(index, 1);\n            }\n\n            // TODO Determine whether this property is animatable at all\n\n            suffix = /[^\\d]*$/.exec(originalValue)[0];\n            interpolator = interpolate(parseFloat(originalValue), parseFloat(to[prop]));\n\n            // ...then kick off a timer-based transition\n            if (interpolator) {\n              propertiesToTransitionInJs.push({\n                name: prop,\n                interpolator: interpolator,\n                suffix: suffix\n              });\n            } else {\n              style[prop] = to[prop];\n            }\n\n            originalValue = null;\n          }\n        }\n\n        // javascript transitions\n        if (propertiesToTransitionInJs.length) {\n          var easing;\n\n          if (isString(options.easing)) {\n            easing = t.ractive.easing[options.easing];\n\n            if (!easing) {\n              warnOnceIfDebug(missingPlugin(options.easing, 'easing'));\n              easing = linear$1;\n            }\n          } else if (isFunction(options.easing)) {\n            easing = options.easing;\n          } else {\n            easing = linear$1;\n          }\n\n          new Ticker({\n            duration: options.duration,\n            easing: easing,\n            step: function step(pos) {\n              var i = propertiesToTransitionInJs.length;\n              while (i--) {\n                var prop = propertiesToTransitionInJs[i];\n                style[prop.name] = prop.interpolator(pos) + prop.suffix;\n              }\n            },\n            complete: function complete() {\n              jsTransitionsComplete = true;\n              checkComplete();\n            }\n          });\n        } else {\n          jsTransitionsComplete = true;\n        }\n\n        if (changedProperties.length) {\n          style[TRANSITION_PROPERTY] = changedProperties.join(',');\n        } else {\n          style[TRANSITION_PROPERTY] = 'none';\n\n          // We need to cancel the transitionEndHandler, and deal with\n          // the fact that it will never fire\n          t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n          cssTransitionsComplete = true;\n          checkComplete();\n        }\n      }, 0);\n    }, options.delay || 0);\n  };\n}\n\nvar createTransitions$1 = createTransitions;\n\nvar getComputedStyle = win && win.getComputedStyle;\nvar resolved = Promise.resolve();\n\nvar names = {\n  t0: 'intro-outro',\n  t1: 'intro',\n  t2: 'outro'\n};\n\nvar Transition = function Transition(options) {\n  this.owner = options.owner || options.up.owner || findElement(options.up);\n  this.element = this.owner.attributeByName ? this.owner : findElement(options.up);\n  this.ractive = this.owner.ractive;\n  this.template = options.template;\n  this.up = options.up;\n  this.options = options;\n  this.onComplete = [];\n};\nvar Transition__proto__ = Transition.prototype;\n\nTransition__proto__.animateStyle = function animateStyle (style, value, options) {\n    var this$1 = this;\n\n  if (arguments.length === 4) {\n    throw new Error(\n      't.animateStyle() returns a promise - use .then() instead of passing a callback'\n    );\n  }\n\n  // Special case - page isn't visible. Don't animate anything, because\n  // that way you'll never get CSS transitionend events\n  if (!visible) {\n    this.setStyle(style, value);\n    return resolved;\n  }\n\n  var to;\n\n  if (isString(style)) {\n    to = {};\n    to[style] = value;\n  } else {\n    to = style;\n\n    // shuffle arguments\n    options = value;\n  }\n\n  return new Promise(function (fulfil) {\n    // Edge case - if duration is zero, set style synchronously and complete\n    if (!options.duration) {\n      this$1.setStyle(to);\n      fulfil();\n      return;\n    }\n\n    // Get a list of the properties we're animating\n    var propertyNames = keys(to);\n    var changedProperties = [];\n\n    // Store the current styles\n    var computedStyle = getComputedStyle(this$1.node);\n\n    var i = propertyNames.length;\n    while (i--) {\n      var prop = propertyNames[i];\n      var name = prefix$1(prop);\n\n      var current = computedStyle[prefix$1(prop)];\n\n      // record the starting points\n      var init = this$1.node.style[name];\n      if (!(name in this$1.originals)) { this$1.originals[name] = this$1.node.style[name]; }\n      this$1.node.style[name] = to[prop];\n      this$1.targets[name] = this$1.node.style[name];\n      this$1.node.style[name] = init;\n\n      // we need to know if we're actually changing anything\n      if (current != to[prop]) {\n        // use != instead of !==, so we can compare strings with numbers\n        changedProperties.push(name);\n\n        // if we happened to prefix, make sure there is a properly prefixed value\n        to[name] = to[prop];\n\n        // make the computed style explicit, so we can animate where\n        // e.g. height='auto'\n        this$1.node.style[name] = current;\n      }\n    }\n\n    // If we're not actually changing anything, the transitionend event\n    // will never fire! So we complete early\n    if (!changedProperties.length) {\n      fulfil();\n      return;\n    }\n\n    createTransitions$1(this$1, to, options, changedProperties, fulfil);\n  });\n};\n\nTransition__proto__.bind = function bind () {\n  var options = this.options;\n  var type = options.template && options.template.v;\n  if (type) {\n    if (type === 't0' || type === 't1') { this.element.intro = this; }\n    if (type === 't0' || type === 't2') { this.element.outro = this; }\n    this.eventName = names[type];\n  }\n\n  var ractive = this.owner.ractive;\n\n  this.name = options.name || options.template.n;\n\n  if (options.params) {\n    this.params = options.params;\n  }\n\n  if (isFunction(this.name)) {\n    this._fn = this.name;\n    this.name = this._fn.name;\n  } else {\n    this._fn = findInViewHierarchy('transitions', ractive, this.name);\n  }\n\n  if (!this._fn) {\n    warnOnceIfDebug(missingPlugin(this.name, 'transition'), { ractive: ractive });\n  }\n\n  setupArgsFn(this, options.template);\n};\n\nTransition__proto__.getParams = function getParams () {\n  if (this.params) { return this.params; }\n\n  // get expression args if supplied\n  if (this.fn) {\n    var values = resolveArgs(this, this.template, this.up).map(function (model) {\n      if (!model) { return undefined; }\n\n      return model.get();\n    });\n    return this.fn.apply(this.ractive, values);\n  }\n};\n\nTransition__proto__.getStyle = function getStyle (props) {\n  var computedStyle = getComputedStyle(this.node);\n\n  if (isString(props)) {\n    return computedStyle[prefix$1(props)];\n  }\n\n  if (!isArray(props)) {\n    throw new Error(\n      'Transition$getStyle must be passed a string, or an array of strings representing CSS properties'\n    );\n  }\n\n  var styles = {};\n\n  var i = props.length;\n  while (i--) {\n    var prop = props[i];\n    var value = computedStyle[prefix$1(prop)];\n\n    if (value === '0px') { value = 0; }\n    styles[prop] = value;\n  }\n\n  return styles;\n};\n\nTransition__proto__.processParams = function processParams (params, defaults) {\n  if (isNumber(params)) {\n    params = { duration: params };\n  } else if (isString(params)) {\n    if (params === 'slow') {\n      params = { duration: 600 };\n    } else if (params === 'fast') {\n      params = { duration: 200 };\n    } else {\n      params = { duration: 400 };\n    }\n  } else if (!params) {\n    params = {};\n  }\n\n  return assign({}, defaults, params);\n};\n\nTransition__proto__.registerCompleteHandler = function registerCompleteHandler (fn) {\n  addToArray(this.onComplete, fn);\n};\n\nTransition__proto__.setStyle = function setStyle (style, value) {\n    var this$1 = this;\n\n  if (isString(style)) {\n    var name = prefix$1(style);\n    if (!hasOwn(this.originals, name)) { this.originals[name] = this.node.style[name]; }\n    this.node.style[name] = value;\n    this.targets[name] = this.node.style[name];\n  } else {\n    var prop;\n    for (prop in style) {\n      if (hasOwn(style, prop)) {\n        this$1.setStyle(prop, style[prop]);\n      }\n    }\n  }\n\n  return this;\n};\n\nTransition__proto__.shouldFire = function shouldFire (type) {\n  if (!this.ractive.transitionsEnabled) { return false; }\n\n  // check for noIntro and noOutro cases, which only apply when the owner ractive is rendering and unrendering, respectively\n  if (type === 'intro' && this.ractive.rendering && nearestProp('noIntro', this.ractive, true))\n    { return false; }\n  if (type === 'outro' && this.ractive.unrendering && nearestProp('noOutro', this.ractive, false))\n    { return false; }\n\n  var params = this.getParams(); // this is an array, the params object should be the first member\n  // if there's not a parent element, this can't be nested, so roll on\n  if (!this.element.parent) { return true; }\n\n  // if there is a local param, it takes precedent\n  if (params && params[0] && isObject(params[0]) && 'nested' in params[0]) {\n    if (params[0].nested !== false) { return true; }\n  } else {\n    // use the nearest instance setting\n    // find the nearest instance that actually has a nested setting\n    if (nearestProp('nestedTransitions', this.ractive) !== false) { return true; }\n  }\n\n  // check to see if this is actually a nested transition\n  var el = this.element.parent;\n  while (el) {\n    if (el[type] && el[type].starting) { return false; }\n    el = el.parent;\n  }\n\n  return true;\n};\n\nTransition__proto__.start = function start () {\n    var this$1 = this;\n\n  var node = (this.node = this.element.node);\n  var originals = (this.originals = {}); //= node.getAttribute( 'style' );\n  var targets = (this.targets = {});\n\n  var completed;\n  var args = this.getParams();\n\n  // create t.complete() - we don't want this on the prototype,\n  // because we don't want `this` silliness when passing it as\n  // an argument\n  this.complete = function (noReset) {\n    this$1.starting = false;\n    if (completed) {\n      return;\n    }\n\n    this$1.onComplete.forEach(function (fn) { return fn(); });\n    if (!noReset && this$1.isIntro) {\n      for (var k in targets) {\n        if (node.style[k] === targets[k]) { node.style[k] = originals[k]; }\n      }\n    }\n\n    this$1._manager.remove(this$1);\n\n    completed = true;\n  };\n\n  // If the transition function doesn't exist, abort\n  if (!this._fn) {\n    this.complete();\n    return;\n  }\n\n  var promise = this._fn.apply(this.ractive, [this].concat(args));\n  if (promise) { promise.then(this.complete); }\n};\n\nTransition__proto__.toString = function toString () {\n  return '';\n};\n\nTransition__proto__.unbind = function unbind () {\n  if (!this.element.attributes || !this.element.attributes.unbinding) {\n    var type = this.options && this.options.template && this.options.template.v;\n    if (type === 't0' || type === 't1') { this.element.intro = null; }\n    if (type === 't0' || type === 't2') { this.element.outro = null; }\n  }\n};\n\nTransition__proto__.unregisterCompleteHandler = function unregisterCompleteHandler (fn) {\n  removeFromArray(this.onComplete, fn);\n};\n\nvar proto$8 = Transition.prototype;\nproto$8.destroyed = proto$8.firstNode = proto$8.rebound = proto$8.render = proto$8.unrender = proto$8.update = noop;\n\nfunction nearestProp(prop, ractive, rendering) {\n  var instance = ractive;\n  while (instance) {\n    if (\n      hasOwn(instance, prop) &&\n      (isUndefined(rendering) || rendering ? instance.rendering : instance.unrendering)\n    )\n      { return instance[prop]; }\n    instance = instance.component && instance.component.ractive;\n  }\n\n  return ractive[prop];\n}\n\nvar elementCache = {};\n\nvar ieBug;\nvar ieBlacklist;\n\ntry {\n  createElement('table').innerHTML = 'foo';\n} catch (/* istanbul ignore next */ err) {\n  ieBug = true;\n\n  ieBlacklist = {\n    TABLE: ['<table class=\"x\">', '</table>'],\n    THEAD: ['<table><thead class=\"x\">', '</thead></table>'],\n    TBODY: ['<table><tbody class=\"x\">', '</tbody></table>'],\n    TR: ['<table><tr class=\"x\">', '</tr></table>'],\n    SELECT: ['<select class=\"x\">', '</select>']\n  };\n}\n\nfunction insertHtml(html$$1, node) {\n  var nodes = [];\n\n  // render 0 and false\n  if (html$$1 == null || html$$1 === '') { return nodes; }\n\n  var container;\n  var wrapper;\n  var selectedOption;\n\n  /* istanbul ignore if */\n  if (ieBug && (wrapper = ieBlacklist[node.tagName])) {\n    container = element('DIV');\n    container.innerHTML = wrapper[0] + html$$1 + wrapper[1];\n    container = container.querySelector('.x');\n\n    if (container.tagName === 'SELECT') {\n      selectedOption = container.options[container.selectedIndex];\n    }\n  } else if (node.namespaceURI === svg$1) {\n    container = element('DIV');\n    container.innerHTML = '<svg class=\"x\">' + html$$1 + '</svg>';\n    container = container.querySelector('.x');\n  } else if (node.tagName === 'TEXTAREA') {\n    container = createElement('div');\n\n    if (typeof container.textContent !== 'undefined') {\n      container.textContent = html$$1;\n    } else {\n      container.innerHTML = html$$1;\n    }\n  } else {\n    container = element(node.tagName);\n    container.innerHTML = html$$1;\n\n    if (container.tagName === 'SELECT') {\n      selectedOption = container.options[container.selectedIndex];\n    }\n  }\n\n  var child;\n  while ((child = container.firstChild)) {\n    nodes.push(child);\n    container.removeChild(child);\n  }\n\n  // This is really annoying. Extracting <option> nodes from the\n  // temporary container <select> causes the remaining ones to\n  // become selected. So now we have to deselect them. IE8, you\n  // amaze me. You really do\n  // ...and now Chrome too\n  var i;\n  if (node.tagName === 'SELECT') {\n    i = nodes.length;\n    while (i--) {\n      if (nodes[i] !== selectedOption) {\n        nodes[i].selected = false;\n      }\n    }\n  }\n\n  return nodes;\n}\n\nfunction element(tagName) {\n  return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));\n}\n\nvar Triple = (function (Mustache) {\n  function Triple(options) {\n    Mustache.call(this, options);\n  }\n\n  if ( Mustache ) Triple.__proto__ = Mustache;\n  var Triple__proto__ = Triple.prototype = Object.create( Mustache && Mustache.prototype );\n  Triple__proto__.constructor = Triple;\n\n  Triple__proto__.detach = function detach () {\n    var docFrag = createDocumentFragment();\n    if (this.nodes) { this.nodes.forEach(function (node) { return docFrag.appendChild(node); }); }\n    return docFrag;\n  };\n\n  Triple__proto__.find = function find (selector) {\n    var this$1 = this;\n\n    var len = this.nodes.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      var node = this$1.nodes[i];\n\n      if (node.nodeType !== 1) { continue; }\n\n      if (matches(node, selector)) { return node; }\n\n      var queryResult = node.querySelector(selector);\n      if (queryResult) { return queryResult; }\n    }\n\n    return null;\n  };\n\n  Triple__proto__.findAll = function findAll (selector, options) {\n    var this$1 = this;\n\n    var result = options.result;\n    var len = this.nodes.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      var node = this$1.nodes[i];\n\n      if (node.nodeType !== 1) { continue; }\n\n      if (matches(node, selector)) { result.push(node); }\n\n      var queryAllResult = node.querySelectorAll(selector);\n      if (queryAllResult) {\n        result.push.apply(result, queryAllResult);\n      }\n    }\n  };\n\n  Triple__proto__.findComponent = function findComponent () {\n    return null;\n  };\n\n  Triple__proto__.firstNode = function firstNode () {\n    return this.rendered && this.nodes[0];\n  };\n\n  Triple__proto__.render = function render (target, occupants, anchor) {\n    var this$1 = this;\n\n    if (!this.nodes) {\n      var html = this.model ? this.model.get() : '';\n      this.nodes = insertHtml(html, target);\n    }\n\n    var nodes = this.nodes;\n\n    // progressive enhancement\n    if (occupants) {\n      var i = -1;\n      var next;\n\n      // start with the first node that should be rendered\n      while (occupants.length && (next = this.nodes[i + 1])) {\n        var n = (void 0);\n        // look through the occupants until a matching node is found\n        while ((n = occupants.shift())) {\n          var t = n.nodeType;\n\n          if (\n            t === next.nodeType &&\n            ((t === 1 && n.outerHTML === next.outerHTML) ||\n              ((t === 3 || t === 8) && n.nodeValue === next.nodeValue))\n          ) {\n            this$1.nodes.splice(++i, 1, n); // replace the generated node with the existing one\n            break;\n          } else {\n            target.removeChild(n); // remove the non-matching existing node\n          }\n        }\n      }\n\n      if (i >= 0) {\n        // update the list of remaining nodes to attach, excluding any that were replaced by existing nodes\n        nodes = this.nodes.slice(i);\n      }\n\n      // update the anchor to be the next occupant\n      if (occupants.length) { anchor = occupants[0]; }\n    }\n\n    // attach any remainging nodes to the parent\n    if (nodes.length) {\n      var frag = createDocumentFragment();\n      nodes.forEach(function (n) { return frag.appendChild(n); });\n\n      if (anchor) {\n        target.insertBefore(frag, anchor);\n      } else {\n        target.appendChild(frag);\n      }\n    }\n\n    this.rendered = true;\n  };\n\n  Triple__proto__.toString = function toString () {\n    var value = this.model && this.model.get();\n    value = value != null ? '' + value : '';\n\n    return inAttribute() ? decodeCharacterReferences(value) : value;\n  };\n\n  Triple__proto__.unrender = function unrender () {\n    if (this.nodes)\n      { this.nodes.forEach(function (node) {\n        // defer detachment until all relevant outros are done\n        runloop.detachWhenReady({\n          node: node,\n          detach: function detach() {\n            detachNode(node);\n          }\n        });\n      }); }\n    this.rendered = false;\n    this.nodes = null;\n  };\n\n  Triple__proto__.update = function update () {\n    if (this.rendered && this.dirty) {\n      this.dirty = false;\n\n      this.unrender();\n      this.render(this.up.findParentNode(), null, this.up.findNextNode(this));\n    } else {\n      // make sure to reset the dirty flag even if not rendered\n      this.dirty = false;\n    }\n  };\n\n  return Triple;\n}(Mustache));\n\n// finds the component constructor in the registry or view hierarchy registries\nfunction getComponentConstructor(ractive, name) {\n  var instance = findInstance('components', ractive, name);\n  var Component;\n\n  if (instance) {\n    Component = instance.components[name];\n\n    if (Component && !Component.isInstance) {\n      if (Component.default && Component.default.isInstance) { Component = Component.default; }\n      else if (!Component.then && isFunction(Component)) {\n        // function option, execute and store for reset\n        var fn = Component.bind(instance);\n        fn.isOwner = hasOwn(instance.components, name);\n        Component = fn();\n\n        if (!Component) {\n          warnIfDebug(noRegistryFunctionReturn, name, 'component', 'component', {\n            ractive: ractive\n          });\n          return;\n        }\n\n        if (isString(Component)) {\n          // allow string lookup\n          Component = getComponentConstructor(ractive, Component);\n        }\n\n        Component._fn = fn;\n        instance.components[name] = Component;\n      }\n    }\n  }\n\n  return Component;\n}\n\nfunction asyncProxy(promise, options) {\n  var partials = options.template.p || {};\n  var name = options.template.e;\n\n  var opts = assign({}, options, {\n    template: { t: ELEMENT, e: name },\n    macro: function macro(handle) {\n      handle.setTemplate(partials['async-loading'] || []);\n      promise.then(\n        function (cmp) {\n          options.up.ractive.components[name] = cmp;\n          if (partials['async-loaded']) {\n            handle.partials.component = [options.template];\n            handle.setTemplate(partials['async-loaded']);\n          } else {\n            handle.setTemplate([options.template]);\n          }\n        },\n        function (err) {\n          if (partials['async-failed']) {\n            handle.aliasLocal('error', 'error');\n            handle.set('@local.error', err);\n            handle.setTemplate(partials['async-failed']);\n          } else {\n            handle.setTemplate([]);\n          }\n        }\n      );\n    }\n  });\n  return new Partial(opts);\n}\n\nfunction extract(tpl, type, name) {\n  var p = tpl.f.find(function (s) { return s.t === type; });\n  if (p) {\n    if (p.n)\n      { return [\n        {\n          t: 19,\n          n: 54,\n          f: p.f || [],\n          z: [{ n: p.n, x: { r: (\"__await.\" + name) } }]\n        }\n      ]; }\n    else { return p.f || []; }\n  } else { return []; }\n}\n\nfunction Await(options) {\n  var tpl = options.template;\n\n  var success = extract(tpl, THEN, 'value');\n  var error = extract(tpl, CATCH, 'error');\n  var pending = extract(tpl, SECTION);\n  var undef = extract(tpl, ELSE);\n\n  var opts = assign({}, options, {\n    template: {\n      t: ELEMENT,\n      m: [\n        {\n          t: ATTRIBUTE,\n          n: 'for',\n          f: [{ t: INTERPOLATOR, r: tpl.r, rx: tpl.rx, x: tpl.x }]\n        }\n      ]\n    },\n    macro: function macro(handle, attrs) {\n      handle.aliasLocal('__await');\n\n      function update(attrs) {\n        if (attrs.for && isFunction(attrs.for.then)) {\n          handle.setTemplate(pending);\n\n          attrs.for.then(\n            function (v) {\n              handle.set('@local.value', v);\n              handle.setTemplate(success);\n            },\n            function (e) {\n              handle.set('@local.error', e);\n              handle.setTemplate(error);\n            }\n          );\n        } else if (isUndefined(attrs.for)) {\n          handle.setTemplate(undef);\n        } else {\n          handle.set('@local.value', attrs.for);\n          handle.setTemplate(success);\n        }\n      }\n\n      update(attrs);\n\n      return {\n        update: update\n      };\n    }\n  });\n\n  opts.macro.attributes = ['for'];\n\n  return new Partial(opts);\n}\n\nvar constructors = {};\nconstructors[ALIAS] = Section;\nconstructors[ANCHOR] = Component;\nconstructors[AWAIT] = Await;\nconstructors[DOCTYPE] = Doctype;\nconstructors[INTERPOLATOR] = Interpolator;\nconstructors[PARTIAL] = Partial;\nconstructors[SECTION] = Section;\nconstructors[TRIPLE] = Triple;\nconstructors[YIELDER] = Partial;\n\nconstructors[ATTRIBUTE] = Attribute;\nconstructors[BINDING_FLAG] = BindingFlag;\nconstructors[DECORATOR] = Decorator;\nconstructors[EVENT] = EventDirective;\nconstructors[TRANSITION] = Transition;\nconstructors[COMMENT] = Comment;\n\nvar specialElements = {\n  doctype: Doctype,\n  form: Form,\n  input: Input,\n  option: Option,\n  select: Select,\n  textarea: Textarea\n};\n\nfunction createItem(options) {\n  if (isString(options.template)) {\n    return new Text(options);\n  }\n\n  var ctor;\n  var name;\n  var type = options.template.t;\n\n  if (type === ELEMENT) {\n    name = options.template.e;\n\n    // could be a macro partial\n    ctor = findInstance('partials', options.up.ractive, name);\n    if (ctor) {\n      ctor = ctor.partials[name];\n      if (ctor.styleSet) {\n        options.macro = ctor;\n        return new Partial(options);\n      }\n    }\n\n    // could be component or element\n    ctor = getComponentConstructor(options.up.ractive, name);\n    if (ctor) {\n      if (isFunction(ctor.then)) {\n        return asyncProxy(ctor, options);\n      } else if (isFunction(ctor)) {\n        return new Component(options, ctor);\n      }\n    }\n\n    ctor = specialElements[name.toLowerCase()] || Element;\n    return new ctor(options);\n  }\n\n  var Item;\n\n  // component mappings are a special case of attribute\n  if (type === ATTRIBUTE) {\n    var el = options.owner;\n    if (!el || (el.type !== ANCHOR && el.type !== COMPONENT && el.type !== ELEMENT)) {\n      el = findElement(options.up);\n    }\n    options.element = el;\n\n    Item = el.type === COMPONENT || el.type === ANCHOR ? Mapping : Attribute;\n  } else {\n    Item = constructors[type];\n  }\n\n  if (!Item) { throw new Error((\"Unrecognised item type \" + type)); }\n\n  return new Item(options);\n}\n\n// TODO all this code needs to die\nfunction processItems(items, values, guid, counter) {\n  if ( counter === void 0 ) counter = 0;\n\n  return items\n    .map(function (item) {\n      if (item.type === TEXT) {\n        return item.template;\n      }\n\n      if (item.fragment) {\n        if (item.fragment.iterations) {\n          return item.fragment.iterations\n            .map(function (fragment) {\n              return processItems(fragment.items, values, guid, counter);\n            })\n            .join('');\n        } else {\n          return processItems(item.fragment.items, values, guid, counter);\n        }\n      }\n\n      var placeholderId = guid + \"-\" + (counter++);\n      var model = item.model || item.newModel;\n\n      values[placeholderId] = model\n        ? model.wrapper\n          ? model.wrapperValue\n          : model.get()\n        : undefined;\n\n      return '${' + placeholderId + '}';\n    })\n    .join('');\n}\n\nfunction resolveAliases(aliases, fragment, dest) {\n  if ( dest === void 0 ) dest = {};\n\n  for (var i = 0; i < aliases.length; i++) {\n    if (!dest[aliases[i].n]) {\n      var m = resolve(fragment, aliases[i].x);\n      dest[aliases[i].n] = m;\n      m.reference();\n    }\n  }\n\n  return dest;\n}\n\nvar Fragment = function Fragment(options) {\n  this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\n  this.isRoot = !options.owner.up;\n  this.parent = this.isRoot ? null : this.owner.up;\n  this.ractive = options.ractive || (this.isRoot ? options.owner : this.parent.ractive);\n\n  this.componentParent =\n    this.isRoot && this.ractive.component\n      ? this.ractive.component.up\n      : this.owner.containerFragment || null;\n  if (!this.isRoot || this.ractive.delegate) {\n    this.delegate = this.owner.containerFragment\n      ? this.owner.containerFragment && this.owner.containerFragment.delegate\n      : (this.componentParent && this.componentParent.delegate) ||\n        (this.parent && this.parent.delegate);\n  } else {\n    this.delegate = false;\n  }\n\n  this.context = null;\n  this.rendered = false;\n\n  // encapsulated styles should be inherited until they get applied by an element\n  if ('cssIds' in options) {\n    this.cssIds = options.cssIds && options.cssIds.length && options.cssIds;\n  } else {\n    this.cssIds = this.parent ? this.parent.cssIds : null;\n  }\n\n  this.dirty = false;\n  this.dirtyValue = true; // used for attribute values\n\n  this.template = options.template || [];\n  this.createItems();\n};\nvar Fragment__proto__ = Fragment.prototype;\n\nFragment__proto__.bind = function bind (context) {\n    var this$1 = this;\n\n  this.context = context;\n\n  if (this.owner.template.z) {\n    this.aliases = resolveAliases(\n      this.owner.template.z,\n      this.owner.containerFragment || this.parent\n    );\n  }\n\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].bind(); }\n  this.bound = true;\n\n  // in rare cases, a forced resolution (or similar) will cause the\n  // fragment to be dirty before it's even finished binding. In those\n  // cases we update immediately\n  if (this.dirty) { this.update(); }\n\n  return this;\n};\n\nFragment__proto__.bubble = function bubble () {\n  this.dirtyValue = true;\n\n  if (!this.dirty) {\n    this.dirty = true;\n\n    if (this.isRoot) {\n      // TODO encapsulate 'is component root, but not overall root' check?\n      if (this.ractive.component) {\n        this.ractive.component.bubble();\n      } else if (this.bound) {\n        runloop.addFragment(this);\n      }\n    } else {\n      this.owner.bubble(this.index);\n    }\n  }\n};\n\nFragment__proto__.createItems = function createItems () {\n    var this$1 = this;\n\n  // this is a hot code path\n  var max = this.template.length;\n  this.items = [];\n  for (var i = 0; i < max; i++) {\n    this$1.items[i] = createItem({\n      up: this$1,\n      template: this$1.template[i],\n      index: i\n    });\n  }\n};\n\nFragment__proto__.destroyed = function destroyed () {\n    var this$1 = this;\n\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].destroyed(); }\n  if (this.pathModel) { this.pathModel.destroyed(); }\n  if (this.rootModel) { this.rootModel.destroyed(); }\n};\n\nFragment__proto__.detach = function detach () {\n  var docFrag = createDocumentFragment();\n  var xs = this.items;\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    docFrag.appendChild(xs[i].detach());\n  }\n  return docFrag;\n};\n\nFragment__proto__.find = function find (selector, options) {\n  return findMap(this.items, function (i) { return i.find(selector, options); });\n};\n\nFragment__proto__.findAll = function findAll (selector, options) {\n  if (this.items) {\n    this.items.forEach(function (i) { return i.findAll && i.findAll(selector, options); });\n  }\n};\n\nFragment__proto__.findComponent = function findComponent (name, options) {\n  return findMap(this.items, function (i) { return i.findComponent(name, options); });\n};\n\nFragment__proto__.findAllComponents = function findAllComponents (name, options) {\n  if (this.items) {\n    this.items.forEach(function (i) { return i.findAllComponents && i.findAllComponents(name, options); });\n  }\n};\n\nFragment__proto__.findContext = function findContext () {\n  var base = findParentWithContext(this);\n  if (!base || !base.context) { return this.ractive.viewmodel; }\n  else { return base.context; }\n};\n\nFragment__proto__.findNextNode = function findNextNode (item) {\n    var this$1 = this;\n\n  // search for the next node going forward\n  if (item) {\n    var it;\n    for (var i = item.index + 1; i < this.items.length; i++) {\n      it = this$1.items[i];\n      if (!it || !it.firstNode) { continue; }\n\n      var node = it.firstNode(true);\n      if (node) { return node; }\n    }\n  }\n\n  // if this is the root fragment, and there are no more items,\n  // it means we're at the end...\n  if (this.isRoot) {\n    if (this.ractive.component) {\n      return this.ractive.component.up.findNextNode(this.ractive.component);\n    }\n\n    // TODO possible edge case with other content\n    // appended to this.ractive.el?\n    return null;\n  }\n\n  if (this.parent) { return this.owner.findNextNode(this); } // the argument is in case the parent is a RepeatedFragment\n};\n\nFragment__proto__.findParentNode = function findParentNode () {\n  var fragment = this;\n\n  do {\n    if (fragment.owner.type === ELEMENT) {\n      return fragment.owner.node;\n    }\n\n    if (fragment.isRoot && !fragment.ractive.component) {\n      // TODO encapsulate check\n      return fragment.ractive.el;\n    }\n\n    if (fragment.owner.type === YIELDER) {\n      fragment = fragment.owner.containerFragment;\n    } else {\n      fragment = fragment.componentParent || fragment.parent; // TODO ugh\n    }\n  } while (fragment);\n\n  throw new Error('Could not find parent node'); // TODO link to issue tracker\n};\n\nFragment__proto__.firstNode = function firstNode (skipParent) {\n  var node = findMap(this.items, function (i) { return i.firstNode(true); });\n  if (node) { return node; }\n  if (skipParent) { return null; }\n\n  return this.parent.findNextNode(this.owner);\n};\n\nFragment__proto__.getKey = function getKey () {\n  return this.keyModel || (this.keyModel = new KeyModel(this.key));\n};\n\nFragment__proto__.getIndex = function getIndex () {\n  return this.idxModel || (this.idxModel = new KeyModel(this.index));\n};\n\nFragment__proto__.rebind = function rebind (next) {\n  this.context = next;\n  if (this.rootModel) { this.rootModel.context = this.context; }\n  if (this.pathModel) { this.pathModel.context = this.context; }\n};\n\nFragment__proto__.rebound = function rebound (update$$1) {\n  if (this.owner.template.z) {\n    var aliases = this.aliases;\n    for (var k in aliases) {\n      if (aliases[k].rebound) { aliases[k].rebound(update$$1); }\n      else {\n        aliases[k].unreference();\n        aliases[k] = 0;\n      }\n    }\n\n    resolveAliases(this.owner.template.z, this.owner.containerFragment || this.parent, aliases);\n  }\n\n  this.items.forEach(function (x) { return x.rebound(update$$1); });\n  if (update$$1) {\n    if (this.rootModel) { this.rootModel.applyValue(this.context.getKeypath(this.ractive.root)); }\n    if (this.pathModel) { this.pathModel.applyValue(this.context.getKeypath()); }\n  }\n};\n\nFragment__proto__.render = function render (target, occupants) {\n  if (this.rendered) { throw new Error('Fragment is already rendered!'); }\n  this.rendered = true;\n\n  var xs = this.items;\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    xs[i].render(target, occupants);\n  }\n};\n\nFragment__proto__.resetTemplate = function resetTemplate (template) {\n  var wasBound = this.bound;\n  var wasRendered = this.rendered;\n\n  // TODO ensure transitions are disabled globally during reset\n\n  if (wasBound) {\n    if (wasRendered) { this.unrender(true); }\n    this.unbind();\n  }\n\n  this.template = template;\n  this.createItems();\n\n  if (wasBound) {\n    this.bind(this.context);\n\n    if (wasRendered) {\n      var parentNode = this.findParentNode();\n      var anchor = this.findNextNode();\n\n      if (anchor) {\n        var docFrag = createDocumentFragment();\n        this.render(docFrag);\n        parentNode.insertBefore(docFrag, anchor);\n      } else {\n        this.render(parentNode);\n      }\n    }\n  }\n};\n\nFragment__proto__.shuffled = function shuffled$3 () {\n  this.items.forEach(shuffled);\n  if (this.rootModel) { this.rootModel.applyValue(this.context.getKeypath(this.ractive.root)); }\n  if (this.pathModel) { this.pathModel.applyValue(this.context.getKeypath()); }\n};\n\nFragment__proto__.toString = function toString (escape) {\n  return this.items.map(escape ? toEscapedString : toString$1).join('');\n};\n\nFragment__proto__.unbind = function unbind (view) {\n    var this$1 = this;\n\n  if (this.owner.template.z && !this.owner.yielder) {\n    for (var k in this$1.aliases) {\n      this$1.aliases[k].unreference();\n    }\n\n    this.aliases = {};\n  }\n\n  this.context = null;\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].unbind(view); }\n  this.bound = false;\n\n  return this;\n};\n\nFragment__proto__.unrender = function unrender (shouldDestroy) {\n    var this$1 = this;\n\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].unrender(shouldDestroy); }\n  this.rendered = false;\n};\n\nFragment__proto__.update = function update () {\n    var this$1 = this;\n\n  if (this.dirty) {\n    if (!this.updating) {\n      this.dirty = false;\n      this.updating = true;\n      var len = this.items.length;\n      for (var i = 0; i < len; i++) { this$1.items[i].update(); }\n      this.updating = false;\n    } else if (this.isRoot) {\n      runloop.addFragmentToRoot(this);\n    }\n  }\n};\n\nFragment__proto__.valueOf = function valueOf () {\n  if (this.items.length === 1) {\n    return this.items[0].valueOf();\n  }\n\n  if (this.dirtyValue) {\n    var values = {};\n    var source = processItems(this.items, values, this.ractive._guid);\n    var parsed = parseJSON(source, values);\n\n    this.value = parsed ? parsed.value : this.toString();\n\n    this.dirtyValue = false;\n  }\n\n  return this.value;\n};\nFragment.prototype.getContext = getContext;\nFragment.prototype.getKeypath = getKeypath;\n\nfunction getKeypath(root) {\n  var base = findParentWithContext(this);\n  var model;\n  if (root) {\n    if (!this.rootModel) {\n      this.rootModel = new KeyModel(\n        this.context.getKeypath(this.ractive.root),\n        this.context,\n        this.ractive.root\n      );\n      model = this.rootModel;\n    } else { return this.rootModel; }\n  } else {\n    if (!this.pathModel) {\n      this.pathModel = new KeyModel(this.context.getKeypath(), this.context);\n      model = this.pathModel;\n    } else { return this.pathModel; }\n  }\n\n  if (base && base.context) { base.getKeypath(root).registerChild(model); }\n\n  return model;\n}\n\nfunction initialise(ractive, userOptions, options) {\n  // initialize settable computeds\n  var computed = ractive.viewmodel.computed;\n  if (computed) {\n    for (var k in computed) {\n      if (k in ractive.viewmodel.value && computed[k] && !computed[k].isReadonly) {\n        computed[k].set(ractive.viewmodel.value[k]);\n      }\n    }\n  }\n\n  // init config from Parent and options\n  config.init(ractive.constructor, ractive, userOptions);\n\n  // call any passed in plugins\n  if (isArray(userOptions.use))\n    { ractive.use.apply(ractive, userOptions.use.filter(function (p) { return !p.construct; })); }\n\n  hooks.config.fire(ractive);\n\n  hooks.init.begin(ractive);\n\n  var fragment = (ractive.fragment = createFragment$1(ractive, options));\n  if (fragment) { fragment.bind(ractive.viewmodel); }\n\n  hooks.init.end(ractive);\n\n  // general config done, set up observers\n  subscribe(ractive, userOptions, 'observe');\n\n  if (fragment) {\n    // render automatically ( if `el` is specified )\n    var el = (ractive.el = ractive.target = getElement(ractive.el || ractive.target));\n    if (el && !ractive.component) {\n      var promise = ractive.render(el, ractive.append);\n\n      if (Ractive.DEBUG_PROMISES) {\n        promise.catch(function (err) {\n          warnOnceIfDebug(\n            'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;'\n          );\n          warnIfDebug('An error happened during rendering', { ractive: ractive });\n          logIfDebug(err);\n\n          throw err;\n        });\n      }\n    }\n  }\n}\n\nfunction createFragment$1(ractive, options) {\n  if ( options === void 0 ) options = {};\n\n  if (ractive.template) {\n    var cssIds = [].concat(ractive.constructor._cssIds || [], options.cssIds || []);\n\n    return new Fragment({\n      owner: ractive,\n      template: ractive.template,\n      cssIds: cssIds\n    });\n  }\n}\n\nfunction render$1(ractive, target, anchor, occupants) {\n  // set a flag to let any transitions know that this instance is currently rendering\n  ractive.rendering = true;\n\n  var promise = runloop.start();\n  runloop.scheduleTask(function () { return hooks.render.fire(ractive); }, true);\n\n  if (ractive.fragment.rendered) {\n    throw new Error(\n      'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first'\n    );\n  }\n\n  if (ractive.destroyed) {\n    ractive.destroyed = false;\n    ractive.fragment = createFragment$1(ractive).bind(ractive.viewmodel);\n  }\n\n  anchor = getElement(anchor) || ractive.anchor;\n\n  ractive.el = ractive.target = target;\n  ractive.anchor = anchor;\n\n  // ensure encapsulated CSS is up-to-date\n  if (ractive.cssId) { applyCSS(); }\n\n  if (target) {\n    (target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(ractive);\n\n    if (anchor) {\n      var docFrag = doc.createDocumentFragment();\n      ractive.fragment.render(docFrag);\n      target.insertBefore(docFrag, anchor);\n    } else {\n      ractive.fragment.render(target, occupants);\n    }\n  }\n\n  runloop.end();\n  ractive.rendering = false;\n\n  return promise.then(function () {\n    if (ractive.torndown) { return; }\n\n    hooks.complete.fire(ractive);\n  });\n}\n\nfunction Ractive$render(target, anchor) {\n  if (this.torndown) {\n    warnIfDebug('ractive.render() was called on a Ractive instance that was already torn down');\n    return Promise.resolve();\n  }\n\n  target = getElement(target) || this.el;\n\n  if (!this.append && target) {\n    // Teardown any existing instances *before* trying to set up the new one -\n    // avoids certain weird bugs\n    var others = target.__ractive_instances__;\n    if (others) { others.forEach(teardown); }\n\n    // make sure we are the only occupants\n    if (!this.enhance) {\n      target.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive\n    }\n  }\n\n  var occupants = this.enhance ? toArray(target.childNodes) : null;\n  var promise = render$1(this, target, anchor, occupants);\n\n  if (occupants) {\n    while (occupants.length) { target.removeChild(occupants.pop()); }\n  }\n\n  return promise;\n}\n\nvar shouldRerender = ['template', 'partials', 'components', 'decorators', 'events'];\n\nfunction Ractive$reset(data) {\n  data = data || {};\n\n  if (!isObjectType(data)) {\n    throw new Error('The reset method takes either no arguments, or an object containing new data');\n  }\n\n  // TEMP need to tidy this up\n  data = dataConfigurator.init(this.constructor, this, { data: data });\n\n  var promise = runloop.start();\n\n  // If the root object is wrapped, try and use the wrapper's reset value\n  var wrapper = this.viewmodel.wrapper;\n  if (wrapper && wrapper.reset) {\n    if (wrapper.reset(data) === false) {\n      // reset was rejected, we need to replace the object\n      this.viewmodel.set(data);\n    }\n  } else {\n    this.viewmodel.set(data);\n  }\n\n  // reset config items and track if need to rerender\n  var changes = config.reset(this);\n  var rerender;\n\n  var i = changes.length;\n  while (i--) {\n    if (shouldRerender.indexOf(changes[i]) > -1) {\n      rerender = true;\n      break;\n    }\n  }\n\n  if (rerender) {\n    hooks.unrender.fire(this);\n    this.fragment.resetTemplate(this.template);\n    hooks.render.fire(this);\n    hooks.complete.fire(this);\n  }\n\n  runloop.end();\n\n  hooks.reset.fire(this, data);\n\n  return promise;\n}\n\nfunction collect$1(source, name, attr, dest) {\n  source.forEach(function (item) {\n    // queue to rerender if the item is a partial and the current name matches\n    if (item.type === PARTIAL && (item.refName === name || item.name === name)) {\n      item.inAttribute = attr;\n      dest.push(item);\n      return; // go no further\n    }\n\n    // if it has a fragment, process its items\n    if (item.fragment) {\n      collect$1(item.fragment.iterations || item.fragment.items, name, attr, dest);\n    } else if (isArray(item.items)) {\n      // or if it is itself a fragment, process its items\n      collect$1(item.items, name, attr, dest);\n    } else if (item.type === COMPONENT && item.instance) {\n      // or if it is a component, step in and process its items\n      // ...unless the partial is shadowed\n      if (item.instance.partials[name]) { return; }\n      collect$1(item.instance.fragment.items, name, attr, dest);\n    }\n\n    // if the item is an element, process its attributes too\n    if (item.type === ELEMENT) {\n      if (isArray(item.attributes)) {\n        collect$1(item.attributes, name, true, dest);\n      }\n    }\n  });\n}\n\nfunction resetPartial(name, partial) {\n  var collection = [];\n  collect$1(this.fragment.items, name, false, collection);\n\n  var promise = runloop.start();\n\n  this.partials[name] = partial;\n  collection.forEach(handleChange);\n\n  runloop.end();\n\n  return promise;\n}\n\n// TODO should resetTemplate be asynchronous? i.e. should it be a case\n// of outro, update template, intro? I reckon probably not, since that\n// could be achieved with unrender-resetTemplate-render. Also, it should\n// conceptually be similar to resetPartial, which couldn't be async\n\nfunction Ractive$resetTemplate(template) {\n  templateConfigurator.init(null, this, { template: template });\n\n  var transitionsEnabled = this.transitionsEnabled;\n  this.transitionsEnabled = false;\n\n  // Is this is a component, we need to set the `shouldDestroy`\n  // flag, otherwise it will assume by default that a parent node\n  // will be detached, and therefore it doesn't need to bother\n  // detaching its own nodes\n  var component = this.component;\n  if (component) { component.shouldDestroy = true; }\n  this.unrender();\n  if (component) { component.shouldDestroy = false; }\n\n  var promise = runloop.start();\n\n  // remove existing fragment and create new one\n  this.fragment.unbind().unrender(true);\n\n  this.fragment = new Fragment({\n    template: this.template,\n    root: this,\n    owner: this\n  });\n\n  var docFrag = createDocumentFragment();\n  this.fragment.bind(this.viewmodel).render(docFrag);\n\n  // if this is a component, its el may not be valid, so find a\n  // target based on the component container\n  if (component && !component.external) {\n    this.fragment.findParentNode().insertBefore(docFrag, component.findNextNode());\n  } else {\n    this.el.insertBefore(docFrag, this.anchor);\n  }\n\n  runloop.end();\n\n  this.transitionsEnabled = transitionsEnabled;\n\n  return promise;\n}\n\nvar reverse = makeArrayMethod('reverse').path;\n\nfunction Ractive$set(keypath, value, options) {\n  var ractive = this;\n\n  var opts = isObjectType(keypath) ? value : options;\n\n  return set(build(ractive, keypath, value, opts && opts.isolated), opts);\n}\n\nvar shift = makeArrayMethod('shift').path;\n\nvar sort = makeArrayMethod('sort').path;\n\nvar splice = makeArrayMethod('splice').path;\n\nfunction Ractive$subtract(keypath, d, options) {\n  var num = isNumber(d) ? -d : -1;\n  var opts = isObjectType(d) ? d : options;\n  return add(this, keypath, num, opts);\n}\n\nfunction Ractive$toggle(keypath, options) {\n  if (!isString(keypath)) {\n    throw new TypeError(badArguments);\n  }\n\n  return set(\n    gather(this, keypath, null, options && options.isolated).map(function (m) { return [m, !m.get()]; }),\n    options\n  );\n}\n\nfunction Ractive$toCSS() {\n  var cssIds = [this.cssId ].concat( this.findAllComponents().map(function (c) { return c.cssId; }));\n  var uniqueCssIds = keys(cssIds.reduce(function (ids, id) { return (ids[id] = true, ids); }, {}));\n  return getCSS(uniqueCssIds);\n}\n\nfunction Ractive$toHTML() {\n  return this.fragment.toString(true);\n}\n\nfunction toText() {\n  return this.fragment.toString(false);\n}\n\nfunction Ractive$transition(name, node, params) {\n  if (node instanceof HTMLElement) {\n    // good to go\n  } else if (isObject(node)) {\n    // omitted, use event node\n    params = node;\n  }\n\n  // if we allow query selector, then it won't work\n  // simple params like \"fast\"\n\n  // else if ( typeof node === 'string' ) {\n  // \t// query selector\n  // \tnode = this.find( node )\n  // }\n\n  node = node || this.event.node;\n\n  if (!node || !node._ractive) {\n    fatal((\"No node was supplied for transition \" + name));\n  }\n\n  params = params || {};\n  var owner = node._ractive.proxy;\n  var transition = new Transition({ owner: owner, up: owner.up, name: name, params: params });\n  transition.bind();\n\n  var promise = runloop.start();\n  runloop.registerTransition(transition);\n  runloop.end();\n\n  promise.then(function () { return transition.unbind(); });\n  return promise;\n}\n\nfunction unlink(here) {\n  var promise = runloop.start();\n  this.viewmodel.joinAll(splitKeypath(here), { lastLink: false }).unlink();\n  runloop.end();\n  return promise;\n}\n\nfunction Ractive$unrender() {\n  if (!this.fragment.rendered) {\n    warnIfDebug('ractive.unrender() was called on a Ractive instance that was not rendered');\n    return Promise.resolve();\n  }\n\n  this.unrendering = true;\n  var promise = runloop.start();\n\n  hooks.unrendering.fire(this);\n\n  // If this is a component, and the component isn't marked for destruction,\n  // don't detach nodes from the DOM unnecessarily\n  var shouldDestroy =\n    !this.component ||\n    (this.component.anchor || {}).shouldDestroy ||\n    this.component.shouldDestroy ||\n    this.shouldDestroy;\n  this.fragment.unrender(shouldDestroy);\n  if (shouldDestroy) { this.destroyed = true; }\n\n  removeFromArray(this.el.__ractive_instances__, this);\n\n  hooks.unrender.fire(this);\n\n  runloop.end();\n  this.unrendering = false;\n\n  return promise;\n}\n\nvar unshift = makeArrayMethod('unshift').path;\n\nfunction Ractive$updateModel(keypath, cascade) {\n  var promise = runloop.start();\n\n  if (!keypath) {\n    this.viewmodel.updateFromBindings(true);\n  } else {\n    this.viewmodel.joinAll(splitKeypath(keypath)).updateFromBindings(cascade !== false);\n  }\n\n  runloop.end();\n\n  return promise;\n}\n\nfunction use() {\n  var this$1 = this;\n  var plugins = [], len = arguments.length;\n  while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  plugins.forEach(function (p) {\n    p({\n      proto: this$1,\n      Ractive: this$1.constructor.Ractive,\n      instance: this$1\n    });\n  });\n  return this;\n}\n\nvar proto$9 = {\n  add: Ractive$add,\n  animate: Ractive$animate,\n  attachChild: attachChild,\n  compute: Ractive$compute,\n  detach: Ractive$detach,\n  detachChild: detachChild,\n  find: Ractive$find,\n  findAll: Ractive$findAll,\n  findAllComponents: Ractive$findAllComponents,\n  findComponent: Ractive$findComponent,\n  findContainer: Ractive$findContainer,\n  findParent: Ractive$findParent,\n  fire: Ractive$fire,\n  get: Ractive$get,\n  getLocalContext: getLocalContext,\n  getContext: getContext$2,\n  insert: Ractive$insert,\n  link: link,\n  observe: observe,\n  observeOnce: observeOnce,\n  off: Ractive$off,\n  on: Ractive$on,\n  once: Ractive$once,\n  pop: pop,\n  push: push,\n  readLink: readLink,\n  render: Ractive$render,\n  reset: Ractive$reset,\n  resetPartial: resetPartial,\n  resetTemplate: Ractive$resetTemplate,\n  reverse: reverse,\n  set: Ractive$set,\n  shift: shift,\n  sort: sort,\n  splice: splice,\n  subtract: Ractive$subtract,\n  teardown: Ractive$teardown,\n  toggle: Ractive$toggle,\n  toCSS: Ractive$toCSS,\n  toCss: Ractive$toCSS,\n  toHTML: Ractive$toHTML,\n  toHtml: Ractive$toHTML,\n  toText: toText,\n  transition: Ractive$transition,\n  unlink: unlink,\n  unrender: Ractive$unrender,\n  unshift: unshift,\n  update: Ractive$update,\n  updateModel: Ractive$updateModel,\n  use: use\n};\n\nfunction isInstance(object) {\n  return object && object instanceof this;\n}\n\nfunction styleGet(keypath, opts) {\n  return this._cssModel.joinAll(splitKeypath(keypath)).get(true, opts);\n}\n\nvar styles = [];\n\nfunction addStyle(id, css) {\n  if (styles.find(function (s) { return s.id === id; }))\n    { throw new Error((\"Extra styles with the id '\" + id + \"' have already been added.\")); }\n  styles.push({ id: id, css: css });\n\n  if (!this.css) {\n    Object.defineProperty(this, 'css', { configurable: false, writable: false, value: buildCSS });\n  }\n\n  if (!this._cssDef) {\n    Object.defineProperty(this, '_cssDef', {\n      configurable: true,\n      writable: false,\n      value: {\n        transform: false,\n        id: 'Ractive.addStyle'\n      }\n    });\n\n    addCSS(this._cssDef);\n  }\n\n  recomputeCSS(this);\n  applyCSS(true);\n}\n\nfunction buildCSS(data) {\n  return styles\n    .map(function (s) { return \"\\n/* ---- extra style \" + (s.id) + \" */\\n\" + (isFunction(s.css) ? s.css(data) : s.css); })\n    .join('');\n}\n\nfunction hasStyle(id) {\n  return !!styles.find(function (s) { return s.id === id; });\n}\n\nfunction sharedSet(keypath, value, options) {\n  var opts = isObjectType(keypath) ? value : options;\n  var model = SharedModel$1;\n\n  return set(build({ viewmodel: model }, keypath, value, true), opts);\n}\n\nfunction sharedGet(keypath, opts) {\n  return SharedModel$1.joinAll(splitKeypath(keypath)).get(true, opts);\n}\n\nfunction use$1() {\n  var this$1 = this;\n  var plugins = [], len = arguments.length;\n  while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  plugins.forEach(function (p) {\n    isFunction(p) &&\n      p({\n        proto: this$1.prototype,\n        Ractive: this$1.Ractive,\n        instance: this$1\n      });\n  });\n  return this;\n}\n\nvar callsSuper = /super\\s*\\(|\\.call\\s*\\(\\s*this/;\n\nfunction extend() {\n  var options = [], len = arguments.length;\n  while ( len-- ) options[ len ] = arguments[ len ];\n\n  if (!options.length) {\n    return extendOne(this);\n  } else {\n    return options.reduce(extendOne, this);\n  }\n}\n\nfunction extendWith(Class, options) {\n  if ( options === void 0 ) options = {};\n\n  return extendOne(this, options, Class);\n}\n\nfunction extendOne(Parent, options, Target) {\n  if ( options === void 0 ) options = {};\n\n  var proto;\n  var Child = isFunction(Target) && Target;\n\n  if (options.prototype instanceof Ractive) {\n    throw new Error(\"Ractive no longer supports multiple inheritance.\");\n  }\n\n  if (Child) {\n    if (!(Child.prototype instanceof Parent)) {\n      throw new Error(\n        \"Only classes that inherit the appropriate prototype may be used with extend\"\n      );\n    }\n    if (!callsSuper.test(Child.toString())) {\n      throw new Error(\"Only classes that call super in their constructor may be used with extend\");\n    }\n\n    proto = Child.prototype;\n  } else {\n    Child = function(options) {\n      if (!(this instanceof Child)) { return new Child(options); }\n      if (options && options.component === true) { return; }\n\n      construct(this, options || {});\n      initialise(this, options || {}, {});\n    };\n\n    proto = create(Parent.prototype);\n    proto.constructor = Child;\n\n    Child.prototype = proto;\n  }\n\n  // Static properties\n  defineProperties(Child, {\n    // alias prototype as defaults\n    defaults: { value: proto },\n\n    extend: { value: extend, writable: true, configurable: true },\n    extendWith: { value: extendWith, writable: true, configurable: true },\n    extensions: { value: [] },\n    use: { value: use$1 },\n\n    isInstance: { value: isInstance },\n\n    Parent: { value: Parent },\n    Ractive: { value: Ractive },\n\n    styleGet: { value: styleGet.bind(Child), configurable: true },\n    styleSet: { value: setCSSData.bind(Child), configurable: true }\n  });\n\n  // extend configuration\n  config.extend(Parent, proto, options, Child);\n\n  // store event and observer registries on the constructor when extending\n  Child._on = (Parent._on || []).concat(toPairs(options.on));\n  Child._observe = (Parent._observe || []).concat(toPairs(options.observe));\n\n  Parent.extensions.push(Child);\n\n  // attribute defs are not inherited, but they need to be stored\n  if (options.attributes) {\n    var attrs;\n\n    // allow an array of optional props or an object with arrays for optional and required props\n    if (isArray(options.attributes)) {\n      attrs = { optional: options.attributes, required: [] };\n    } else {\n      attrs = options.attributes;\n    }\n\n    // make sure the requisite keys actually store arrays\n    if (!isArray(attrs.required)) { attrs.required = []; }\n    if (!isArray(attrs.optional)) { attrs.optional = []; }\n\n    Child.attributes = attrs;\n  }\n\n  dataConfigurator.extend(Parent, proto, options, Child);\n\n  defineProperty(Child, 'helpers', { writable: true, value: proto.helpers });\n\n  if (isArray(options.use)) { Child.use.apply(Child, options.use); }\n\n  return Child;\n}\n\ndefineProperties(Ractive, {\n  sharedGet: { value: sharedGet },\n  sharedSet: { value: sharedSet },\n  styleGet: { configurable: true, value: styleGet.bind(Ractive) },\n  styleSet: { configurable: true, value: setCSSData.bind(Ractive) },\n  addCSS: { configurable: false, value: addStyle.bind(Ractive) },\n  hasCSS: { configurable: false, value: hasStyle.bind(Ractive) }\n});\n\nfunction macro(fn, opts) {\n  if (!isFunction(fn)) { throw new Error(\"The macro must be a function\"); }\n\n  assign(fn, opts);\n\n  defineProperties(fn, {\n    extensions: { value: [] },\n    _cssIds: { value: [] },\n    cssData: { value: assign(create(this.cssData), fn.cssData || {}) },\n\n    styleGet: { value: styleGet.bind(fn) },\n    styleSet: { value: setCSSData.bind(fn) }\n  });\n\n  defineProperty(fn, '_cssModel', { value: new CSSModel(fn) });\n\n  if (fn.css) { initCSS(fn, fn, fn); }\n\n  this.extensions.push(fn);\n\n  return fn;\n}\n\nfunction findPlugin(name, type, instance) {\n  return findInViewHierarchy(type, instance, name);\n}\n\nfunction Ractive(options) {\n  if (!(this instanceof Ractive)) { return new Ractive(options); }\n  if (options && options.component) { return; }\n\n  construct(this, options || {});\n  initialise(this, options || {}, {});\n}\n\n// check to see if we're being asked to force Ractive as a global for some weird environments\nif (win && !win.Ractive) {\n  var opts$1 = '';\n  var script =\n    document.currentScript ||\n    /* istanbul ignore next */ document.querySelector('script[data-ractive-options]');\n\n  if (script) { opts$1 = script.getAttribute('data-ractive-options') || ''; }\n\n  /* istanbul ignore next */\n  if (~opts$1.indexOf('ForceGlobal')) { win.Ractive = Ractive; }\n} else if (win) {\n  warn(\"Ractive already appears to be loaded while loading 1.4.4.\");\n}\n\nassign(Ractive.prototype, proto$9, defaults);\nRactive.prototype.constructor = Ractive;\n\n// alias prototype as `defaults`\nRactive.defaults = Ractive.prototype;\n\n// share defaults with the parser\nshared.defaults = Ractive.defaults;\nshared.Ractive = Ractive;\n\n// static properties\ndefineProperties(Ractive, {\n  // debug flag\n  DEBUG: { writable: true, value: true },\n  DEBUG_PROMISES: { writable: true, value: true },\n\n  // static methods:\n  extend: { value: extend },\n  extendWith: { value: extendWith },\n  escapeKey: { value: escapeKey },\n  evalObjectString: { value: parseJSON },\n  findPlugin: { value: findPlugin },\n  getContext: { value: getContext$1 },\n  getCSS: { value: getCSS },\n  isInstance: { value: isInstance },\n  joinKeys: { value: joinKeys },\n  macro: { value: macro },\n  normaliseKeypath: { value: normalise },\n  parse: { value: parse },\n  splitKeypath: { value: splitKeypath$1 },\n  // sharedSet and styleSet are in _extend because circular refs\n  unescapeKey: { value: unescapeKey },\n  use: { value: use$1 },\n\n  // support\n  enhance: { writable: true, value: false },\n  svg: { value: svg },\n  tick: {\n    get: function get() {\n      return batch && batch.promise;\n    }\n  },\n\n  // version\n  VERSION: { value: '1.4.4' },\n\n  // plugins\n  adaptors: { writable: true, value: {} },\n  components: { writable: true, value: {} },\n  decorators: { writable: true, value: {} },\n  easing: { writable: true, value: easing },\n  events: { writable: true, value: {} },\n  extensions: { value: [] },\n  helpers: { writable: true, value: defaults.helpers },\n  interpolators: { writable: true, value: interpolators },\n  partials: { writable: true, value: {} },\n  transitions: { writable: true, value: {} },\n\n  // CSS variables\n  cssData: { configurable: true, value: {} },\n  perComponentStyleElements: { get: splitTag, set: splitTag },\n\n  // access to @shared without an instance\n  sharedData: { value: data },\n\n  // for getting the source Ractive lib from a constructor\n  Ractive: { value: Ractive },\n\n  // to allow extending contexts\n  Context: { value: extern.Context.prototype }\n});\n\n// cssData must already be in place\ndefineProperty(Ractive, '_cssModel', {\n  configurable: true,\n  value: new CSSModel(Ractive)\n});\n\ndefineProperty(Ractive.prototype, 'rendered', {\n  get: function get() {\n    return this.fragment && this.fragment.rendered;\n  }\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Ractive);\n//# sourceMappingURL=/Users/chris/syncthing/dev/js/ractive/.gobble-build/10-transpile/.cache/ractive.mjs.map\n\n\n//# sourceURL=webpack://prom1009/./node_modules/ractive/ractive.mjs?\n}");

/***/ }),

/***/ "./src/trivia.ts":
/*!***********************!*\
  !*** ./src/trivia.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _trivia_Api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trivia/Api */ \"./src/trivia/Api.ts\");\n/* harmony import */ var _trivia_trivia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trivia/trivia */ \"./src/trivia/trivia.ts\");\n\n\nconst triviaElement = document.querySelector(\"#trivia\");\nconst token = triviaElement?.dataset.token;\nif (!triviaElement || !token) throw new Error(\"HTTP error triviaElement\");\nconst savePath = triviaElement.getAttribute(\"action\") ?? \"/save_trivia\";\nconst saveMethod = triviaElement.getAttribute(\"method\") ?? \"POST\";\nvar gameover = false;\nwindow.addEventListener(\"beforeunload\", e => {\n  if (!gameover) {\n    e.preventDefault();\n    return \"Seguro que quieres irte?\";\n  }\n});\n_trivia_Api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getTrivia(token).then(data => {\n  return new Promise(resolve => {\n    const callback = userAns => resolve(userAns);\n    const trivia = new _trivia_trivia__WEBPACK_IMPORTED_MODULE_1__[\"default\"](data, callback);\n    trivia.init();\n  });\n}).then(userAns => {\n  return _trivia_Api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].saveTrivia(userAns, token, savePath, saveMethod);\n}).then(response => {\n  gameover = true;\n  if (response.status == \"ok\") {\n    return window.location.href = response.redirect;\n  }\n  window.alert(\"Hubo un problema. Por favor, pongase en contacto con el administrador.\");\n  return window.location.href = \"/\";\n}).catch(err => {\n  console.error(err);\n  alert(\"Algo salio mal. Porfavor, pongase en contacto con el administrador.\");\n});\n\n//# sourceURL=webpack://prom1009/./src/trivia.ts?\n}");

/***/ }),

/***/ "./src/trivia/Api.ts":
/*!***************************!*\
  !*** ./src/trivia/Api.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TriviaApi)\n/* harmony export */ });\n/* harmony import */ var _pecrypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pecrypto */ \"./src/trivia/pecrypto.ts\");\n\nclass TriviaApi {\n  static async getTrivia(token, path = \"/get_trivia\") {\n    return new Promise((resolve, reject) => {\n      fetch(path).then(response => {\n        return response.json();\n      }).then(data => {\n        const triviaData = _pecrypto__WEBPACK_IMPORTED_MODULE_0__[\"default\"].decrypt(data, token);\n        resolve(triviaData);\n      });\n    });\n  }\n  static async saveTrivia(_data, token, path = \"/save_trivia\", method = \"POST\") {\n    // const cript = { s: PECrypto.encrypt({ trivia: _data }, token) };\n    return new Promise((resolve, reject) => {\n      const data = _pecrypto__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encrypt({\n        trivia: _data\n      }, token);\n      const formData = new FormData();\n      formData.append(\"s\", data);\n      fetch(path, {\n        method: method.toUpperCase(),\n        headers: {\n          \"Cache-Control\": \"no-cache\"\n        },\n        body: formData\n      }).then(response => {\n        return response.json();\n      }).then(response => {\n        resolve(response);\n      });\n    });\n  }\n}\n\n//# sourceURL=webpack://prom1009/./src/trivia/Api.ts?\n}");

/***/ }),

/***/ "./src/trivia/clock.ts":
/*!*****************************!*\
  !*** ./src/trivia/clock.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Clock)\n/* harmony export */ });\nclass Clock {\n  clockElement = document.querySelector(\"#timekeeper\");\n  clockTimerElement = document.getElementById(\"timer\");\n  constructor() {}\n  start() {\n    if (!this.clockElement) return;\n    this.clockElement.classList.remove(\"end\");\n    this.clockElement.classList.add(\"start\");\n  }\n  end() {\n    if (!this.clockElement) return;\n    this.clockElement.classList.remove(\"start\");\n    this.clockElement.classList.add(\"end\");\n  }\n  addZ(num, padding = 2) {\n    return String(num).padStart(padding, \"0\");\n  }\n  update(value) {\n    if (!this.clockTimerElement) return;\n    this.clockTimerElement.innerHTML = `${this.addZ(value.mins)}:${this.addZ(value.secs)}:${this.addZ(value.ms, 3).substring(0, 2)}`;\n  }\n}\n\n//# sourceURL=webpack://prom1009/./src/trivia/clock.ts?\n}");

/***/ }),

/***/ "./src/trivia/pecrypto.ts":
/*!********************************!*\
  !*** ./src/trivia/pecrypto.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js */ \"./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * PymEngine formatter for CryptoJS\n * @link https://pymeweb.mx\n * @version 1.0.0\n */\n\n// import \"./pecrypto.d\";\n// declare module \"pecrypto\"\n\n\n// import { CipherParams } from \"crypto-js\";\n\nconst PECrypto = {\n  // construct() {}\n  /**\n   * Encrypt any value\n   * @param {*} value\n   * @param {string} password\n   * @return {string}\n   */\n  encrypt: function (value, password) {\n    // const options =\n    return crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.encrypt(JSON.stringify(value), password, {\n      format: PECrypto\n    }).toString();\n  },\n  /**\n   * Decrypt a previously encrypted value\n   * @param {string} jsonStr\n   * @param {string} password\n   * @return {*}\n   */\n  decrypt: function (jsonStr, password) {\n    return JSON.parse(crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.decrypt(jsonStr, password, {\n      format: PECrypto\n    }).toString((crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc).Utf8));\n  },\n  /**\n   * Stringify cryptojs data\n   * @param {Object} cipherParams\n   * @return {string}\n   */\n  stringify: function (cipherParams) {\n    var j = {\n      ct: cipherParams.ciphertext.toString((crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc).Base64)\n    };\n    if (cipherParams.iv) j.iv = cipherParams.iv.toString();\n    if (cipherParams.salt) j.s = cipherParams.salt.toString();\n    return JSON.stringify(j).replace(/\\s/g, \"\");\n  },\n  /**\n   * Parse cryptojs data\n   * @param {string} jsonStr\n   * @return {*}\n   */\n  parse: function (jsonStr) {\n    var j = JSON.parse(jsonStr);\n    var cipherParams = {\n      ciphertext: crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Base64.parse(j.ct)\n    };\n    if (j.iv) cipherParams.iv = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(j.iv);\n    if (j.s) cipherParams.salt = crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Hex.parse(j.s);\n    return cipherParams;\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PECrypto);\n\n//# sourceURL=webpack://prom1009/./src/trivia/pecrypto.ts?\n}");

/***/ }),

/***/ "./src/trivia/timer.ts":
/*!*****************************!*\
  !*** ./src/trivia/timer.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Timer)\n/* harmony export */ });\n/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moment */ \"./node_modules/moment/moment.js\");\n/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_0__);\n\nclass Timer {\n  intervaloMs = 10;\n  constructor(callback) {\n    this.callback = callback;\n  }\n  start() {\n    this.moment = moment__WEBPACK_IMPORTED_MODULE_0___default()();\n    this.crono = setInterval(() => this.workflow(), this.intervaloMs);\n  }\n  pause() {\n    this.pauseStorage = moment__WEBPACK_IMPORTED_MODULE_0___default()();\n    window.clearInterval(this.crono);\n  }\n  resume() {\n    const resume = moment__WEBPACK_IMPORTED_MODULE_0___default()();\n    const crono = resume.diff(this.pauseStorage, \"ms\");\n    this.moment?.add(crono, \"ms\");\n    this.crono = setInterval(() => {\n      this.workflow();\n    }, this.intervaloMs);\n  }\n  end() {\n    window.clearInterval(this.crono);\n  }\n  addZ(num, padding = 2) {\n    return String(num).padStart(padding, \"0\");\n  }\n  cronoTimer() {\n    const actual = moment__WEBPACK_IMPORTED_MODULE_0___default()();\n    const time = actual.diff(this.moment, \"ms\");\n    const ms = time % 1000; // Obtener milisegundos restantes\n    const timeSecs = Math.floor(time / 1000); // Total de segundos\n    const secs = timeSecs % 60; // Obtener segundos restantes\n    const timeMinutes = Math.floor(timeSecs / 60); // Total de minutos\n    const mins = timeMinutes % 60; // Obtener minutos restantes\n    const hours = Math.floor(timeMinutes / 60); // Total de horas\n    const finalTime = `${this.addZ(hours)}:${this.addZ(mins)}:${this.addZ(secs)}:${this.addZ(ms, 3)}`;\n    this.values = {\n      _time: time,\n      ms: ms,\n      timeSecs: timeSecs,\n      secs: secs,\n      timeMinutes: timeMinutes,\n      mins: mins,\n      hours: hours,\n      finalTime: finalTime\n    };\n  }\n  workflow() {\n    this.cronoTimer();\n    this.callback(this.values);\n  }\n}\n\n//# sourceURL=webpack://prom1009/./src/trivia/timer.ts?\n}");

/***/ }),

/***/ "./src/trivia/trivia.ts":
/*!******************************!*\
  !*** ./src/trivia/trivia.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Trivia)\n/* harmony export */ });\n/* harmony import */ var ractive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ractive */ \"./node_modules/ractive/ractive.mjs\");\n/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timer */ \"./src/trivia/timer.ts\");\n/* harmony import */ var _clock__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./clock */ \"./src/trivia/clock.ts\");\n// import { format } from 'crypto-js';\n\n\n\n// import PECrypto from \"./pecrypto\";\n\nclass Trivia {\n  #timer = new _timer__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.updateTime.bind(this));\n  #data = [];\n  #trivia;\n  clock = new _clock__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n  config = {};\n  triviaElement = document.querySelector(\"#trivia\");\n  hiddenInputs = new ractive__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    target: \"#hidden__inputs\",\n    template: \"#hidden__inputs--template\",\n    data: {\n      TIME_MS: \"0\",\n      TIMER_CLOCK: \"00:00:00\"\n    }\n  });\n  triviaQuestion = new ractive__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    target: \"#trivia__question\",\n    template: \"#trivia__question--template\"\n  });\n  triviaAnswers = new ractive__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    target: \"#trivia__options\",\n    template: \"#trivia__options--template\",\n    on: {\n      handleInputChange: function () {\n        const submitButtons = document.querySelectorAll('[type=\"submit\"]');\n        submitButtons.forEach(button => {\n          button.classList.remove(\"disabled\");\n          button.disabled = false;\n        });\n      }\n    }\n  });\n  #resolver;\n  constructor(config, callback) {\n    this.#resolver = callback;\n    this.config = config.config;\n    this.#trivia = config.trivia;\n    this.initSubmitHandler();\n    this.disableSubmit();\n  }\n  init() {\n    this.#timer.start();\n    this.clock.start();\n    this.renderTrivia();\n  }\n  updateTime(time) {\n    this.clock.update(time);\n    this.hiddenInputs.set(\"TIME_MS\", time._time);\n    this.hiddenInputs.set(\"TIMER_CLOCK\", time.finalTime);\n  }\n  get loader() {\n    const loader = document.querySelector(\"dialog#loader\");\n    if (!loader) return false;\n    return loader;\n  }\n  initSubmitHandler() {\n    this.triviaElement?.addEventListener(\"submit\", e => {\n      e.preventDefault();\n      if (!(e.currentTarget instanceof HTMLFormElement)) return;\n      const formData = new FormData(e.currentTarget);\n      const data = Array.from(formData.entries()).map(([name, value]) => ({\n        name,\n        value\n      }));\n      this.setData(data);\n      this.#logic();\n    });\n  }\n  setData(data) {\n    const _data = {};\n    for (const item of data) {\n      var name = item[\"name\"];\n      var value = item[\"value\"];\n      _data[name] = value.toString();\n    }\n    const userAns = {\n      trivia_id: Number.parseInt(_data[\"trivia_id\"]),\n      ans: _data[\"ans\"],\n      tiempo: Number.parseInt(_data[\"tiempo\"]),\n      timer: _data[\"timer\"]\n    };\n    this.#data.push(userAns);\n    this.#trivia?.shift();\n  }\n  #logic() {\n    this.clearTrivia();\n    this.disableSubmit();\n    if (this.#trivia !== undefined && this.#trivia.length) {\n      return this.renderTrivia();\n    }\n    this.#finish();\n  }\n  disableSubmit() {\n    const submitButtons = document.querySelectorAll('[type=\"submit\"]');\n    submitButtons.forEach(button => {\n      button.classList.add(\"disabled\");\n      button.disabled = true;\n    });\n  }\n  clearTrivia() {\n    this.triviaAnswers.set(\"DISPLAY\", \"none\");\n    this.triviaAnswers.set(\"OPTIONS\", []);\n    this.disableSubmit();\n  }\n  renderTrivia() {\n    if (this.#trivia === undefined) return this.#finish();\n    const question = this.#trivia[0];\n    question[\"options\"].forEach((option, index) => {\n      option.ID = `opc_${new Date().getTime().toString(36)}-${index}`;\n    });\n    this.triviaQuestion.set(\"TRIVIA_ID\", question.TRIVIA_ID);\n    this.triviaQuestion.set(\"TRIVIA_PREGUNTA\", question.TRIVIA_PREGUNTA);\n    this.triviaAnswers.set(\"DISPLAY\", \"block\");\n    this.triviaAnswers.set(\"OPTIONS\", question.options);\n  }\n  #finish() {\n    if (this.loader) this.loader.showModal();\n    this.#timer.end();\n    this.clock.end();\n    const ans = this.#data;\n    if (this.#resolver !== undefined) this.#resolver(ans);\n  }\n}\n\n//# sourceURL=webpack://prom1009/./src/trivia/trivia.ts?\n}");

/***/ }),

/***/ "?9157":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://prom1009/crypto_(ignored)?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/trivia.ts");
/******/ 	
/******/ })()
;